<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-10-29 周二 01:33 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>UML和模式应用笔记</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel=stylesheet href=/global.css type=text/css/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">UML和模式应用笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org5744c32">1. 第一部分 绪论</a>
<ul>
<li><a href="#org62e5326">1.1. 第一章 面向对象分析和设计</a></li>
<li><a href="#org5dde0e7">1.2. 第二章 迭代、进化和敏捷</a></li>
</ul>
</li>
<li><a href="#orgb9c23a0">2. 第二部分 初始阶段</a>
<ul>
<li><a href="#org2eda5f4">2.1. 第三章 案例研究</a></li>
<li><a href="#org677a0f6">2.2. 第四章 初始不是需求阶段</a></li>
<li><a href="#orgdc1aee3">2.3. 第五章 进化式需求</a></li>
<li><a href="#org18888f7">2.4. 第六章 用例</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org5744c32" class="outline-2">
<h2 id="org5744c32"><span class="section-number-2">1</span> 第一部分 绪论</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org62e5326" class="outline-3">
<h3 id="org62e5326"><span class="section-number-3">1.1</span> 第一章 面向对象分析和设计</h3>
<div class="outline-text-3" id="text-1-1">
<p>
分析和设计这两个术语经常出现在一起，人们也很常常混淆二者的含义，其他它们是完全不同的概念。分析是对需求（或问题）的调查研究。设计是已经定义的问题，构造一个逻辑上的解决方案。分析让我们知道面临着什么问题，设计告诉我们要如何去解决。这样看来，分析在设计之前，设计在分析之后。实际上人们对问题和解的认识是不断细化和深入的，因此在工作中往往是分析、设计、分析、设计不断循环，直到问题和解足够的“好”。什么是“好”呢？就是得到涉众的一致认可。面向对象分析和设计就是使用面向对象这个工具进行分析和设计。对象这个词在分析和设计阶段具有不同的含义。在分析阶段，对象是业务领域内的概念。在设计阶段，对象指软件对象，如模块、组件、类等。面向对象分析就是从使用者的视角出发，发现和描述业务领域内的概念，建立一个业务模型。面向对象分析的的主要工作内容是编写用例，并通过用例发现和建立领域模型。面向对象设计将业务领域概念映射为可以编码实现的软件对象。主要的工作包括分配软件对象职责、确定软件对象协作方式和详细设计软件类。在使用面向对象这个工具时，熟练地为对象分配职责是一项非常重要的能力。
</p>


<p>
示例：航班信息系统
</p>
<blockquote>
<p>
业务模型：
航班信息系统包含飞机、航班、飞行员等概念。飞机有尾翼号。
</p>


<p>
领域模型：
</p>
<pre class="example">
public class Plane {
    private String tailNumber;
    public List getFlightHistory() {...}
}
</pre>
</blockquote>


<p>
示例：骰子游戏。
</p>
<blockquote>
<p>
玩家掷2个骰子，如果总点数为7则玩家获得胜利，否则输掉游戏。我们先从定义用例开始。用例（use case）是用户使用系统（或解决方案）的场景和情节。
</p>
</blockquote>

<p>
下面我们用这个骰子游戏来展示如何面向对象分析和设计。我们把工作分为定义用例、定义领域模型、分配对象职责并绘制交互图和定义设计类图4个步骤。定义用例和领域模型属于分析阶段，分配对象职责并绘制交互图和设计类图是设计阶段。第一个步骤是定义用例。用例描述了使用者（利益相关者）和软件交互的场景。用例告诉我们，使用者是如何使用软件达成业务目标的。用例是捕获需求和记录需求的重要工具。下面是掷骰子游戏的一个用例：
</p>
<blockquote>
<p>
用例1：玩家请求掷骰子。系统展示结果。如果总点数是7则玩家胜，否则玩家输。
</p>
</blockquote>


<p>
第二个步骤是定义领域模型。这个步骤需要从用例中提取概念、属性和关联，并抽象成领域模型（domain model）。在掷骰子游戏中有3个概念，分别是玩家、骰子、游戏。三者的关联是游戏包含一个玩家和两个骰子。玩家有名字，骰子有点数，这些都是属性。这一步骤完成后，我们得到了一个领域模型，标志着面向对象分析工作结束。
</p>


<p>
下一个步骤是分配对象职责并绘制交互图。从这里我们开始进入设计阶段。前面提到过，设计阶段讨论的对象主要指软件对象。这一步骤我们主要关注如何将概念、关联以及交互映射成软件对象。通常一个概念（领域对象）对应一个软件对象，但这不是绝对的。这个步骤不会关注某个类的具体细节，而是考察各个类在软件中如何协作。下面描述了游戏中各个概念的职责和概念之间的交互：
</p>
<blockquote>
<p>
玩家 玩游戏
游戏 掷骰子1
游戏 获得骰子1点数
游戏 掷骰子1  
游戏 获得骰子2点数
游戏 判断并展示结果
</p>
</blockquote>

<p>
使用UML可以更直观的展示概念和交互，比如下面的时序图：
</p>

<div class="figure">
<p><img src="./dice_game.png" alt="dice_game.png" />
</p>
</div>

<p>
可能你已经注意到，这里的描述和领域模型稍有不同。在领域模型中，“掷骰子”行为是“玩家”所拥有的。这是因为在设计阶段必须考虑方案的实施（编码），不能简单的将领域对象直接映射为软件对象。软件设计可以从真实世界中获得灵感，但绝不是对真实世界的简单模拟。
</p>


<p>
最后一个步骤是，定义设计类图。在这里对具体的类进行详细设计，以指导后续的编码工作。
</p>
<blockquote>
<p>

</p>

<p>
类：DiceGame
属性：die1 类型：Die
属性：die2 类型：Die
行为：play()
</p>

<p>
类：Die
属性：faceValue 类型：int
行为：getFaceValue(): int
行为：roll()
</p>
</blockquote>

<p>
至此分析和设计工作告于段落。这里再说一点，分析和设计工作的产出物可以使用任何形式来展示。这里之所以选择UML，是因为UML具有直观形象、应用广泛、提供多层次视角等优点。
</p>


<p>
一个成功的软件必须是贴合用户实际需求的。面向对象分析和设计可以帮助开发团队做到这一点，面向对象分析和设计产出的软件模型更接近领域模型。领域驱动设计是另一种提高软件价值的开发方法，在这里不做讨论。
</p>
</div>
</div>

<div id="outline-container-org5dde0e7" class="outline-3">
<h3 id="org5dde0e7"><span class="section-number-3">1.2</span> 第二章 迭代、进化和敏捷</h3>
<div class="outline-text-3" id="text-1-2">
<p>
软件开发过程是构造、部署以及维护软件的方式。对于小的软件（比如一个人在一天之内就可以开发完成），开发过程并不重要。但是对于大型软件，由于需要多人协作开发，为了保证软件质量和软件价值，必须有一定的规范和流程进行约束。规范和流程的总和就是开发过程。高价值和高质量的软件往往是，高质量开发过程的产物。而一个低劣开发过程要想产出高质量的软件，就像彩票中奖一样机会渺茫。
</p>


<p>
下面介绍的是统一过程（Unified Process，UP）。这是一种灵活的迭代式软件开发过程。迭代式开发过程将整个开发周期划分为若干个迭代周期，每个迭代周期都产出一个可交付的软件，并在周期结束时进行验证。一开始软件比较粗糙，只有主要功能。随着迭代期数的增加，软件不断完善，最终达到用户满意的状态。迭代式开发过程既不是从上到下的，也不是从下到上的，它是从粗到细的。将画家绘画一样，先勾画线稿，接着上色，最后修饰完善。迭代式开发的另一个特点是迭代周期较短且是固定的。这两个特点保证软件功能不会大幅偏离用户预期，以及项目进展不会大幅偏离计划。
</p>


<p>
下面我们用一个案例来展示迭代时开发过程：
</p>
<blockquote>
<p>
开发团队决定采用迭代式开发过程，并计划采用20个迭代周期，每个周期的长度是三周。
</p>


<p>
在开始迭代之前首先是召开需求工作会议。需求工作会议也是时间定量的，经讨论确定为两天。业务代表、首席架构师和开发人员都要出席。第一天上午进行高阶需求分析。首先确定用例和特性的名称，以及关键的非功能需求。将这些名称编号，加入高阶用例列表。接着咨询业务代表和首席架构师，从高阶用例列表中选择10%的列表项，加入本期用例列表。选择的标准有三点：
</p>

<ol class="org-ol">
<li>具有重要的架构意义，比如为了实现软件必须构造的核心架构。</li>
<li>具有高业务价值。</li>
<li>具有高风险，比如每秒处理500个并发交易。</li>
</ol>

<p>
在剩下的一天半里，团队针对本期用例列表中的用例进行详细分析。会议结束后，已经对10%的用例进行了详细分析，对90%的用例进行了高阶分析。
</p>


<p>
接下来进入第一次迭代。首先要召开一个简短的迭代计划会议，确认本次迭代计划完成本期用例列表中的哪些子集。在开始的前两天，团队分组进行建模和设计，画出UML和其他模型的草图。接下来的时间用于开发、测试和集成。测试是非常重要的工作。在迭代中要进行大量的测试，包括单元测试、验收测试、负载均衡测试和可用性测试。在距离迭代结束的前一周，团队召开一个简短的会议确认迭代进度。如果发现无法完成迭代目标，缩小本地迭代范围，将次要功能放回到任务列表。在最后一周的星期二，冻结代码并进行测试和集成，建立迭代基线。在星期三上午，对涉众展示系统并要求反馈。在最后一周的星期三和星期四，召开第二次需求工作会议，对上次会议的材料进行复查和精细化，选择另外10%-15%的高阶用例进行详细分析。在周五上午举行下一迭代的计划会议。在第一个迭代完成的时候，大约有20%的用例完成了详细分析，80%的用例完成了高阶分析。
</p>


<p>
以相同的步骤进行后续迭代。在四到五次需求会议后，大致有90%的用例完成了详细分析。并且这些分析是基于反馈的，质量远远高于纯粹的推测。至此大部分重要需求已经被捕获，后续不再需要召开需求会议了。
</p>
</blockquote>


<p>
统一过程也是采用迭代的一种开发过程。它将迭代分为四个阶段：
</p>
<ul class="org-ul">
<li>初始。构想业务案例、范围，进行初步评估。</li>
<li>细化。对需求进行更细致的分析和设计，实现核心架构。</li>
<li>构造。对剩余部分进行实现，准备部署。</li>
<li>移交。beta测试和部署。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgb9c23a0" class="outline-2">
<h2 id="orgb9c23a0"><span class="section-number-2">2</span> 第二部分 初始阶段</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org2eda5f4" class="outline-3">
<h3 id="org2eda5f4"><span class="section-number-3">2.1</span> 第三章 案例研究</h3>
<div class="outline-text-3" id="text-2-1">
<p>
本书以两个软件的开发作为例子，详细介绍迭代式开发和模式设计。这两个例子是NextGen POS系统和Monopoly游戏。
</p>
</div>
</div>

<div id="outline-container-org677a0f6" class="outline-3">
<h3 id="org677a0f6"><span class="section-number-3">2.2</span> 第四章 初始不是需求阶段</h3>
<div class="outline-text-3" id="text-2-2">
<p>
初始阶段不是需求分析或设计阶段。初始阶段要预见项目的范围、设想和业务案例，这些工作可以回答一个问题，项目是否值得继续认真研究？如果大家（涉众）对项目的设想较为一致，并且都认为应该继续推进项目，这一阶段的工作就完成了。初始阶段通常持续时间较短，一般不超过一周。
</p>


<p>
初始阶段通常会产出以下制品或其草稿：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">制品</td>
<td class="org-left">说明</td>
</tr>

<tr>
<td class="org-left">设想和业务用例</td>
<td class="org-left">描述高阶目标与约束、业务案例，并提供执行摘要。</td>
</tr>

<tr>
<td class="org-left">用例模型</td>
<td class="org-left">描述功能需求。在初始阶段只需要确定大部分用例的名称，并详细分析优先级最高的部分（如10%）用例。</td>
</tr>

<tr>
<td class="org-left">补充性规格说明</td>
<td class="org-left">描述非功能需求。这些需求可能会影响架构设计。</td>
</tr>

<tr>
<td class="org-left">词汇表</td>
<td class="org-left">关键领域术语和数据字典。</td>
</tr>

<tr>
<td class="org-left">风险列表和风险管理计划</td>
<td class="org-left">描述风险（业务、技术、资源和进度）及应对和缓解的方法。</td>
</tr>

<tr>
<td class="org-left">原型和概念验证</td>
<td class="org-left">澄清设想，验证技术思路。</td>
</tr>

<tr>
<td class="org-left">迭代计划</td>
<td class="org-left">描述第一个细化迭代任务。</td>
</tr>

<tr>
<td class="org-left">阶段计划和软件开发计划</td>
<td class="org-left">初步估计细化阶段需要的时间和工作量。</td>
</tr>

<tr>
<td class="org-left">开发案例</td>
<td class="org-left">描述项目特有的信息。</td>
</tr>
</tbody>
</table>

<p>
初始阶段并不要求完成全部浙西制品，可以只提供部分制品，制品本身也可以是部分完成的。后续阶段会持续细化这些制品。要记住，初始阶段的核心任务是让大家对项目设想达成一致，文档只是交流和记录的方式。
</p>
</div>
</div>


<div id="outline-container-orgdc1aee3" class="outline-3">
<h3 id="orgdc1aee3"><span class="section-number-3">2.3</span> 第五章 进化式需求</h3>
<div class="outline-text-3" id="text-2-3">
<p>
需求是系统必须提供的能力和满足的条件。通常在短时间（项目开发周期）内，用户的实际需求是不变的，但是涉众对需求的理解却是不断变化的。就像是同一块草地，在晴天和阴天时候看起来颜色不同。因此在开始编码前尝试捕获全部用例的尝试往往导致软件项目失败。统一过程考虑到了这一点，它将需求看作是不断变化的，并要求需求管理必须支持寻找、记录、组织和跟踪不断变更的需求。在这里后后面的部分，我们把“需求”看作为对“实际需求”的理解。
</p>


<p>
统一过程要求将需求按照FURPS+模型分为以下几类：
</p>

<ul class="org-ul">
<li>Functional 功能。特性、功能、安全性。</li>
<li>Usability 可用。人性化因素、帮助、文档。</li>
<li>Reliablity 可靠。故障频率、可恢复性、可预测性。</li>
<li>Performance 性能。响应时间、吞吐量、准确性、有效性、资源利用率。</li>
<li>Supportability 可支持。适应性、可维护性、国际化、可配置性。</li>
<li>Implementation 实现。资源限制、语言和工具、硬件等。</li>
<li>Interface 接口。加强于外部系统接口之上的约束。</li>
<li>Operation 操作。对其操作设置的系统管理。</li>
<li>Packaging 包装。例如物理的包装盒。</li>
<li>Legal 授权。许可证或其他方式。</li>
</ul>


<p>
对于需求分析工作，统一过程提供了一些制品，这些制品也是可选的：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">制品</td>
<td class="org-left">说明</td>
</tr>

<tr>
<td class="org-left">用例模型</td>
<td class="org-left">一组使用系统的典型场景。主要拥有描述功能需求。</td>
</tr>

<tr>
<td class="org-left">补充性规格说明</td>
<td class="org-left">用语言描述非功能需求。</td>
</tr>

<tr>
<td class="org-left">词汇表</td>
<td class="org-left">重要术语的定义。</td>
</tr>

<tr>
<td class="org-left">设想</td>
<td class="org-left">对高阶需求的概况。</td>
</tr>

<tr>
<td class="org-left">业务规则</td>
<td class="org-left">软件所服务的行业内，必须遵守的法律、法规和行业规则。</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org18888f7" class="outline-3">
<h3 id="org18888f7"><span class="section-number-3">2.4</span> 第六章 用例</h3>
<div class="outline-text-3" id="text-2-4">
<p>
用例是文本形式的情节描述。用例包含参与者和场景。参与者（actor）是具有行为的人或其他系统（比如时钟）。场景（scenario）是参与者和系统（System under Discussion，SuD）之间的一系列特定的活动和交互，也叫做用例实例（use case instance）。用例（use case）就是一组相关的成功和失败场景集合。参与者分为3类：主要参与者（primary actor）、协助参与者（supporting actor）和幕后参与者（offstage actor）。主要参与者是驱动用例的用户目标，是使用SuD完成服务的对象。对于收银系统，收银员就是主要参与者。协助参与者为SuD提供服务。协助参与者通常是外部计算机系统。幕后参与者在用例中具有影响或利益，但不是协助参与者。比如收银系统中，税务部门就是幕后参与者。
</p>

<p>
Alistair Cockburn提供了一个用例模板
</p>

<p>
部分                 注释
<code>==================</code> <code>=======================================</code>
用例名称             以动词开头
范围                 要设计的系统
级别                 “用户目标”或“子功能”
主要参与者           调用系统，使之交付服务
涉众及其关注点       关注该用例的人，及其需要
前置条件             值得告诉读者的，开始前必须为真的条件
成功保证             值得告知读者的，成功完成必须满足的条件
主成功场景           典型的、无条件的、理想方式的成功场景
扩展                 成功或失败的替代场景
特殊需求             相关的非功能性需求
技术和数据变元表     不同的I/O方法和数据格式
发生频率             影响对实现的调查、测试和时间安排
杂项                 例如未决问题
</p>

<p>
下面是一个用例示例：
</p>

<p>
用例UC1：处理销售。
范围：NextGen POS应用。
级别：用户目标。
主要参与者：收银员。
涉众及其关注点：
1 收银员：希望能够准确、快速地输入，而且没有支付错误。
2 售货员：希望自动更新销售提成。
3 顾客：希望以最小代价完成购买活动并得到快速服务。希望便捷、清晰地看到所输入的商品项目和价格。希望得到购买凭证，以便退货。
4 公司：希望准确地记录交易，满足顾客需求。希望确保记录了支付授权服务的支付票据。希望有一定的容错性，即使在某些服务器构件不可用时（如远程信用卡验证）也能够完成销售。希望能够自动、快速地更新账务和库存信息。
5 经理：希望能够快速执行超控操作，并易于更正收银员的不当操作。
6 政府税收代理：希望能从每笔交易中抽取税金。可能存在多级税务代理，比如国家级、州级和县级。
7 支付授权服务：希望接收到协议和格式正确的数字授权请求。希望准确计算对商店的应付款。
前置条件：收银员必须经过确认和认证。
成功保证（或后置条件）：存储销售信息。准确计算税金。更新账务和库存信息。记录提成。生成票据。记录支付授权的批准。
主成功场景（或基本流程）：
1 顾客携带所购商品或服务到收银台通过POS机付款。
2 收银员开始一次新的销售交易。
3 收银员输入商品条码。
4 系统逐条记录出售的商品，并显示该商品的描述、价格和累计额。价格通过一组价格规则计算。
收银员重复3-4步，直到输入结束。
5 系统显示总额和所计算的税金。
6 收银员告知顾客总额，并请顾客付款。
7 顾客付款，系统处理支付。
8 系统记录完整的销售信息，并将销售和支付信息发送到外部的账务系统（进行账务处理和提成）和库存系统（更新库存）。
9 系统打印票据。
10 顾客携带商品和票据离开（如果有）。
扩展（或替代流程）：
*a 经理在任意时刻要求进行超控操作：
  1 系统进入经理授权模式。
  2 经理或收银员执行某一经理模式的操作。例如，变更现金结余，恢复其他登录者中断的销售交易，取消销售交易等。
  3 系统恢复到收银员授权模式。
*b 系统在任意时刻失败：
  为了支持恢复和更正账务处理，要保证所有交易的敏感状态和时间都能够从场景的任何一步中完全恢复。
  1 收银员重启系统，登录，请求恢复上次状态。
  2 系统重建上次状态。
    2a 系统在恢复过程中检测到异常。
      1 系统向收银员提示错误，记录此错误，并进入一个初始状态。
      2 收银员开始一次新的销售交易。
1a 客户或经理需要恢复一个中断的销售交易。
  1 收银员执行恢复操作，并且输入ID以提取对应的销售交易。
  2 系统显示被恢复的销售交易状态及其小计。
    2a 未发现对应的销售交易。
      1 系统向收银员提示错误。
      2 收银员可能会开始一个新的销售交易，并重新输入所有商品。
  3 收银员继续该次销售交易（可能要输入更多的商品或处理支付）。
2-4a 顾客告诉收银员其免税状态（例如：年长者，本国人等）。
  1 收银员进行核实，并输入免税状态代码。
  2 系统记录该状态编码（在计算税金时使用）。
3a 无效商品ID（在系统中未发现）：
  1 系统提示错误并拒绝输入该ID。
  2 收银员响应该错误。
    2a 商品ID可读（例如，数字型的UPC（通用产品代码））：
      1 收银员手动输入商品ID。
      2 系统显示商品项目的描述和价格。
        2a 无效商品ID：系统提示错误。收银员尝试其他方式。
    2b 系统内不存在该商品ID，但是商品附有价签。
      1 收银员请求经理执行超控操作。
      2 经理执行响应的超控操作。
      3 收银员选择手工输入价格，输入价签上的价格，并且请求对该价目进行标准计税。（因为没有产品信息，计税引擎无法确定如何计税。）
    2c 收银员通过执行寻找产品帮助以获取正确的商品ID及其价格。
    2d 另外，收银员可以向其他员工询问商品ID或价格，然后手工输入ID或价格（参见以上内容）。
3b 当有多个商品项目属于同一类别的时候（如5个汉堡），不必记录每个商品项目的唯一标识：
  1 收银员可以输入类别的标识和商品的数量。
3c 需要手工输入类别和价格（例如，花卉或纸牌及其价格）：
  1 收银员手工输入特定的类别代码及其价格。
3-6a 顾客要求收银员从所购商品中去掉一项：
  所去除商品的价格必须小于收银员的权限，否则需要经理执行超控操作。
  1 收银员输入商品ID并将其删除。
  2 系统删除该项目并显示更新后的累计额。
    2a 商品价格超过了收银员权限：
      1 系统提示错误，并建立经理超控。
      2 收银员请求经理超控，完成超控后，重做该操作。
3-6b 顾客要求收银员取消销售交易。
  1 收银员在系统中取消销售交易。
3-6c 收银员延迟销售交易。
  1 系统记录销售交易信息，使其能够在任何POS登录中恢复操作。
  2 系统显示用来恢复销售交易的“延迟票据”，其中包含商品项目和销售交易ID。
4a 系统定义的商品价格不是顾客预期的价格（顾客对此产生抱怨并要求减价）：
  1 收银员请求经理批准。
  2 经理执行超控操作。
  3 收银员手工输入超控后的价格。
  4 系统显示新价格。
5a 系统检测到与外部税务计算系统服务的通信故障：
  1 系统在POS机节点上重启此服务，并继续操作。
    1a 系统检测到该服务无法重启
      1 系统提示错误。
      2 收银员手动计算和输入税金，或者取消该销售交易。
5b 顾客声称他们符合打折条件（例如，是雇员或重要顾客）
5c 顾客要求兑现账户积分，用于此次销售交易：
  1 收银员提交积分请求。
  2 收银员输入顾客ID。
  3 系统应用积分直到价格为0，同时扣除结余积分。
6a 顾客要求现金付款，但所携现金不足：
  1 顾客要求使用其他支付方式。
    1a 顾客要求取消此次销售交易，收银员在系统上取消该交易。
7a 现金支付。
  1 收银员输入收取的现金额。
  2 系统显示找零余额，并弹出现金抽屉。
  3 收银员放入收取的现金，并给顾客找零。
  4 系统记录该现金支付。
7b 信用卡支付：
  1 顾客输入信用卡账户信息。
  2 系统显示其支付信息以备验证。
  3 收银员确认。
    3a 收银员取消付款步骤。
      1 系统回复到“商品输入”模式。
  4 系统向外部支付授权服务系统发送支付授权请求，并请求批准该支付。
    4a 系统检测到与外部系统协作是故障。
      1 系统向收银员提示错误。
      2 收银员请求顾客更换支付方式。
  5 系统收到批准支付的应答并提示收银员，同时弹出现金抽屉（以便放入签名后的信用卡支付票据）。
    5a 系统收到拒绝支付的应答
      1 系统向收银员提示支付被拒绝。
      2 收银员请求顾客更换支付方式。
    5b 应答超时。
      1 系统向收银员提示支付被拒绝。
      2 收银员请求顾客更换支付方式。
  6 系统记录信用卡支付信息，其中包括支付批准。
  7 系统显示信用卡支付的签名输入机制。
  8 收银员请求顾客签署信用卡支付。顾客输入签名。
  9 如果在纸质票据上签名，则收银员将该票据放入现金抽屉并关闭抽屉。
7c 支票支付&#x2026;
7d 记账支付&#x2026;
7e 收银员取消支付步骤：
  1 系统回到“商品输入”模式。
7f 顾客出示优惠券：
  1 在处理支付之前，收银员记录每张优惠券，系统扣除相应金额。系统记录已使用的优惠券以备账务处理只用。
    1a 输入的优惠券不适用于所购商品。
      1 系统向收银员提示错误。
9a 存在产品回扣。
  1 系统对每个具有回扣的商品给出回扣表单和票据。
9b 股票索要赠品票据（不显示价格）。
  1 收银员请求赠品票据，系统给出赠品票据。
9c 打印票据。
  1 如果系统能够检测到错误，给出提示。
  2 收银员更换纸张。
  3 收银员请求打印其他票据。
特殊需求：
</p>
<ul class="org-ul">
<li>使用大尺寸平面显示触摸屏UI。文本信息可见距离为1米。</li>
<li>90%的信用卡授权响应时间小于30秒。</li>
<li>由于某些原因，我们希望在访问远程服务（如库存系统）失败的情况下具有比较强的恢复功能。</li>
<li>支持文本显示的语言国际化。</li>
<li>在步骤3和步骤7之间能够加入可插拔的业务规则。</li>
</ul>
<p>
&#x2026;
技术与数据变元表：
*a 经理超控需要刷卡（由读卡器读取超控卡）或在键盘上输入授权码。
3a 商品ID可以用条码扫描器（如果有条形码）或键盘输入。
3b 商品ID可以使用UPC（通用产品代码）、EAN（欧洲物品编码）、JAN（日本物品编码）或SKU（库存信息）等任何一种编码方式。
7a 信用卡账户信息可以用读卡器或键盘输入。
7b 记录在纸质票据上的信用卡支付签名。但我们预测，两年内会有许多顾客将希望使用数字签名。
发生频率：可能会不断地发生。
未决问题：
</p>
<ul class="org-ul">
<li>税法如何变化？</li>
<li>研究远程服务的恢复问题。</li>
<li>针对不同的业务需要怎样进行定制。</li>
<li>收银员是否必须从系统注销后带走他们的现金抽屉。</li>
<li>顾客是否可以直接使用读卡器，还是必须由收银员完成？</li>
</ul>

<p>
在这个模板中，范围界定了要设计的系统。如果用例针对一个软件系统的使用，就叫做系统用例（system use case）。如果描述了顾客和相关人员如何使用业务，叫做业务用例（business use case）。业务用例规模更大。类似的，级别分为用户目标级别（user-goal level）和子功能级别（subfunction-level）。
</p>

<p>
要注意的是，在主成功场景（基本流程）中只能记录一个理想路径。其他的分支和扩展放到扩展部分说明。场景记录以下3中步骤：参与者之间的交互，确认过程，系统完成时的状态变更。
</p>

<p>
编写早期用例的一个重要方法是摒除用户界面，只考虑本质的业务操作意图。在设计子系统时在考虑这些细节。
</p>

<p>
编写用例要使用黑盒风格，如：系统记录销售。反例是：系统将销售记录写入数据库。
</p>

<p>
发现用例的方法：
#. 选择系统边界。系统仅仅是软件应用，还是软硬件结合的整体？是一个人用，还是一个组织在用？
#. 确定主要参与者。哪些人或物通过系统实现了目标？
#. 确定每个主要参与者的目标。
#. 定义满足用户目标的用例。
</p>

<p>
有助于发现主要参与者和目标的问题：
#. 谁来启动和停止系统？
#. 谁来完成用户管理和安全管理？
#. 谁来完成系统管理？
#. “时间”是参与者吗？系统是否需要响应时间事件来完成某些活动？
#. 当系统失败时，是否存在监控进程将系统重启？
#. 软件升级是如何处理的？采用“推”模式还是“拉”模式？
#. 除了人作为主要参与者之外，还有其他外部的软件或者自动机器系统调用了该系统的服务吗？
#. 谁来考察系统活动或性能？
#. 谁来考察日志？是否可以远程检索？
#. 系统发生错误或故障时应通知谁？
</p>

<p>
建立领域模型的方法：
#. 寻找概念类。
#. 绘制UML类图。
#. 添加关联和属性。
</p>

<p>
寻找概念类的方法：
#. 重用和修改现有模型。
#. 使用分类列表。
#. 确定名词短语。
</p>

<p>
概念类和属性的区分方法是：如果某个概念类不是现实世界中的数字或文本，这就是一个概念类，不是属性。
</p>

<p>
如果两个领域对象在一段时间内是联系在一起的，则两个概念类存在关联。
领域模型的属性应该只是简单的数字、文本等类型，不应包含其他领域模型。要表示两个领域模型的关联，要使用关系，而不是属性。在领域模型中，任何属性都不能表示外键。
</p>

<p>
在领域模型中，是否为一些数据类型（如字符串）建立领域模型呢？如果满足下列中的某一点，需要这样做：
</p>

<p>
#. 由不同的小节组成。如400-800-1234。
#. 支持解析和校验。如身份证号码。
#. 具有其他属性，如日期。
</p>

<p>
创建者（Creator）模式：
问题：谁创建了类A实例？
方案：如果满足下列条件之一，创建类A实例的职责应当分配给类B：
#. B包含A或组成A的聚集。
#. B记录A。
#. B紧密使用A。
#. B具有A的初始化数据。
优点：支持低耦合。
相关模式：抽象工厂、工厂
</p>

<p>
信息专家（Information Export）模式
问题：为对象分配职责的基本原则是什么？
方案：把职责分配给具有完成该职责所需信息的类，这个类叫做信息专家。
优点：维持信息的封装性，支持低耦合。
</p>

<p>
低耦合（Low Coupling）模式
问题：如何减少因变化产生的影响？
方案：分配职责以使耦合保持在较低的水平。
优点：不受其他构件变化的影响。易于单独理解。便于复用。
</p>

<p>
耦合是元素和其他元素连接、感知和依赖程度的度量。高耦合导致的问题：相关类的变化导致本体被迫变化。难以单独理解。使用类时需要它所依赖的类。
</p>

<p>
控制器Controller
在UI层之上首先接收和协调（控制）系统操作的对象是什么？
方案：
</p>
<ol class="org-ol">
<li>代表系统、根对象、运行软件的设备或主要的子系统。</li>
<li>代表发生操作的用例场景。</li>
</ol>
<p>
优点：增加了可复用和接口可插拔的潜力。获得了推测用例状态的机会。
相关模式：命令Command 外观Facade 层Layer（POSA模式）纯虚构。
</p>

<p>
控制器要把任务委派出去。如果控制器处理了太多的事件和任务，要么拆分成多个控制器，要么做成只分配任务的控制器。
</p>

<p>
高内聚（High Cohesion）
怎样是对象保持有内聚、可理解和可管理，同时具有支持低耦合的附加作用？
方案：职责分配应当保持高内聚。
</p>

<p>
内聚是软件元素操作在功能上的相关程度。
</p>

<p>
GRASP是通用职责分配软件模式（General Responsibility Assignment Software Patterns）。GRASP的9个模式为：
创建者Creator 控制器Controller 纯虚构Pure Fabrication 信息专家Information Expert 高内聚High Cohesion 间接性 Indirection 低耦合 Low Coupling 多态性Polymorphism 防止变异 Protected Variations
</p>

<p>
命令-查询分离原则（Command-Query Separation Principle）执行动作（修改对象状态）和查询数据（幂等）的操作要分离。否则会违反最小意外原则（Least Surprise）。
</p>

<p>
可见性（visibility）是一个对象引用其他对象的能力。可见性可以分为4个层面：
</p>

<p>
属性可见性：B是A的属性。
参数可见性：B是A中方法的参数。
局部可见性：B是A中方法的局部对象。
全局可见性：B是某种全局对象。
</p>

<p>
多态Polymorphism
如何处理基于类型的选择？如何创建可插拔的软件构建？
方案：使用多态。不要测试对象类型，不要用逻辑条件执行基于类型的不同选择。
优点：易于增加新变化所需的扩展。不需要影响客户端就能引入新实现。
涉及的模式：适配器adapter、命令command、组合composite、代理proxy、状态state、策略strategy。
</p>

<p>
纯虚构Pure fabrication
为了分配职责而定义的没有概念类对应的软件类。
优点：高内聚、低耦合
涉及模式：适配器Adapter、命令Command、策略Strategy。
</p>

<p>
间接性indirection
为了避免两个对象之间的直接耦合。
将职责分配给中介对象。
相关模式：适配器adapter、桥bridge、外观facade、观察者observer、中介mediator。
</p>


<p>
活动图用户可视化业务流程。
</p>

<p>
将领域模型划分为包结构时，将满足下列条件的元素放到一起：
</p>
<ul class="org-ul">
<li>在同一个主题领域，概念或目标密切相关的元素。</li>
<li>在同一个类层次结构中的关系。</li>
<li>参与同一个用例的元素。</li>
<li>有很强的关联性的元素。</li>
</ul>

<p>
软件系统中有两种地方需要特别关注：变化点（variation point）是现有系统或需求中的变化之处，如必须支持多个税金计算器接口。进化点（evolution point）是现有需求中不存在的，但可能在将来发生的变化点。
</p>

<p>
架构分析是指在功能性需求的语境中识别和解决非功能性需求。
</p>

<p>
缺陷Fault：异常行为的起因。
错误Error：缺陷在运行系统中的表现。
故障Failure：由错误引起的服务拒绝。
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2019-10-29 周二 01:33</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-09-23 周一 18:45 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org060ed65">温故而知新</a></li>
<li><a href="#orgc54821c">编译和链接</a></li>
<li><a href="#org813695e">目标文件里有什么</a></li>
<li><a href="#orgbf3b806">静态链接</a></li>
<li><a href="#org41bd012">Windows PE/COFF</a></li>
<li><a href="#org343a2ca">可执行文件的装载与进程</a></li>
<li><a href="#org50cca51">动态链接</a></li>
<li><a href="#org121e4ef">Linux共享库的组织</a></li>
<li><a href="#orga928f66">Windows下的动态链接</a></li>
<li><a href="#org76c238a">内存</a></li>
<li><a href="#org49408cf">运行库</a></li>
<li><a href="#orga9bfd6f">系统调用与API</a></li>
<li><a href="#org22ebe63">运行库实现</a></li>
</ul>
</div>
</div>
<div id="outline-container-org060ed65" class="outline-2">
<h2 id="org060ed65">温故而知新</h2>
<div class="outline-text-2" id="text-org060ed65">
<p>
Linux采用0x80中断作为系统调用接口。
</p>

<p>
目前x86架构上的Windows和Linux多采用4KB作为内存页大小，这个值是在系统启动时决定的。通常提到“页”这个术语时，要根据上下文区分虚拟页（virtual page，VP）、物理页（physical page，PP）和磁盘页（disk page，DP）。VP可能被映射为PP或DP。如果进程需要使用某个VP，而这个VP被保存为DP，系统会发生页错误（page fault），将这个VP从磁盘中读取出来，映射到一个PP给进程使用。在执行虚拟地址转换时，CPU使用一个叫做MMU（Memory Management Unit）的组件进行页映射，将VP映射为PP。
</p>


<p>
一个标准的线程由线程编号、程序指针（PC）、寄存器集合和堆栈组成。采用多线程的好处在于
</p>
<ul class="org-ul">
<li>某个操作可能陷入长时间等待。多线程程序可以有效利用等待时间。</li>
<li>某些操作需要一定时间，多线程程序可以避免程序无法响应用户操作或程序与用户的交互中断。</li>
<li>支持逻辑上要求并发的操作，如bittorrent。</li>
<li>利用多CPU的计算能力。</li>
<li>相比多进程系统，多线程数据共享更高效，不会跨越地址空间。</li>
</ul>

<p>
线程的私有存储：
</p>
<ul class="org-ul">
<li>栈（函数参数和局部变量）。</li>
<li>线程本地存储，TLS。</li>
<li>寄存器。</li>
</ul>
<p>
线程共享的存储：
</p>
<ul class="org-ul">
<li>全局变量。</li>
<li>堆数据。</li>
<li>函数的静态变量。</li>
<li>程序代码。</li>
<li>打开的文件。</li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">fork</td>
<td class="org-left">复制当前进程</td>
</tr>

<tr>
<td class="org-left">exec</td>
<td class="org-left">使用新的可执行映像覆盖当前映像</td>
</tr>

<tr>
<td class="org-left">clone</td>
<td class="org-left">创建子进程并从指定位置开始执行</td>
</tr>
</tbody>
</table>


<p>
由于线程调度和异步信号处理，以及函数自身的递归调用，可以出现一个函数在执行到一半时，在另外的线程，或本线程上再次调用这个函数。如果在这种情况下，函数可以正常工作，不会产生副作用，这样的函数叫做可重入（reentrant）的。在编写可重入函数时必须保证：
</p>
<ul class="org-ul">
<li>不使用局部变量、静态变量或全局非const变量。</li>
<li>不返回局部变量、静态变量或全局非const变量。</li>
<li>只依赖于调用方传入的参数。</li>
<li>不依赖任何单个资源的锁。</li>
<li>不调用不可重入函数。</li>
</ul>

<p>
可重入函数可以在多线程环境下放心使用。
</p>

<p>
volatile可以避免编译器将变量缓存在寄存器，而不写回内存。也可以阻止编译器调整操作volatile变量的指令的顺序。
</p>
</div>
</div>


<div id="outline-container-orgc54821c" class="outline-2">
<h2 id="orgc54821c">编译和链接</h2>
<div class="outline-text-2" id="text-orgc54821c">
<p>
C程序代码经过预编译、编译、汇编和链接，生成可执行文件。预编译过程执行宏替换和预编译指令。编译过程将程序代码翻译成汇编代码，这个过程是通过cc1程序（C++是cc1plus，Java是jc1,）完成的。汇编器（as）将汇编代码翻译成机器指令，叫做目标文件。链接器（ld）将目标文件和库结合起来，生成最终的可执行文件。程序中使用的，其他模块中定义的全局变量和函数，在链接阶段确定绝对位置。链接的过程主要包括：地址和空间分配（address and storage alloction）、符号决议（symbol resolution）和重定位（relocation）。
</p>
</div>
</div>


<div id="outline-container-org813695e" class="outline-2">
<h2 id="org813695e">目标文件里有什么</h2>
<div class="outline-text-2" id="text-org813695e">
<p>
Windows下的可执行文件格式PE（Portable Executable）和Linux下的ELF（Executable Linkable Format）都是COFF（COmmon File Format）的变种。
</p>


<p>
程序代码编译后保存在代码段（code section）中，代码段常以.code或.text命名。全局变量和局部静态变量保存在数据段（data section，以.data命名）中。对于未初始化的全局变量和局部静态变量，会分配一个.bss（Block Started By Symbol）段，为其预留位置。
</p>


<p>
代码和数据分离的好处有：
</p>
<ul class="org-ul">
<li>数据和指令在内存中的位置不同，映射到不同的区域。</li>
<li>分离可以让指令和数据都具有更好的局部性，便于CPU缓存（现代CPU一般将数据缓存和指令缓存分离）。</li>
<li>支持一个程序运行多副本，减少内存占用。</li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b22222;">// </span><span style="color: #b22222;">linux:</span>
<span style="color: #b22222;">//   </span><span style="color: #b22222;">gcc -c simple_seciton.c</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">windows:</span>
<span style="color: #b22222;">//   </span><span style="color: #b22222;">cl simple_seciton.c /c /Za</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">printf</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">format</span>, ...);
<span style="color: #228b22;">int</span> <span style="color: #a0522d;">global_init_var</span> = 84;
<span style="color: #228b22;">int</span> <span style="color: #a0522d;">global_uninit_var</span>;

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">func1</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>) {
  printf(<span style="color: #8b2252;">"%d\n"</span>, i);
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>(<span style="color: #228b22;">void</span>) {
  <span style="color: #a020f0;">static</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">static_var</span> = 85;
  <span style="color: #a020f0;">static</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">static_var2</span>;
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">a</span> = 1;
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">b</span>;
  func1(static_var + static_var2 + a + b);
  <span style="color: #a020f0;">return</span> a;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell">objdump -h simple_section.o
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">段</td>
<td class="org-left">说明</td>
</tr>

<tr>
<td class="org-left">.text</td>
<td class="org-left">代码</td>
</tr>

<tr>
<td class="org-left">.data</td>
<td class="org-left">数据</td>
</tr>

<tr>
<td class="org-left">.bss</td>
<td class="org-left">未初始化全局变量和静态变量</td>
</tr>

<tr>
<td class="org-left">.rodata</td>
<td class="org-left">只读数据</td>
</tr>

<tr>
<td class="org-left">.comment</td>
<td class="org-left">注释</td>
</tr>

<tr>
<td class="org-left">.note.GNU-stack</td>
<td class="org-left">栈</td>
</tr>

<tr>
<td class="org-left">.rodata1</td>
<td class="org-left">只读数据</td>
</tr>

<tr>
<td class="org-left">.debug</td>
<td class="org-left">调试信息</td>
</tr>

<tr>
<td class="org-left">.dynamic</td>
<td class="org-left">动态信息</td>
</tr>

<tr>
<td class="org-left">.hash</td>
<td class="org-left">符号散列表</td>
</tr>

<tr>
<td class="org-left">.strtab</td>
<td class="org-left">字符串表</td>
</tr>

<tr>
<td class="org-left">.symtab</td>
<td class="org-left">符号表</td>
</tr>

<tr>
<td class="org-left">.note</td>
<td class="org-left">编译器信息</td>
</tr>

<tr>
<td class="org-left">.line</td>
<td class="org-left">行号</td>
</tr>

<tr>
<td class="org-left">.shstrtab</td>
<td class="org-left">段名表</td>
</tr>

<tr>
<td class="org-left">.plt .got</td>
<td class="org-left">动态链接跳转表和全局入口表</td>
</tr>

<tr>
<td class="org-left">.init .fini</td>
<td class="org-left">程序初始化和终结代码段</td>
</tr>
</tbody>
</table>


<div class="org-src-container">
<pre class="src src-shell">size simple_section.o
</pre>
</div>


<div class="org-src-container">
<pre class="src src-shell">objcopy -I binary -O elf32-i386 -B i386 image.jpg image.o
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell">objcopy -s -d simple_section.o
</pre>
</div>

<p>
如果全局变量或静态变量的初始值是0（或零值），编译器会将这个变量保存到.bss段作为优化。
</p>

<p>
GCC允许将对象放到指定的自定义段中：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #a020f0;">__attribute__</span>((section(<span style="color: #8b2252;">"FOO"</span>))) <span style="color: #228b22;">int</span> <span style="color: #a0522d;">global</span> = 42;
<span style="color: #a020f0;">__attribute__</span>(section(<span style="color: #8b2252;">"BAR"</span>))) <span style="color: #228b22;">void</span> <span style="color: #0000ff;">foo</span>();
</pre>
</div>

<p>
ELF文件的基本结构如下：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">ELF头</td>
</tr>

<tr>
<td class="org-left">.text</td>
</tr>

<tr>
<td class="org-left">.data</td>
</tr>

<tr>
<td class="org-left">.bss</td>
</tr>

<tr>
<td class="org-left">&#x2026;</td>
</tr>

<tr>
<td class="org-left">section header table</td>
</tr>

<tr>
<td class="org-left">string tables &amp; symbol tables</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-shell">readelf -h simple_section.o
</pre>
</div>

<p>
ELF头定义在/usr/include/elf.h中，有32位和64位两个版本（Elf32<sub>Ehdr和Elf64</sub><sub>Ehdr</sub>）。二者的成员相同，区别在于部分成员的长度不同。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> {
  <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">e_ident</span>[16];   <span style="color: #b22222;">// </span><span style="color: #b22222;">&#39764;&#25968;&#65292;&#29256;&#26412;&#65292;ABI&#31561;&#12290;</span>
  <span style="color: #228b22;">Elf32_Half</span> <span style="color: #a0522d;">e_type</span>;           <span style="color: #b22222;">// </span><span style="color: #b22222;">ELF&#31867;&#22411;&#12290;ET_REL &#21487;&#37325;&#23450;&#20301;&#25991;&#20214; ET_EXEC &#21487;&#25191;&#34892;&#25991;&#20214; ET_DYN &#20849;&#20139;&#30446;&#26631;&#25991;&#20214;</span>
  <span style="color: #228b22;">Elf32_Half</span> <span style="color: #a0522d;">e_machine</span>;        <span style="color: #b22222;">// </span><span style="color: #b22222;">ABI&#12290;EM_386 x86</span>
  <span style="color: #228b22;">Elf32_Word</span> <span style="color: #a0522d;">e_version</span>;        <span style="color: #b22222;">// </span><span style="color: #b22222;">ELF&#29256;&#26412;</span>
  <span style="color: #228b22;">Elf32_Addr</span> <span style="color: #a0522d;">e_entry</span>;          <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20837;&#21475;&#34394;&#22320;&#22336;</span>
  <span style="color: #228b22;">Elf32_Off</span> <span style="color: #a0522d;">e_phoff</span>;           <span style="color: #b22222;">// </span><span style="color: #b22222;">program header&#20559;&#31227;&#37327;</span>
  <span style="color: #228b22;">Elf32_Off</span> <span style="color: #a0522d;">e_shoff</span>;           <span style="color: #b22222;">// </span><span style="color: #b22222;">section header&#20559;&#31227;&#37327;</span>
  <span style="color: #228b22;">Elf32_Word</span> <span style="color: #a0522d;">e_flags</span>;          <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26631;&#24535;&#20301;</span>
  <span style="color: #228b22;">Elf32_Half</span> <span style="color: #a0522d;">e_ehsize</span>;         <span style="color: #b22222;">// </span><span style="color: #b22222;">ELF&#22836;&#22823;&#23567;</span>
  <span style="color: #228b22;">Elf32_Half</span> <span style="color: #a0522d;">e_phentsize</span>;      <span style="color: #b22222;">// </span><span style="color: #b22222;">program header&#22823;&#23567;</span>
  <span style="color: #228b22;">Elf32_Half</span> <span style="color: #a0522d;">e_phnum</span>;          <span style="color: #b22222;">// </span><span style="color: #b22222;">program header&#25968;&#37327;</span>
  <span style="color: #228b22;">Elf32_Half</span> <span style="color: #a0522d;">e_shentsize</span>;      <span style="color: #b22222;">// </span><span style="color: #b22222;">section header&#22823;&#23567;</span>
  <span style="color: #228b22;">Elf32_Half</span> <span style="color: #a0522d;">e_shnum</span>;          <span style="color: #b22222;">// </span><span style="color: #b22222;">section header&#25968;&#37327;</span>
  <span style="color: #228b22;">Elf32_Half</span> <span style="color: #a0522d;">e_shstrndx</span>;       <span style="color: #b22222;">// </span><span style="color: #b22222;">section header string table index</span>
} <span style="color: #228b22;">Elf32_Ehdr</span>;
</pre>
</div>

<p>
段表的元素是Elf32<sub>Shdr</sub>：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> {
  <span style="color: #228b22;">Elf32_Word</span> <span style="color: #a0522d;">sh_name</span>;          <span style="color: #b22222;">// </span><span style="color: #b22222;">&#27573;&#21517;&#22312;.shstrtab&#20013;&#30340;&#20559;&#31227;</span>
  <span style="color: #228b22;">Elf32_Word</span> <span style="color: #a0522d;">sh_type</span>;          <span style="color: #b22222;">// </span><span style="color: #b22222;">&#27573;&#31867;&#22411;&#12290;</span>
  <span style="color: #228b22;">Elf32_Word</span> <span style="color: #a0522d;">sh_flags</span>;         <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26631;&#24535;&#20301;</span>
  <span style="color: #228b22;">Elf32_Addr</span> <span style="color: #a0522d;">sh_addr</span>;          <span style="color: #b22222;">// </span><span style="color: #b22222;">&#27573;&#30340;&#34394;&#25311;&#22320;&#22336;</span>
  <span style="color: #228b22;">Elf32_Off</span> <span style="color: #a0522d;">sh_offset</span>;         <span style="color: #b22222;">// </span><span style="color: #b22222;">&#27573;&#20559;&#31227;</span>
  <span style="color: #228b22;">Elf32_Word</span> <span style="color: #a0522d;">sh_size</span>;          <span style="color: #b22222;">// </span><span style="color: #b22222;">&#27573;&#38271;&#24230;</span>
  <span style="color: #228b22;">Elf32_Word</span> <span style="color: #a0522d;">sh_link</span>;          <span style="color: #b22222;">// </span><span style="color: #b22222;">&#38142;&#25509;&#20449;&#24687;</span>
  <span style="color: #228b22;">Elf32_Word</span> <span style="color: #a0522d;">sh_info</span>;          <span style="color: #b22222;">// </span><span style="color: #b22222;">&#38142;&#25509;&#20449;&#24687;</span>
  <span style="color: #228b22;">Elf32_Word</span> <span style="color: #a0522d;">sh_addralign</span>;     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#22320;&#22336;&#23545;&#40784;</span>
  <span style="color: #228b22;">Elf32_Word</span> <span style="color: #a0522d;">sh_entsize</span>;       <span style="color: #b22222;">// </span><span style="color: #b22222;">section entry size&#38271;&#24230;</span>
} <span style="color: #228b22;">Elf32_Shdr</span>;
</pre>
</div>

<p>
.rel.text是对.text段的重定位表。
</p>

<p>
符号段.symtab是一个数值，其元素是
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> {
  <span style="color: #228b22;">Elf32_Word</span> <span style="color: #a0522d;">st_name</span>;         <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31526;&#21495;&#21517;&#32034;&#24341;&#12290;</span>
  <span style="color: #228b22;">Elf32_Addr</span> <span style="color: #a0522d;">st_value</span>;        <span style="color: #b22222;">// </span>
  <span style="color: #228b22;">Elf32_Word</span> <span style="color: #a0522d;">st_size</span>;         <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31526;&#21495;&#22823;&#23567;&#12290;</span>
  <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">st_info</span>;      <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31526;&#21495;&#31867;&#22411;&#21644;&#31526;&#21495;&#32465;&#23450;&#20449;&#24687;&#12290;</span>
  <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">st_other</span>;     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20445;&#30041;&#20351;&#29992;&#12290;</span>
  <span style="color: #228b22;">Elf32_Half</span> <span style="color: #a0522d;">st_shndx</span>;        <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31526;&#21495;&#25152;&#22312;&#30340;&#27573;&#12290;</span>
} <span style="color: #228b22;">Elf32_Sym</span>;
</pre>
</div>

<p>
ld在链接时会引入一些特殊符号，如
</p>
<ul class="org-ul">
<li>_<sub>executable</sub><sub>start</sub> 程序起始地址，非入口地址。</li>
<li>_<sub>etext</sub>，<sub>etext</sub>，etext 代码段结束地址。</li>
<li>_edata，edata 数据段结束地址。</li>
<li>_end，end 程序结束地址。</li>
</ul>

<p>
GCC编译器生成的名字
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">int func(int)</td>
<td class="org-left">_Z4funci</td>
</tr>

<tr>
<td class="org-left">float func(float)</td>
<td class="org-left">_Z4funcf</td>
</tr>

<tr>
<td class="org-left">int C::func(int)</td>
<td class="org-left">_ZN1C4funcEi</td>
</tr>

<tr>
<td class="org-left">int C::C2::func(int)</td>
<td class="org-left">_ZN1C2C24funcEi</td>
</tr>

<tr>
<td class="org-left">int N::func(int)</td>
<td class="org-left">_ZN1N4funcEi</td>
</tr>

<tr>
<td class="org-left">int N::C::func(int)</td>
<td class="org-left">_ZN1N1C4funcEi</td>
</tr>
</tbody>
</table>

<p>
命令c++filt可以解释修饰过的名字：
</p>
<div class="org-src-container">
<pre class="src src-shell">c++filt _ZN1N1C4funcEi
</pre>
</div>

<p>
在Windows下有一个函数UnDecorateSymbolName可以解析C++的名字。
</p>


<div class="org-src-container">
<pre class="src src-c++"><span style="color: #483d8b;">#ifdef</span> __cplusplus
<span style="color: #a020f0;">extern</span> <span style="color: #8b2252;">"C"</span> {
<span style="color: #483d8b;">#endif</span>

<span style="color: #483d8b;">#ifdef</span> __cplusplus
}
<span style="color: #483d8b;">#endif</span>
</pre>
</div>

<p>
符号分为强符号（string symbol）和弱符号（weak symbol）和其他。默认情况下，以初始化全局变量和函数是强符号，未初始化全局变量是弱符号。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #a020f0;">__attribute__</span>((weak)) <span style="color: #228b22;">int</span> <span style="color: #a0522d;">a</span> = 2;
</pre>
</div>

<p>
强符号只能定义一次。如果一个符号在某个目标文件中是强符号，在其他目标文件是弱符号，选择强符号。如果在所有目标文件中都是弱符号，选择size最大的那个。
</p>

<p>
引用也分为强引用（strong reference）和弱引用（weak reference）。强引用没有找到符号时会报错，弱引用不会。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #a020f0;">__attribute__</span>((weakref)) <span style="color: #228b22;">void</span> <span style="color: #0000ff;">foo</span>();
</pre>
</div>

<p>
弱符号和弱引用允许程序根据链接情况决定行为。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;pthread.h&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">pthread_create</span>(<span style="color: #228b22;">pthread_t</span>*, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">pthread_attr_t</span>*, <span style="color: #228b22;">void</span> *(*)(<span style="color: #228b22;">void</span>*), <span style="color: #228b22;">void</span>*) <span style="color: #a020f0;">__attribute__</span>((weak));

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
  <span style="color: #a020f0;">if</span> (pthread_create) {
    printf(<span style="color: #8b2252;">"multi-thread version\n"</span>);
  } <span style="color: #a020f0;">else</span> {
    printf(<span style="color: #8b2252;">"single-thread versino\n"</span>);
  }
}

<span style="color: #b22222;">// </span><span style="color: #b22222;">gcc main.c -o pt</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">gcc main.c -lpthread -o pt2</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-orgbf3b806" class="outline-2">
<h2 id="orgbf3b806">静态链接</h2>
<div class="outline-text-2" id="text-orgbf3b806">
<p>
现代链接器都采用两步链接（two-pass linking），第一步是空间和地址分配，第二部是符号解析和重定位。经过这两步，各目标文件的相似段合并到一起。
</p>

<p>
objdump输出的VMA和LMA分别是Virtual Memory Address和Load Memory Address的缩写。大部分时候，这两个值是相等的（部分嵌入式系统除外）。在链接之前，VMA都是0。链接时，ld为各段和符号分配VMA。在Linux下，ELF可执行文件默认从0x08048000开始分配。x86的段内近跳转的操作数是函数的地址偏移。在链接时，地址偏移发生变化，因此需要进行重定位。ELF通过重定位表（relocation table）提供支持。重定位表是一个数组
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">Elf32_Addr</span> <span style="color: #a0522d;">r_offset</span>;
    <span style="color: #228b22;">Elf32_Word</span> <span style="color: #a0522d;">r_info</span>;
} <span style="color: #228b22;">Elf32_Rel</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell">readelf -s a.o
</pre>
</div>
<p>
输出的Ndx是符号的定位。如果是UND，说明函数未定义。
</p>

<p>
msvc提供了函数级别链接（functional-level linking /Gy），将每个使用到的库函数放到独立的段中，其余的库函数丢弃。这个选项可以减少可执行文件长度，代价是编译和链接时间增加。GCC中类似的选项是-ffuntion-sections（每个函数一个段）和-fdata-sections（每个变量一个段）。
</p>

<p>
linux下程序的入口是<sub>start</sub>，这时Glibc的一部分。ELF定义了两个特殊的段，用于环境（如C++全局对象）的初始化和销毁。这两个段是.init和.fini。
</p>

<p>
如果想让两个编译器生成的目标文件可以正常链接，必须满足：
</p>
<ul class="org-ul">
<li>相同的目标文件格式。</li>
<li>相同的符号修饰标准。</li>
<li>相同的变量内存分布方式。</li>
<li>相同的函数调用方式。</li>
</ul>
<p>
这些和二进制兼容相关的内容叫做ABI（Application Binary Interface）。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">C运行库</td>
<td class="org-left">dll</td>
<td class="org-left">描述</td>
</tr>

<tr>
<td class="org-left">libcmt.lib</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">多线程静态库</td>
</tr>

<tr>
<td class="org-left">msvcrt.lib</td>
<td class="org-left">msvcr90.dll</td>
<td class="org-left">多线程动态库</td>
</tr>

<tr>
<td class="org-left">libcmtd.lib</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">多线程静态调试库</td>
</tr>

<tr>
<td class="org-left">msvcrtd.lib</td>
<td class="org-left">msvcr90d.dll</td>
<td class="org-left">多线程动态调试库</td>
</tr>
</tbody>
</table>

<p>
ar -t可以查看.a中包含的文件：
</p>
<div class="org-src-container">
<pre class="src src-shell">ar -t libc.a
</pre>
</div>
<p>
msvc提供的类似工具是lib.exe
</p>
<div class="org-src-container">
<pre class="src src-shell">lib /LIST libcmt.lib
</pre>
</div>

<p>
ar -x lib.a 解压
gcc -c hello.c -verbose 显示编译中间步骤
</p>

<p>
collect2是lib的一个包装。
</p>

<p>
Windows内核时ntoskrnl.exe。
</p>

<p>
ld -verbose可以查看默认的链接脚本。这些脚本通常在/usr/lib/ldscripts下，如elf<sub>i386.x</sub>（可执行文件），elf<sub>i386.xs</sub>（共享库）等。
ld -T myldscript.lds
链接脚本示例
</p>
<div class="org-src-container">
<pre class="src src-text">ENTYR(nomain)  /* &#20837;&#21475;&#20989;&#25968; */

SECTIONS
{
  . = 0x080480000 + SIZEOF_HEADERS;  /* &#36215;&#22987;&#34394;&#25311;&#20301;&#32622; */
  tinytext: { *(.text) *(.data) *(.rodata) }  /* &#23558;.text&#12289;.data&#12289;.rodata&#20381;&#27425;&#21512;&#24182;&#20026;.tinytext&#27573;&#12290; */
  /DISCARD/: { *(.comment) } /* &#20002;&#24323;.comment&#27573; */
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org41bd012" class="outline-2">
<h2 id="org41bd012">Windows PE/COFF</h2>
<div class="outline-text-2" id="text-org41bd012">
<p>
64位的PE格式叫做PE32+，和PE的区别在于将里面的32位数据替换为64位。PE/COFF也是分段的，msvc生成的段名通常是.code、.data等。
</p>

<p>
#pragma data<sub>seg</sub>("FOO")
int global = 1;
#pragma data<sub>seg</sub>(".data")
</p>

<p>
dumpbin.exe /all simple<sub>section.obj</sub>
</p>

<p>
PE文件的结构为
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">IMAGE<sub>FILE</sub><sub>HEADER</sub></td>
</tr>

<tr>
<td class="org-left">IMAGE<sub>SECTION</sub><sub>HEADER</sub>[]</td>
</tr>

<tr>
<td class="org-left">.text</td>
</tr>

<tr>
<td class="org-left">.data</td>
</tr>

<tr>
<td class="org-left">.drectve</td>
</tr>

<tr>
<td class="org-left">.debug$S</td>
</tr>

<tr>
<td class="org-left">&#x2026;</td>
</tr>

<tr>
<td class="org-left">symbol table</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b22222;">// </span><span style="color: #b22222;">WinNT.h</span>
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">_IMAGE_FILE_HEADER</span> {
    <span style="color: #228b22;">WORD</span> <span style="color: #a0522d;">Machine</span>;
    <span style="color: #228b22;">WORD</span> <span style="color: #a0522d;">NumberOfSections</span>;
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">TimeDateStamp</span>;
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">PointerToSymbolTable</span>;
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">NumberOfSymbols</span>;
    <span style="color: #228b22;">WORD</span> <span style="color: #a0522d;">SizeOfOptionalHeader</span>;
    <span style="color: #228b22;">WORD</span> <span style="color: #a0522d;">Characteristics</span>;
} <span style="color: #228b22;">IMAGE_FILE_HEADER</span>, *<span style="color: #228b22;">PIMAGE_FILE_HEADER</span>;

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">_IMAGE_SECTION_HEADER</span> {
  <span style="color: #228b22;">BYTE</span> <span style="color: #a0522d;">Name</span>[8];
  <span style="color: #a020f0;">union</span> {
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">PhysicalAddress</span>;
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">VirtualSize</span>;
  } <span style="color: #a0522d;">Misc</span>;
  <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">VirtualAddress</span>;
  <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">SizeOfRawData</span>;
  <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">PointerToRawData</span>;
  <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">PointerToRelocations</span>;
  <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">PointerToLinenumbers</span>;
  <span style="color: #228b22;">WORD</span> <span style="color: #a0522d;">NumberOfRelocations</span>;
  <span style="color: #228b22;">WORD</span> <span style="color: #a0522d;">NumberOfLinenumbers</span>;
  <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">Characteristics</span>;
} <span style="color: #228b22;">IMAGE_SECTION_HEADER</span>, *<span style="color: #228b22;">PIMAGE_SECTION_HEADER</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org343a2ca" class="outline-2">
<h2 id="org343a2ca">可执行文件的装载与进程</h2>
<div class="outline-text-2" id="text-org343a2ca">
<p>
32位Linux将内存分为两部分，0x00000000-0xc0000000的3GB给用户使用，0xc0000000的1GB给内核使用。Windows默认给用户进程的空间是2GB。在根目录下的boot.ini中加入/3G参数，可以把预留给用户进程的内存提升到3GB。
</p>

<p>
进程启动过程
</p>
<ul class="org-ul">
<li>建立独立的虚拟地址空间</li>
<li>读取可执行文件头，建立虚拟空间和可执行文件的映射关系</li>
<li>设置程序计数器，启动运行。</li>
</ul>


<p>
Linux加载ELF的过程。
</p>
<ul class="org-ul">
<li>执行execve()</li>
<li>调用sys<sub>execve</sub>()，在Process.c中。</li>
<li>do<sub>execve</sub>()</li>
<li>search<sub>binary</sub><sub>handle</sub>()</li>
<li>load<sub>aout</sub><sub>binary</sub>/load<sub>elf</sub><sub>binary</sub>/load<sub>script</sub></li>
<li>load<sub>elf</sub><sub>binary在fs</sub>/binfmt<sub>elf.c中</sub>。
<ul class="org-ul">
<li>校验ELF</li>
<li>寻找.interp段，设置动态链接器</li>
<li>映射ELF段</li>
<li>将系统调用返回地址改为ELF入口</li>
<li>从sys<sub>execve</sub>()返回时，EIP已经是ELF入口，执行用户程序。</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org50cca51" class="outline-2">
<h2 id="org50cca51">动态链接</h2>
<div class="outline-text-2" id="text-org50cca51">
<p>
动态链接优点：
</p>
<ul class="org-ul">
<li>节省磁盘空间</li>
<li>节省内存空间</li>
<li>将逻辑和基础分离，便于发布</li>
<li>插件化</li>
</ul>

<p>
ld-2.6.so是Linux下的动态连接器。
</p>

<p>
在动态加载时的重定位叫做装载时重定位（load time relocation）或基址重置（rebasing）。在重定位时，需要修改部分指令（如跳转），因此不能直接在多个进程之间共享。
对于装载时重定位不会改动的部分，是可以在进程间共享的，这需要使用一项技术，叫做地址无关代码（PIC，Position-Independent Code, -fPIC）。
</p>

<p>
和-fPIC类型的选项是-fPIE：地址无关可执行文件。
</p>

<p>
readelf -d foo.so | grep TEXTREL 可以观察一个so是否是PIC。
</p>

<p>
跨模块的引用可以分为4类：
</p>
<ul class="org-ul">
<li>模块内函数调用或跳转</li>
<li>模块内数据（全局变量、静态变量）访问</li>
<li>模块外函数调用或跳转</li>
<li>模块外数据（全局变量、静态变量）访问</li>
</ul>

<p>
对于模块内部调用，相对位置是固定的。
对于模块内部数据访问，相对位置也是固定的。但是指令不能使用相对位置访问数据，因此需要一个技巧：
</p>

<p>
在模块间调用时，ELF建立一个全局偏移表（Global Offset Table, GOT）。
</p>

<p>
Glibc中查找对象的函数叫做<sub>dl</sub><sub>runtime</sub><sub>resolve</sub>()。
</p>

<p>
linux-gate.so.1是内核虚拟共享文件（kernel virtual DSO）。
</p>

<p>
Linux加载符号时，如果同名符号已经存在，后面的符号被忽略。这个现象叫做全局符号介入（Global Symbol Interpose）。
</p>

<p>
Linux加载so和可执行文件时，解析ELF文件。如果有.interp段，跳转到.interp指向的动态链接器。否则跳转到e<sub>entry</sub>。
</p>


<p>
&lt;dlfcn.h&gt;
void* dlopen(const char *filename, int flag);
查找顺序：LD<sub>LIBRARY</sub><sub>PATH</sub> /etc/ld.so.cache /lib /usr/lib
RTLD<sub>LAZY</sub> NOW GLOBAL
不会自动加载依赖项。
</p>

<p>
void* dlsym(void *handle, char *symbol);
dlerror();
dlclose() 将计数器减一。当计数为0时，卸载模块。执行.fini段，从符号表移除符号，取消进程空间和模块的映射关系，关闭模块文件。
</p>
</div>
</div>


<div id="outline-container-org121e4ef" class="outline-2">
<h2 id="org121e4ef">Linux共享库的组织</h2>
<div class="outline-text-2" id="text-org121e4ef">
<p>
ldconfig可以更新/lib、/usr/lib下的软连接。
</p>

<p>
ld使用-static时，-lc会查找libc.a，如果使用-Bdynamic（默认）会查找libc.so.x.y.z。
</p>

<p>
大部分Linux系统遵循FHS（File Hierarchy Standard）标准，根据FHS：
</p>
<ul class="org-ul">
<li>/lib 系统运行时的关键共享库</li>
<li>/usr/lib 非系统运行时的关键共享库</li>
<li>/usr/local/lib 第三方共享库</li>
</ul>

<p>
动态链接器会首先加载LD<sub>PRELOAD指向的共享库</sub>。/etc/ld.so.preload
</p>

<p>
LD<sub>DEBUG</sub>=files ./a.out 打印链接器执行信息。还可以是bindings显示绑定过程。 libs 显示库查找过程。versions显示版本依赖关系。reloc显示重定位过程。
symbols显示符号表查找过程。statistics显示统计信息。all显示全部。help帮助。
</p>


<p>
strip a.so 消除符号
ld -s 消除所有符号 -S 消除调试符号
Gcc -Wl,-s 或 -Wl,-S
</p>



<p>
void _<sub>attribute</sub>_<sub>((constructor))</sub> init();
void _<sub>attribute</sub>_<sub>((destructor))</sub> fini();
</p>

<p>
void _<sub>attribute</sub>_<sub>((constructor(1)))</sub> init(); 设定优先级。最小越高。
</p>
</div>
</div>


<div id="outline-container-orga928f66" class="outline-2">
<h2 id="orga928f66">Windows下的动态链接</h2>
<div class="outline-text-2" id="text-orga928f66">
<p>
DLL是Dynamic-Link Library的缩写。DLL的代码不是地址无关的，因此只能在某些情况下可以被多个进程共享。PE文件中有基地址（Base Address）和相对地址（Relative Virtual Address, RVA）两个概念。基地址就是PE头中的Image Base。对于exe文件，Image Base通常是0x004000000，对dll是0x10000000。加载PE时，Windows尝试将其载入Image Base指定的虚地址。如果地址被占用，Windows选择一个空闲的地址加载。RVA就是实际加载地址相对基地址的偏移。
</p>


<p>
Windows允许将DLL的数据段设置为进程间可共享的。一个DLL中通常有2个数据段，一个在进程间共享，一个是私有的。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">__declspec</span>(dllexport) <span style="color: #228b22;">void</span> <span style="color: #0000ff;">foo</span>();
<span style="color: #a020f0;">__declspec</span>(dllimport) <span style="color: #228b22;">void</span> <span style="color: #0000ff;">foo</span>();
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell">cl /LDd a.c &#29983;&#25104;&#35843;&#35797;&#29256;&#26412;dll
cl /LD a.c &#29983;&#25104;&#21457;&#24067;&#29256;&#26412;dll
</pre>
</div>

<p>
使用dumpbin可以查看dll的导出符号
</p>
<div class="org-src-container">
<pre class="src src-shell">dumpbin /EXPORTS a.dll
</pre>
</div>

<p>
以动态链接的方法使用dll时，需要链接相应的lib文件。这个lib和作为静态库的lib不同，这个lib只有dll导出符号的信息，不包含实际的代码。这种lib叫做导入库（import library）。
</p>

<p>
为了更好的控制链接，可以将_<sub>declspec的内容保存成def文件</sub>
</p>
<div class="org-src-container">
<pre class="src src-text">LIBRARY Math
EXPORTS
Add=_Add@16
Sub
Mul
Div
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell">cl Math.c /LD /DEF Math.def
</pre>
</div>

<p>
使用def文件的好处之一就是可以设置别名。如果要手动加载dll，可以使用Windows提供的API：
</p>
<div class="org-src-container">
<pre class="src src-c">LoadLibrary
LoadLibraryEx
<span style="color: #228b22;">GetProcAddress</span>
<span style="color: #a0522d;">FreeLibrary</span>
</pre>
</div>

<p>
PE也有和符号表类似的概念，叫做导出表（export table）。导出表是一个IMAGE<sub>EXPROT</sub><sub>DIRECTORY结构体</sub>。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">_IMAGE_EXPORT_DIRECTORY</span> {
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">Characteristics</span>;
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">TimeDateStamp</span>;
    <span style="color: #228b22;">WORD</span> <span style="color: #a0522d;">MajorVersion</span>;
    <span style="color: #228b22;">WORD</span> <span style="color: #a0522d;">MinorVersion</span>;
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">Name</span>;
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">Base</span>;
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">NumberOfFunctions</span>;
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">NumberOfNames</span>;
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">AddressOfFunctions</span>;         <span style="color: #b22222;">// </span><span style="color: #b22222;">&#23548;&#20986;&#22320;&#22336;&#34920; EAT&#65292;Exprot Address Table</span>
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">AddressOfNames</span>;             <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31526;&#21495;&#21517;&#34920; Name Table</span>
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">AddressOfNameOrdinals</span>;      <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21517;&#23383;&#24207;&#21495;&#23545;&#24212;&#34920; Name-Ordinal Table</span>
} <span style="color: #228b22;">IMAGE_EXPORT_DIRECTORY</span>;
</pre>
</div>

<p>
导出地址表保存各函数的RVA，符号名表是已排序的符号名数组，名字序号对应表是为了兼容早期版本而保留的。
</p>

<p>
DLL支持导出重定向（export forwarding），如Windows XP中kernel32.dll的函数HeapAlloc被重定向为ntdll.dll中的RtlAllocHeap。要做到这一点，可以修改def文件完成：
</p>
<div class="org-src-container">
<pre class="src src-def">EXPORTS
HeapAlloc = NTDLL.RtlAllocHeap
</pre>
</div>
<p>
如果一个符号被重定向，它的RVA指向导出表中的一个字符串，记录了目标符号的名称。
</p>

<p>
PE也有一个导入表（import table）：
</p>
<div class="org-src-container">
<pre class="src src-shell">dumpbin /IMPORTS Math.dll
</pre>
</div>

<p>
在PE文件中，导入表用结构体IMAGE<sub>IMPORT</sub><sub>DESCRIPTOR描述</sub>：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">OriginalFirstThunk</span>;
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">TimeDateStamp</span>;
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">ForwarderChain</span>;
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">Name</span>;
    <span style="color: #228b22;">DWORD</span> <span style="color: #a0522d;">FirstThunk</span>;
} <span style="color: #228b22;">IMAGE_IMPORT_DESCRIPTOR</span>;
</pre>
</div>

<p>
FirstThunk指向导入地址数组（import address table，IAT）。IAT的每个元素对应一个符号。
</p>
</div>
</div>

<div id="outline-container-org76c238a" class="outline-2">
<h2 id="org76c238a">内存</h2>
<div class="outline-text-2" id="text-org76c238a">
<p>
Linux下内存的典型布局
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">0xFFFFFFFF</td>
</tr>

<tr>
<td class="org-left">kernel space</td>
<td class="org-right">0xc0000000</td>
</tr>

<tr>
<td class="org-left">stack</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#x2026;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">dynamic library</td>
<td class="org-right">0x40000000</td>
</tr>

<tr>
<td class="org-left">&#x2026;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">heap</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">read/write secionts(.data, .bss)</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">readonly sections(.init, .rodata, .text)</td>
<td class="org-right">0x08048000</td>
</tr>

<tr>
<td class="org-left">reversed</td>
<td class="org-right">0x00000000</td>
</tr>
</tbody>
</table>

<p>
栈（stack）是一个先进后出（First In Last Out, FILO）队列。现代操作系统中，栈是向低地址增长的。栈顶位置记录在esp寄存器中。压栈会减小esp的值，反之，弹栈是esp的值增加。栈保存了函数调用需要的信息，叫做堆栈帧（stack frame）或活动记录（activate record）。堆栈帧包括
</p>
<ul class="org-ul">
<li>函数的返回地址和参数</li>
<li>临时变量</li>
<li>上下文，如函数调用前后需要保持不变的寄存器</li>
</ul>

<p>
在i386上，堆栈帧的范围由ebp和esp确定。esp指向栈顶，ebp指向栈低。ebp-4是函数的返回地址。ebp-8开始是压栈的参数。i386的函数调用几乎总是
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #0000ff;">push</span> <span style="color: #a020f0;">ebp</span>
<span style="color: #0000ff;">mov</span> <span style="color: #a020f0;">ebp</span>, esp
<span style="color: #b22222;">;; </span><span style="color: #b22222;">sub esp, N ;; optional, allocate space for local variables</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">push XXX   ;; optional, save registers</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">...</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">pop XXX    ;; optional, load registers</span>
<span style="color: #0000ff;">mov</span> <span style="color: #a020f0;">esp</span>, ebp
<span style="color: #0000ff;">pop</span> <span style="color: #a020f0;">ebp</span>
<span style="color: #0000ff;">ret</span>
</pre>
</div>

<p>
在msvc的调试模式下，所有栈空间都被初始化为0xCC。0xCCCC在GBK编码下是汉字“烫”。有时也会初始化为0xCD。0xCDCD在GBK下是汉字“屯”。
</p>

<p>
一些Windows函数在push ebp之前会插入一条指令mov edi, edi。这是一个指令占位符，用于实现钩子（hook）机制。
</p>


<p>
调用惯例（calling convention）包括
</p>
<ul class="org-ul">
<li>参数传递顺序</li>
<li>栈的维护方式</li>
<li>名字修饰（name-mangling）策略</li>
</ul>

<p>
C语言的默认调用惯例记为<sub>cdecl</sub>，在GCC下是_<sub>attribute</sub>_<sub>((cdcel))</sub>。常见的调用惯例有：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">调用惯例</th>
<th scope="col" class="org-left">参数传递</th>
<th scope="col" class="org-left">栈平衡</th>
<th scope="col" class="org-left">符号命名</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">cdecl</td>
<td class="org-left">从右至左</td>
<td class="org-left">调用方</td>
<td class="org-left">下划线+函数名</td>
</tr>

<tr>
<td class="org-left">stdcall</td>
<td class="org-left">从右至左</td>
<td class="org-left">函数自身</td>
<td class="org-left">下划线+函数+@+参数字节数</td>
</tr>

<tr>
<td class="org-left">fastcall</td>
<td class="org-left">前两个参数保存到寄存器，其余从右至左入栈</td>
<td class="org-left">函数自身</td>
<td class="org-left">@+函数名+@+参数字节数</td>
</tr>

<tr>
<td class="org-left">pascal</td>
<td class="org-left">从左至右</td>
<td class="org-left">函数自身</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>


<p>
函数的返回值通常通过eax返回。如果返回值超过32位，eax存储低32位，edx存储高32位。如果返回值更大，会在栈上分配一个空间，将空间的地址作为隐藏参数传递给函数，函数返回时，将数据复制到这个空间中，并通过eax将空间地址返回。函数返回后，将空间复制到外部变量的地址。
</p>


<p>
Linux下的堆有两种分配方式：brk()和mmap()。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">int</span> <span style="color: #0000ff;">brk</span>(<span style="color: #228b22;">void</span> *<span style="color: #a0522d;">end_of_data_segment</span>);
</pre>
</div>

<p>
brk可以设置进场数据段的结束位置。mmap类似Windows下的VirtualAlloc，向系统申请一段虚拟地址空间。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">void</span> *<span style="color: #0000ff;">mmap</span>(<span style="color: #228b22;">void</span> *<span style="color: #a0522d;">start</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">length</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">prot</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">flags</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">fd</span>, <span style="color: #228b22;">off_t</span> <span style="color: #a0522d;">offset</span>);
</pre>
</div>

<p>
glibc里的malloc最小内存做了优化处理。如果申请的空间小于128KB，malloc使用现有堆空间，如果大于128KB，会通过mmap分配新空间。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">void</span>* <span style="color: #0000ff;">malloc</span>(<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">size</span>) {
    <span style="color: #228b22;">void</span> *<span style="color: #a0522d;">ret</span> = mmap(0, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
    <span style="color: #a020f0;">if</span> (ret == MAP_FAILED) {
        <span style="color: #a020f0;">return</span> 0;
    }

    <span style="color: #a020f0;">return</span> ret;
}
</pre>
</div>

<p>
malloc会受到资源限制（limit）、物理内存和交换空间之和的约束。
</p>

<p>
Windows线程栈默认1MB大小。
HeapCreate/HeapAlloc/HeapFree/HeapDestroy。
</p>




<p>
常见的堆分配算法有空闲链表、位图和对象池。位图的方法将内存划分为大小相同的块。块有3中状态：头（head）、体（body）和空闲。当分配内存时，找到一组连续的空闲块，将其中首个块设置为头，其余设置为体，然后返回给客户程序。内存块的状态统一维护。位图的堆栈不容易破坏，但是容易产生内存碎片。
</p>
</div>
</div>

<div id="outline-container-org49408cf" class="outline-2">
<h2 id="org49408cf">运行库</h2>
<div class="outline-text-2" id="text-org49408cf">
<p>
glibc的入口是<sub>start</sub>。在<sub>start里</sub>，会将env、args、argc依次压栈，然后通过_<sub>libc</sub><sub>start</sub><sub>main调用main函数</sub>。
</p>

<p>
msvc的入口是int mainCRTStartup(void)。
</p>

<p>
C运行库的主要功能包括
</p>
<ul class="org-ul">
<li>用户程序的启动和退出</li>
<li>标准函数</li>
<li>I/O</li>
<li>堆</li>
<li>语言实现</li>
<li>调试</li>
</ul>

<p>
msvc静态库的命名规则：
lib [p] [mt] [d] .lib
p cpp
mt multi thread
d debug
</p>

<p>
线程私有数据有
</p>
<ul class="org-ul">
<li>局部变量</li>
<li>函数参数</li>
<li>TLS数据</li>
</ul>

<p>
线程共享数据有
</p>
<ul class="org-ul">
<li>全局变量</li>
<li>堆数据</li>
<li>函数静态变量</li>
<li>程序代码</li>
<li>打开的文件</li>
</ul>

<p>
在gcc中，errno定义为
#define errno (*_<sub>errno</sub><sub>location</sub> ())
这是一个线程本地对象。
</p>

<p>
TLS对象创建：
TlsAlloc
TlsGetValue
TlsSetValue
TlsFree
</p>

<p>
pthread<sub>key</sub><sub>create</sub>
pthread<sub>getspecific</sub>
pthread<sub>setspecific</sub>
pthread<sub>key</sub><sub>delete</sub>
</p>

<p>
glibc的全局构造函数放在.ctors段中，将函数指针放到这个段，可以在main之前运行函数。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">my_init</span>(<span style="color: #228b22;">void</span>) {
    printf(<span style="color: #8b2252;">"Hello "</span>);
}

<span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">void</span> (*<span style="color: #228b22;">ctor_t</span>) (<span style="color: #228b22;">void</span>);
<span style="color: #228b22;">ctor_t</span> <span style="color: #a020f0;">__attribute__</span>((section (<span style="color: #8b2252;">".ctors"</span>))) <span style="color: #a0522d;">my_init_p</span> = &amp;my_init;

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    printf(<span style="color: #8b2252;">"World!\n"</span>);
    <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>

<p>
gcc提供了一个简单的语法
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">my_init</span>(<span style="color: #228b22;">void</span>) <span style="color: #a020f0;">__attribute__</span>((constructor));
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">my_init</span>(<span style="color: #228b22;">void</span>) {
    printf(<span style="color: #8b2252;">"Hello "</span>);
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    printf(<span style="color: #8b2252;">"World!\n"</span>);
    <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga9bfd6f" class="outline-2">
<h2 id="orga9bfd6f">系统调用与API</h2>
<div class="outline-text-2" id="text-orga9bfd6f">
<p>
Linux系统调用采用0x80中断，Windows采用0x2E中断。
</p>

<p>
Linux在在执行0x80中断之前，系统必须进行堆栈切换，从用户态切换到内核态：
</p>
<ul class="org-ul">
<li>保存ESP和SS</li>
<li>将ESP和SS设置为内核态的值</li>
</ul>
<p>
在返回时恢复用户栈的ESP和SS。
</p>

<p>
从2.5开始，Linux采用sysenter和sysexit进行系统调用。
</p>
</div>
</div>

<div id="outline-container-org22ebe63" class="outline-2">
<h2 id="org22ebe63">运行库实现</h2>
<div class="outline-text-2" id="text-org22ebe63">
<p>
-fno-rtti 和/GR- 会关闭RTTI
-fno-exceptions 关闭异常
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2019-09-23 周一 18:45</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>

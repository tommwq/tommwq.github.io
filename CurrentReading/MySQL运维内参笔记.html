<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-10-28 周一 19:45 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MySQL运维内参笔记</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">MySQL运维内参笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org419b8d8">第一部分 MySQL篇</a>
<ul>
<li><a href="#org5c1b4bb">MySQL源代码入门</a></li>
<li><a href="#org32688a5">MySQL启动过程</a></li>
<li><a href="#org07032de">连接的生命与使命</a></li>
<li><a href="#org2220bd0">MySQ表对象缓存</a></li>
<li><a href="#org6c282e8">InnoDB初探</a></li>
<li><a href="#orgeb5e15e">InnoDB数据字典</a></li>
<li><a href="#org03e0a66">InnoDB数据存储结构</a></li>
<li><a href="#org6c4c8fa">InnoDB索引实现原理</a></li>
<li><a href="#orgebc1949">InnoDB记录格式</a></li>
<li><a href="#org0ccab77">解密独特的两次写</a></li>
<li><a href="#org2e9286a">InnoDB日志管理机制</a></li>
<li><a href="#org0b9d3e4">MySQL5.7中崭新的MySQL sys Schema</a></li>
<li><a href="#orgbfd7616">方便的MySQL GTID</a></li>
<li><a href="#org959fb70">MySQL半同步复制</a></li>
<li><a href="#orgbf9ccad">MySQL 5.7多线程复制原理</a></li>
<li><a href="#orgd32435e">大量MySQL表导致服务变慢的问题</a></li>
<li><a href="#org224615f">MySQL快速删除大表</a></li>
<li><a href="#orgab8247a">两条不同的插入语句导致的死锁</a></li>
<li><a href="#org6e36ce2">MySQL在并发删除同一行数据时导致死锁的分析</a></li>
<li><a href="#org138e117">参数SQL_SLAVE_SKIP_COUNTER的奥秘</a></li>
<li><a href="#org3ecc4d8">Binlog中的时间戳</a></li>
<li><a href="#orgd285499">InnoDB中Rowid对Binlog的影响</a></li>
<li><a href="#org77a5ab0">MySQL备份：Percona XtraBackup的原理与实践</a></li>
<li><a href="#org8d33b83">MySQL分库分表</a></li>
<li><a href="#org9c61541">MySQL数据安全</a></li>
<li><a href="#org311c745">MySQL性能拾遗</a></li>
<li><a href="#orgd796d2b">MySQL Group Replication</a></li>
<li><a href="#orgc018b53">MySQL Document Store面面观</a></li>
</ul>
</li>
<li><a href="#org4764ddf">附录：MySQL 8.0.15 提供的系统表</a></li>
<li><a href="#orge12c1cd">附录：参考资料</a></li>
<li><a href="#org975ab0e">试验</a>
<ul>
<li><a href="#org45863e1">在Windows上编译MySQL</a></li>
<li><a href="#org0218338">在Linux上编译MySQL</a></li>
<li><a href="#org04fad78">Master-Slave</a></li>
<li><a href="#org0fe8fcb">Master-Master</a></li>
<li><a href="#org998e33c">搭建Group Replication集群</a></li>
<li><a href="#orga6dba09">编写MySQL插件</a></li>
<li><a href="#org4de2e2f">搭建PXC集群</a></li>
<li><a href="#orgb768789">手动同步数据库</a></li>
<li><a href="#org6966809">使用sysbench进行测试</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org419b8d8" class="outline-2">
<h2 id="org419b8d8">第一部分 MySQL篇</h2>
<div class="outline-text-2" id="text-org419b8d8">
</div>
<div id="outline-container-org5c1b4bb" class="outline-3">
<h3 id="org5c1b4bb">MySQL源代码入门</h3>
<div class="outline-text-3" id="text-org5c1b4bb">
<p>
MySQL源代码包含以下目录或文件：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">BUILD</td>
<td class="org-left">编译脚本目录</td>
</tr>

<tr>
<td class="org-left">CMakeLists.txt</td>
<td class="org-left">CMake文件</td>
</tr>

<tr>
<td class="org-left">client</td>
<td class="org-left">客户端工具</td>
</tr>

<tr>
<td class="org-left">cmake</td>
<td class="org-left">CMake目录</td>
</tr>

<tr>
<td class="org-left">cmd-line-utils</td>
<td class="org-left">一些小工具</td>
</tr>

<tr>
<td class="org-left">config.h.cmake</td>
<td class="org-left">用于生成.cmake文件</td>
</tr>

<tr>
<td class="org-left">dbug</td>
<td class="org-left">调试用的宏</td>
</tr>

<tr>
<td class="org-left">extra</td>
<td class="org-left">网络和加密小工具</td>
</tr>

<tr>
<td class="org-left">include</td>
<td class="org-left">所有头文件</td>
</tr>

<tr>
<td class="org-left">libbinlogevents</td>
<td class="org-left">解析binlog</td>
</tr>

<tr>
<td class="org-left">libmysql</td>
<td class="org-left">嵌入式MySQL客户端核心</td>
</tr>

<tr>
<td class="org-left">libmysqld</td>
<td class="org-left">嵌入式MySQL服务器核心</td>
</tr>

<tr>
<td class="org-left">mysql-test</td>
<td class="org-left">测试工具</td>
</tr>

<tr>
<td class="org-left">mysys</td>
<td class="org-left">常用数据结构和算法</td>
</tr>

<tr>
<td class="org-left">mysys_ssl</td>
<td class="org-left">SSL相关的服务</td>
</tr>

<tr>
<td class="org-left">plugin</td>
<td class="org-left">插件</td>
</tr>

<tr>
<td class="org-left">regex</td>
<td class="org-left">正则表达式</td>
</tr>

<tr>
<td class="org-left">scripts</td>
<td class="org-left">系统工具脚本</td>
</tr>

<tr>
<td class="org-left">sql</td>
<td class="org-left">MySQL服务器主要代码</td>
</tr>

<tr>
<td class="org-left">sql-common</td>
<td class="org-left">服务器和客户端共用代码</td>
</tr>

<tr>
<td class="org-left">storage</td>
<td class="org-left">引擎</td>
</tr>

<tr>
<td class="org-left">strings</td>
<td class="org-left">字符串</td>
</tr>

<tr>
<td class="org-left">support-files</td>
<td class="org-left">配置文件和编译工具</td>
</tr>

<tr>
<td class="org-left">unittest</td>
<td class="org-left">单元测试</td>
</tr>

<tr>
<td class="org-left">vio</td>
<td class="org-left">网络和IO</td>
</tr>

<tr>
<td class="org-left">win</td>
<td class="org-left">Windows平台下的编译文件</td>
</tr>

<tr>
<td class="org-left">zlib</td>
<td class="org-left">zlib库</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-org32688a5" class="outline-3">
<h3 id="org32688a5">MySQL启动过程</h3>
<div class="outline-text-3" id="text-org32688a5">
<p>
MySQL的启动由函数mysqld_main执行，启动步骤如下：
</p>
<ul class="org-ul">
<li>加载配置文件</li>
<li>初始化日志系统</li>
<li>初始化信号系统</li>
<li>初始化核心模块（如存储引擎）</li>
<li>文件重定向</li>
<li>初始化网络系统</li>
<li>初始化状态变量</li>
<li>检查binlog</li>
<li>建立服务监听线程</li>
</ul>
</div>
</div>

<div id="outline-container-org07032de" class="outline-3">
<h3 id="org07032de">连接的生命与使命</h3>
<div class="outline-text-3" id="text-org07032de">
<p>
MySQL使用poll或select处理TCP连接。收到连接请求后，MySQL为客户端分配一个线程，如果线程缓存（thread_cache）没有空闲，就新建一个线程。新建线程的工作由handle_one_connection完成，它的处理逻辑如下：
</p>
<ul class="org-ul">
<li>初始化线程。</li>
<li>设置session变量。</li>
<li>循环。
<ul class="org-ul">
<li>初始化lex词法解析器。</li>
<li>认证。</li>
<li>初始化工作环境。</li>
<li>循环。
<ul class="org-ul">
<li>处理客户端命令。</li>
</ul></li>
<li>关闭连接，将线程加入线程缓存。</li>
</ul></li>
</ul>

<p>
处理客户端命令的工作由函数do_command完成，它的处理逻辑如下：
</p>
<ul class="org-ul">
<li>读取网络数据。</li>
<li>解析命令。</li>
<li>分派命令。</li>
</ul>

<p>
dispatch_command函数负责分派命令。它包含一个巨大的switch语句。对于最常见的查询语句，MySQL对调用mysql_parse解析命令并执行。mysql_parse通过query_cache_send_result_to_client检查并发送SQL结果缓存。如果缓存失效，mysql_parse调用parse_sql和mysql_execute_command解析执行。
</p>
</div>
</div>


<div id="outline-container-org2220bd0" class="outline-3">
<h3 id="org2220bd0">MySQ表对象缓存</h3>
<div class="outline-text-3" id="text-org2220bd0">
<p>
为了加速对表的访问，MySQL把表的基础信息（如表名、列信息、字符集）缓存在内存中，封装成TABLE_SHARES对象。TABLE_SHARES和存储引擎无关，通过锁进行并发保护。进程打开表时，从TABLE_SHARES构造一个TABLE对象。TABLE_SHARES是唯一的，TABLE不是。在MDL不冲突的情况下，每个线程都可以拥有自己的TABLE对象。
</p>
</div>
</div>

<div id="outline-container-org6c282e8" class="outline-3">
<h3 id="org6c282e8">InnoDB初探</h3>
<div class="outline-text-3" id="text-org6c282e8">
<p>
information_schema表是MySQL自带的，记录数据源元数据的库。sys是系统信息库，performance_schema是性能信息库。
</p>

<p>
InnoDB的初始化函数是innobase_init。它执行以下步骤：
</p>
<ul class="org-ul">
<li>初始化缓冲区池。</li>
<li>初始化日志。</li>
<li>初始化IO线程。</li>
<li>打开数据文件。</li>
<li>从检查点恢复。</li>
<li>建立double write缓冲区。</li>
<li>启动主线程。</li>
<li>启动工作线程。</li>
<li>启动磁盘刷写线程。</li>
</ul>
</div>
</div>

<div id="outline-container-orgeb5e15e" class="outline-3">
<h3 id="orgeb5e15e">InnoDB数据字典</h3>
<div class="outline-text-3" id="text-orgeb5e15e">
<p>
InnoDB数据表的元数据记录在information_schema库的INNODB_TABLES、INNODB_COLUMNS、INNODB_INDEXES、INNODB_FIELDS、INNODB_VIRTUAL等几个表中。
</p>

<p>
information_schema.INNODB_TABLES记录了表的信息，它的各列如下：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">NAME</td>
<td class="org-left">名字</td>
</tr>

<tr>
<td class="org-left">ID</td>
<td class="org-left">表的ID</td>
</tr>

<tr>
<td class="org-left">N_COLS</td>
<td class="org-left">列数</td>
</tr>

<tr>
<td class="org-left">TYPE</td>
<td class="org-left">表的存储类型</td>
</tr>

<tr>
<td class="org-left">ROW_FORMAT</td>
<td class="org-left">行类型</td>
</tr>

<tr>
<td class="org-left">SPACE</td>
<td class="org-left">表空间ID号</td>
</tr>
</tbody>
</table>

<p>
information_schema.INNODB_COLUMNS记录了列的信息，它的各列如下：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">TABLE_ID</td>
<td class="org-left">表ID</td>
</tr>

<tr>
<td class="org-left">NAME</td>
<td class="org-left">列名</td>
</tr>

<tr>
<td class="org-left">POS</td>
<td class="org-left">位置，从0开始</td>
</tr>

<tr>
<td class="org-left">MTYPE</td>
<td class="org-left">主数据类型</td>
</tr>

<tr>
<td class="org-left">PRTYPE</td>
<td class="org-left">精确数据类型</td>
</tr>

<tr>
<td class="org-left">LEN</td>
<td class="org-left">数据长度</td>
</tr>

<tr>
<td class="org-left">HAS_DEFAULT</td>
<td class="org-left">是否有默认值</td>
</tr>

<tr>
<td class="org-left">DEFAULT_VALUE</td>
<td class="org-left">默认值</td>
</tr>
</tbody>
</table>

<p>
information_schema.INNODB_INDEXES是索引信息，它的各列如下：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">TABLE_ID</td>
<td class="org-left">表ID</td>
</tr>

<tr>
<td class="org-left">ID</td>
<td class="org-left">索引ID</td>
</tr>

<tr>
<td class="org-left">NAME</td>
<td class="org-left">索引名</td>
</tr>

<tr>
<td class="org-left">N_FIELDS</td>
<td class="org-left">索引包含的列数</td>
</tr>

<tr>
<td class="org-left">TYPE</td>
<td class="org-left">索引类型</td>
</tr>

<tr>
<td class="org-left">SPACE</td>
<td class="org-left">表空间ID</td>
</tr>

<tr>
<td class="org-left">PAGE_NO</td>
<td class="org-left">B+树的根页面</td>
</tr>
</tbody>
</table>

<p>
information_schema.INNODB_FIELDS是索引中列的信息，它的各列如下：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">INDEX_ID</td>
<td class="org-left">索引ID</td>
</tr>

<tr>
<td class="org-left">NAME</td>
<td class="org-left">索引名字</td>
</tr>

<tr>
<td class="org-left">POS</td>
<td class="org-left">索引位置</td>
</tr>
</tbody>
</table>

<p>
information_schema.INNODB_VIRTUAL记录了虚拟列的信息，它的结构如下：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">TABLE_ID</td>
<td class="org-left">表ID</td>
</tr>

<tr>
<td class="org-left">POS</td>
<td class="org-left">虚拟列全部依赖列序号之和 &lt;&lt; 16 + 虚拟列序号</td>
</tr>

<tr>
<td class="org-left">BASE_POS</td>
<td class="org-left">虚拟列所依赖的列，从0开始</td>
</tr>
</tbody>
</table>

<p>
虚拟列是不会持久化的，它是从其他列计算得出的。下面是一个例子：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #FBDE2D;">create</span> <span style="color: #FBDE2D;">table</span> `t1` (
  `a` <span style="color: #8DA6CE;">int</span>(11) <span style="color: #FBDE2D;">default</span> <span style="color: #FBDE2D;">null</span>,
  `b` <span style="color: #8DA6CE;">int</span>(11) <span style="color: #FBDE2D;">default</span> <span style="color: #FBDE2D;">null</span>,
  `c` <span style="color: #8DA6CE;">int</span>(11) <span style="color: #FBDE2D;">generated</span> always <span style="color: #FBDE2D;">as</span> (a+b) virtual,
) engine=InnoDB <span style="color: #FBDE2D;">default</span> charset=utf8mb4;
</pre>
</div>

<p>
在表t1中，列c就是一个虚拟列。列c依赖于列a和列b，因此在INNODB_VIRTUAL中，列c会对应两条记录。
</p>


<p>
上面提到的5个表是数据字典对象。在storage/innobase/include/dict0dict.h中定义了数据结构struct dict_sys_t，里面有5个成员指向上述表：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #FBDE2D;">struct</span> <span style="color: #8DA6CE;">dict_sys_t</span> {
  <span style="color: #AEAEAE; font-style: italic;">// </span><span style="color: #AEAEAE; font-style: italic;">...</span>
  <span style="color: #8DA6CE;">hash_table_t</span> *<span style="color: #FF6400;">table_hash</span>;    <span style="color: #AEAEAE; font-style: italic;">/*</span><span style="color: #AEAEAE; font-style: italic;">!&lt; hash table of the tables, based</span>
<span style="color: #AEAEAE; font-style: italic;">                               on name </span><span style="color: #AEAEAE; font-style: italic;">*/</span>
  <span style="color: #8DA6CE;">hash_table_t</span> *<span style="color: #FF6400;">table_id_hash</span>; <span style="color: #AEAEAE; font-style: italic;">/*</span><span style="color: #AEAEAE; font-style: italic;">!&lt; hash table of the tables, based</span>
<span style="color: #AEAEAE; font-style: italic;">                               on id </span><span style="color: #AEAEAE; font-style: italic;">*/</span>

  <span style="color: #8DA6CE;">dict_table_t</span> *<span style="color: #FF6400;">sys_tables</span>;  <span style="color: #AEAEAE; font-style: italic;">/*</span><span style="color: #AEAEAE; font-style: italic;">!&lt; SYS_TABLES table </span><span style="color: #AEAEAE; font-style: italic;">*/</span>
  <span style="color: #8DA6CE;">dict_table_t</span> *<span style="color: #FF6400;">sys_columns</span>; <span style="color: #AEAEAE; font-style: italic;">/*</span><span style="color: #AEAEAE; font-style: italic;">!&lt; SYS_COLUMNS table </span><span style="color: #AEAEAE; font-style: italic;">*/</span>
  <span style="color: #8DA6CE;">dict_table_t</span> *<span style="color: #FF6400;">sys_indexes</span>; <span style="color: #AEAEAE; font-style: italic;">/*</span><span style="color: #AEAEAE; font-style: italic;">!&lt; SYS_INDEXES table </span><span style="color: #AEAEAE; font-style: italic;">*/</span>
  <span style="color: #8DA6CE;">dict_table_t</span> *<span style="color: #FF6400;">sys_fields</span>;  <span style="color: #AEAEAE; font-style: italic;">/*</span><span style="color: #AEAEAE; font-style: italic;">!&lt; SYS_FIELDS table </span><span style="color: #AEAEAE; font-style: italic;">*/</span>
  <span style="color: #8DA6CE;">dict_table_t</span> *<span style="color: #FF6400;">sys_virtual</span>; <span style="color: #AEAEAE; font-style: italic;">/*</span><span style="color: #AEAEAE; font-style: italic;">!&lt; SYS_VIRTUAL table </span><span style="color: #AEAEAE; font-style: italic;">*/</span>
};
</pre>
</div>

<p>
这个结构体里还有两个散列表：table_hash和table_id_hash。它们包含InnoDB所有的表（系统表、用户表），一个按照名字散列，一个按ID散列。当首次打开用户表时，InnoDB就会从字典对象中读取表信息。这个过程由函数dict_load_table_one（storage/innobase/dict/dict0load.cc）进行。加载了表的元数据之后，InnoDB才能正确解析B+树中的记录。列的加载和表加载的过程类似。InnoDB会自动为表增加列TRXID和列ROLLPTR，以及可选的Rowid列。TRXID是最后一次修改记录的事务ID，ROLLPTR指向记录原来值的位置。Rowid是行号。如果用户没有为表建立主键，InnoDB会自动建立Rowid列作为隐藏的主键。Rowid的只是全局共享的，所有表都会更新Rowid。为了避免频繁刷写磁盘，InnoDB只有在Rowid是256的整数倍时刷写页面。如果系统崩溃重启，InnoDB会将页面中最大Rowid向上对齐256后，再加上256，以避免冲突。MySQL不会记录库的信息，因此没有加载库的过程。
</p>
</div>
</div>


<div id="outline-container-org03e0a66" class="outline-3">
<h3 id="org03e0a66">InnoDB数据存储结构</h3>
<div class="outline-text-3" id="text-org03e0a66">
<p>
InnoDB数据由表空间管理。每次建立一个数据库，InnoDB会建立文件ibdata1作为表空间文件。如果设置了innodb_file_per_table，每个表会有自己独立的表空间文件。不过这些文件只包含B+树、索引、插入缓冲等信息，其他信息还是保存在默认表空间文件中。
</p>


<p>
表空间文件被划分为若干个段。新建一个索引会分配2个段，一个管理叶节点，一个管理非叶节点。段又被划分为簇（extend）。簇是一段连续的空间，大小是64个页面。数据保存在簇中。如果簇的空间不够了，段会分配一个簇来保存数据。从物理的角度看，段和簇就是链表和链表节点。簇中更细分的单元是页面。一个页面有16KB。因此一个簇有1MB。
</p>
</div>
</div>

<div id="outline-container-org6c4c8fa" class="outline-3">
<h3 id="org6c4c8fa">InnoDB索引实现原理</h3>
<div class="outline-text-3" id="text-org6c4c8fa">
<p>
InnoDB采用B+树作为索引的数据结构。B+树和B树的区别主要在于B+树只有叶子节点会保存数据。InnoDB的每个表都有唯一的聚簇索引（clustered index）。这个索引是建立在主键上的。如果用户没有手动设定主键，聚簇索引建立在InnoDB自动添加的Rowid列上。其他的索引叫做二级索引（secondary index）。聚簇索引比二级索引更快，原因在于聚簇索引包含记录的全部数据，因此只需要一次查找。同时，记录按照聚簇索引顺序排列，减少了随机IO次数。二级索引值包含键数据。在查找时，首先要查找到对应的聚集索引，然后才能读取记录。多了一次查找，同时随机IO次数也增加了。
</p>


<p>
InnoDB用一个页面记录一个B+树节点。对每个节点，InnoDB都会加入虚拟的键min和max（页面中的infimum和supremum）。假设一个节点可以存储k个键，那么它最多可以有k+1个子节点。子节点中可以记录的键就有(k+1)k个。这是一个几何级数：
\[
k + (k+1)k + (k+1)^2k + \cdots + (k+1)^{n-1}k=(k+1)^n - 1 = O(k^n)
\]
</p>

<p>
这里n是B+树的高度。假设一个节点可以容纳1000个键，一个3层高的B+树可以容纳大约10亿个键，一个4层高的B+树可以容纳大约1000^4=1万亿个键。
</p>


<p>
一个页面保存一个B+树节点。页面头部是38位的文件管理头信息，接着是56位的页面头信息。后面跟着两个13位的数据，记录了B+树节点的最小记录和最大记录。在这两个整数后面是存储用户记录的空间、页面槽信息和文件尾部。页面头信息包含两个指针，一个指向未使用的页面空间，另外一个是一个链表，指向可重用（曾经使用过，后来又释放了）空间。页面槽信息保存在一个紧邻页面尾部的数组中，这个数组向上增长。页面槽和用户记录构成一个类似跳表的结构。频繁的插入删除记录可能导致页面碎片（可重用空间）过多，使得数据使用率较低，并且在查询表的时候产生大量无效IO，数据库整体性能下降。通过语句
</p>
<div class="org-src-container">
<pre class="src src-mysql">show table status like '%my_table%';
</pre>
</div>
<p>
可以查看表的data free和data length统计值。如果data free过大而data length很小，就说明表碎片比较多。使用命令
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #FBDE2D;">alter</span> <span style="color: #FBDE2D;">table</span> <span style="color: #FF6400;">my_table</span> engine innodb;
</pre>
</div>
<p>
可以回收这些碎片。
</p>
</div>
</div>

<div id="outline-container-orgebc1949" class="outline-3">
<h3 id="orgebc1949">InnoDB记录格式</h3>
<div class="outline-text-3" id="text-orgebc1949">
<p>
命令
</p>
<div class="org-src-container">
<pre class="src src-sql">show <span style="color: #FBDE2D;">table</span> status <span style="color: #FBDE2D;">like</span> <span style="color: #61CE3C;">'%my_table%'</span>;
</pre>
</div>

<p>
返回的Row_format列描述了表使用的记录格式。对于系统表，这个值是NULL。而用户表通常是Compat或Dynamic等。一条SQL记录实际上是一个元组。在写入记录时，InnoDB将元组转换为对应的记录格式，写入到页面中。这个转换过程由函数rec_convert_dtuple_to_rec_new完成。
</p>
</div>
</div>

<div id="outline-container-org0ccab77" class="outline-3">
<h3 id="org0ccab77">解密独特的两次写</h3>
<div class="outline-text-3" id="text-org0ccab77">
<p>
在MySQL5.7中，两次写（innodb_doublewrite）是默认启用的。启用后，在进行磁盘IO时，首先将页面写入两次写缓冲区，并持久化表空间文件（ibdata），然后再写入实际的位置。两次写是为了保证写入操作的可靠性。但是每次写入都增加一次IO，会对性能产生影响。因此从5.7版本开始，MySQL采用批量的方式进行两次写。有两种情况下，MySQL将页面刷写到磁盘上。一是缓冲区池（buffer pool）不够用了，需要将老的页面淘汰才能分配新页面。这种我们成为LRU方式。另外一种情况是Master线程定期将页面刷写到磁盘上。这种我们叫做LIST方式。
</p>
</div>
</div>

<div id="outline-container-org2e9286a" class="outline-3">
<h3 id="org2e9286a">InnoDB日志管理机制</h3>
<div class="outline-text-3" id="text-org2e9286a">
<p>
和大部分关系型数据库一样，InnoDB对ACID的支持以<a href="https://people.eecs.berkeley.edu/~brewer/cs262/Aries.pdf">ARIES论文</a>为基础。为了便于管理数据页面，InnoDB使用了一个叫做缓冲区池（buffer pool）的模块。缓冲区池采用LRU（最近最少使用）算法维护最近使用过的数据页面。缓冲区池默认是128MB（innodb_buffer_pool_size）大小。增加缓冲区池大小可以提高数据库性能。不过如果缓冲区池比较大（大于1GB）的时候，为了避免线程竞争，最好将缓冲区池分为多个实例（innodb_buffer_pool_instances=8）。
</p>


<p>
从逻辑上，插入操作很简单，就是把一条记录加入到数据表中。但是在物理上，从SQL元组到磁盘页面，之间涉及很多不同层次的操作。为了保证页面层次的ACID特性，MySQL提供了物理事务。物理事务也叫MTR（mini-transaction）。
</p>


<p>
在以下五个情况下，MySQL将日志写入文件或磁盘：
</p>
<ul class="org-ul">
<li>日志缓冲区空间耗尽。</li>
<li>Master线程每秒钟定时刷写日志。</li>
<li>执行DML操作时，如果日志空间使用率超过阈值，MySQL会将日志写入文件（不刷写磁盘）。</li>
<li>保存检查点时，要将最小LSN的页面刷写磁盘。</li>
<li>提交事务时，如果innodb_flush_log_at_trx_commit的值是：
<ul class="org-ul">
<li>0，不会刷写日志。</li>
<li>1，写入日志，同步到磁盘。</li>
<li>2，写入日志，不同步磁盘。</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org0b9d3e4" class="outline-3">
<h3 id="org0b9d3e4">MySQL5.7中崭新的MySQL sys Schema</h3>
<div class="outline-text-3" id="text-org0b9d3e4">
<p>
MySQL5.7提供了sys Schema。sys Schema由一组对象组成，这些对象不会存储信息，而是基于performance_schema和information_schema，以更方便的方式提供出来。sys Schema通过库sys提供，里面大部分是视图、存储过程和函数。其中视图主要分为：
</p>
<ul class="org-ul">
<li>主机相关信息，以host_summary开头。</li>
<li>innodb相关信息，以innodb开头。</li>
<li>io信息，以io开头。</li>
<li>内存信息，以memory开头。</li>
<li>连接与会话信息，包括processlist和session。</li>
<li>表信息，以schema_table开头。</li>
<li>索引信息，名字包含index。</li>
<li>语句信息，以statement开头。</li>
<li>用户信息，以user开头。</li>
<li>等待信息，以wait开头。</li>
</ul>

<p>
下面介绍几个实际的例子。下面的语句可以查看表的访问量
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #FBDE2D;">select</span> table_schema,<span style="color: #FBDE2D;">table_name</span>,io_read_requests+io_write_requests <span style="color: #FBDE2D;">as</span> io_total <span style="color: #FBDE2D;">from</span> sys.schema_table_statistics;
</pre>
</div>

<p>
使用schema_redundant_indexes和schema_unused_indexes可以帮助我们找到冗余索引。使用schema_auto_increment_columns可以检查自增列的使用情况。使用statements_with_full_table_scans可以查看全表扫描的语句：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #FBDE2D;">select</span> query,
    exec_count,
    total_latency,
    rows_sent_avg/rows_examined_avg,
    round(substr(total_latency, 1, locate(" ", total_latency)) / exec_count)  <span style="color: #FBDE2D;">as</span> latency_avg 
<span style="color: #FBDE2D;">from</span> sys.statements_with_full_table_scans <span style="color: #FBDE2D;">where</span> db=<span style="color: #61CE3C;">'sys'</span> 
<span style="color: #FBDE2D;">order</span> <span style="color: #FBDE2D;">by</span> latency_avg <span style="color: #FBDE2D;">desc</span>;
</pre>
</div>

<p>
使用io_global_by_file_by_bytes可以查看产生大量IO的数据库：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #FBDE2D;">select</span> * <span style="color: #FBDE2D;">from</span> sys.io_global_by_file_by_bytes
</pre>
</div>

<p>
当然，启用performance_schema（performance_schema=on）会对性能产生影响。一些研究表明，performance_schema会降低大约10%的性能表现。
</p>
</div>
</div>


<div id="outline-container-orgbfd7616" class="outline-3">
<h3 id="orgbfd7616">方便的MySQL GTID</h3>
<div class="outline-text-3" id="text-orgbfd7616">
<p>
GTID是全局事务标识符。有了GTID，事务在一个MySQL集群中就具备了唯一性，让MySQL集群更可靠，更可用，更易维护。在提交事务时，执行线程会得到一个GTID，它的格式是
</p>
<div class="org-src-container">
<pre class="src src-text">GTID = source_id:sequence_id
</pre>
</div>

<p>
source_id是MySQL实例的唯一标识，sequence_id则是事务在该实例上分配的序号。在同一个实例中，sequence_id是递增的。使用下面的语句可以查看系统的GTID：
</p>
<div class="org-src-container">
<pre class="src src-sql">show master status;
show slave status;
</pre>
</div>

<p>
GTID的生命周期如下：
</p>
<ul class="org-ul">
<li>master执行事务，产生GTID，保存到binlog。</li>
<li>master将binlog发送给slave，slave将其保存到relay log中，并将gtid_next设置为GTID的值。</li>
<li>如果这个GTID没有在slave提交，slave提交事务，写入binlog。</li>
</ul>

<p>
从MySQL 5.7.5开始，mysql库增加了表gtid_executed来记录GTID。如果变量gtid_mode为ON或ON_PERMISSIVE，MySQL会将GTID写入gtid_executed表。如果同时启用了binlog，，GTID也会写入binlog。为了避免这个表增长过快，MySQL提供了压缩机制。压缩后，同一个source_id的记录合并为一条。压缩的时机由变量executed_gtid_compression_period控制。这个变量默认值是1000，表示执行1000个事务后进行压缩。压缩由线程thread/sql/compress_gtid_table进行。此外，执行reset master会清空gtid_executed表。
</p>


<p>
GTID的一个用途是搭建主从同步。这时要对MySQL进行配置：
</p>
<ul class="org-ul">
<li>server_id。每个MySQL实例的server_id不能相同。</li>
<li>gtid_mode=ON。开启GTID。</li>
<li>enforce_gtid_consistency=ON。保证GTID一致性。</li>
<li>log-bin。开启binlog。</li>
<li>log-slave-updates=1。</li>
<li>binlog_format=ROW。</li>
<li>skip-slave-start=1。slave启动时不会自动开始复制。</li>
</ul>

<p>
使用GTID复制可以方便的动态调整拓扑结构，直接执行下面的语句就可以：
</p>
<div class="org-src-container">
<pre class="src src-sql">stop slave;
change master <span style="color: #FBDE2D;">to</span> master_host=<span style="color: #61CE3C;">'127.0.0.1'</span>,master_port=3306,master_auto_position=1;
<span style="color: #FBDE2D;">start</span> slave;
</pre>
</div>

<p>
GTID复制非常方法，但也存在一些局限。由于GTID是基于事务的，下列场景GTID无法支持：
</p>
<ul class="org-ul">
<li>事务中混用多个存储引擎。这会产生多个GTID。</li>
<li>主从库存储引擎不一致。</li>
<li>不支持CREATE TABLE &#x2026; SELECT。这个语句其实是两个步骤：创建表和插入记录。</li>
<li>不支持CREATE TEMPORARY TABLE和DROP TEMPORARY TABLE。</li>
<li>不要再GTID库上进行mysql_upgrade。</li>
</ul>
</div>
</div>

<div id="outline-container-org959fb70" class="outline-3">
<h3 id="org959fb70">MySQL半同步复制</h3>
<div class="outline-text-3" id="text-org959fb70">
<p>
默认情况下MySQL采用异步方式进行同步。如果主库崩溃，尚未同步到从库的事务可能会丢失。MySQL还有一种全同步机制，只有在所有从库都提交了事务之后，主库才认为事务提交完成。异步复制是高性能低可靠的，全同步复制是高可靠低性能的。而实际的业务需求往往要兼顾可靠性和性能，为此MySQL提供了半同步复制插件（rpl_semi_sync_master）。如果主库和从库都配置了半同步，在提交事务时，主库会将binlog发送给从库，当（至少一个）从库接收了事务所有的binlog并写入relay log后，主库才认为提交完成。如果从库一直没有接收binlog，主库在超时后会关闭半同步，切换为异步同步。在切换为异步同步后，如果某个从库重新赶上了主库的进度，MySQL会再次切换为半同步复制。
</p>

<p>
开启半同步首先需要安装插件：
</p>
<div class="org-src-container">
<pre class="src src-sql">INSTALL PLUGIN rpl_semi_sync_master SONAME <span style="color: #61CE3C;">'semisync_master.dll'</span>
</pre>
</div>
<p>
或
</p>
<div class="org-src-container">
<pre class="src src-sql">INSTALL PLUGIN rpl_semi_sync_master SONAME <span style="color: #61CE3C;">'semisync_slave.dll'</span>
</pre>
</div>

<p>
安装之后，MySQL会将插件信息写入mysql.plugin表，重启MySQL不需要重新安装。
</p>


<p>
接着是配置半同步变量：
</p>
<ul class="org-ul">
<li>rpl_semi_sync_master_enabled=1</li>
<li>rpl_semi_sync_master_timeout=1000</li>
<li>rpl_semi_sync_slave_enabled=1</li>
</ul>
</div>
</div>


<div id="outline-container-orgbf9ccad" class="outline-3">
<h3 id="orgbf9ccad">MySQL 5.7多线程复制原理</h3>
<div class="outline-text-3" id="text-orgbf9ccad">
<p>
通常应对MySQL延迟高有以下几种方法：
</p>
<ul class="org-ul">
<li>增大innodb_buffer_pool_size，降低IO次数。</li>
<li>增大innodb_log_file_size、innodb_log_files_in_group，减少buffer pool磁盘IO。</li>
<li>在SSD（或高性能磁盘）下将innodb_flush_method设置为O_DIRECT。</li>
<li>（可选）关闭从库binlog，或关闭从库log_slave_updates。</li>
<li>将innodb_flush_log_at_trx_commit设置为0或2。</li>
<li>将sync_binlog设置为0或一个大数。</li>
<li>将binlog_format设置为row。</li>
<li>将master_info_repository、relay_log_info_repository设置为TABLE。</li>
</ul>

<p>
MySQL 5.6开始支持多线程复制，但是这个功能直到5.7才完善。多线程复制指的是从库在接收到binlog后，多线程并行应用binlog。这样可以加快复制速度。要启动多线程复制需要修改MySQL配置：
</p>
<ul class="org-ul">
<li>slave_parallel_workers=N。应用binlog的线程数。</li>
<li>slave_parallel_type=logical_clock。并行应用binlog的策略。如果是database，不同数据库的事务并行执行。如果是logical_clock，同一个binlog group中的事务并行执行。</li>
<li>slave_preserve_commit_order=1。按照binlog中的顺序提交事务。要求同时开启&#x2013;log-bin和&#x2013;log-slave-updates，同时slave_parallel_type必须是logical_clock。</li>
</ul>

<p>
开启多线程复制后，从库将收到的binlog分发给SQL线程。SQL线程会等待当前事务的前置事务完成后（last_committed小于low water mark）开始执行。如果在多线程复制过程中从库崩溃，为了知道哪些事务已经执行完毕，哪些正在执行，系统必须重建当时binlog分发情况。为此MySQL建立了数据表mysql.slave_worker_info保存这些信息。
</p>
</div>
</div>

<div id="outline-container-orgd32435e" class="outline-3">
<h3 id="orgd32435e">大量MySQL表导致服务变慢的问题</h3>
<div class="outline-text-3" id="text-orgd32435e">
<p>
如果表的数量过多，InnoDB使用的文件也会很多。如果performance schema观察到某个文件发生了IO指令，会把这个文件记录到数据表performance_schema.file_instances中。这个表使用了散列表来缓存数据，散列表的大小是performance_schema_max_file_instances。如果没有手动设定，这个值会设置为open_files_limit/0.65。一些测试表明，performance_schema_max_file_instances大于200000时性能会出现大幅下降。
</p>
</div>
</div>

<div id="outline-container-org224615f" class="outline-3">
<h3 id="org224615f">MySQL快速删除大表</h3>
<div class="outline-text-3" id="text-org224615f">
<p>
MySQL对表的删除分为两个步骤：清理buffer pool，删除数据文件。在Linux下，可以通过手动删除数据文件的方法加速大表删除。方法是首先用ln为ibd文件建立硬链接，接着删除ibd文件。由于硬链接的存在，数据没有从磁盘上移除，删除ibd文件的过程很快。实际数据的删除，可以在业务不繁忙的时候再进行。
</p>
</div>
</div>

<div id="outline-container-orgab8247a" class="outline-3">
<h3 id="orgab8247a">两条不同的插入语句导致的死锁</h3>
<div class="outline-text-3" id="text-orgab8247a">
<p>
锁封锁的是索引。在可重复读隔离级别下，插入也可能引发死锁。考虑下面这个例子：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #FBDE2D;">create</span> <span style="color: #FBDE2D;">table</span> <span style="color: #FF6400;">my1</span> (
  sno <span style="color: #8DA6CE;">int</span>(11) <span style="color: #FBDE2D;">primary</span> <span style="color: #FBDE2D;">key</span>
) engine=InnoDB;
</pre>
</div>

<p>
这时如果有两个事务t1和t2，按照下列顺序执行（关闭autocommit）：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #AEAEAE; font-style: italic;">-- t1</span>
<span style="color: #FBDE2D;">begin</span>;
<span style="color: #FBDE2D;">insert</span> <span style="color: #FBDE2D;">into</span> my1 <span style="color: #FBDE2D;">values</span>(1); <span style="color: #AEAEAE; font-style: italic;">-- &#22312;&#20027;&#38190;sno=1&#19978;&#21152;&#25490;&#20182;&#38145;</span>
<span style="color: #AEAEAE; font-style: italic;">-- t2</span>
<span style="color: #FBDE2D;">begin</span>;
<span style="color: #FBDE2D;">insert</span> <span style="color: #FBDE2D;">into</span> my1 <span style="color: #FBDE2D;">values</span>(1); <span style="color: #AEAEAE; font-style: italic;">-- &#20027;&#38190;sno=1&#19978;&#24050;&#32463;&#26377;&#25490;&#20182;&#38145;&#65292;&#23545;&#20854;&#21152;&#20849;&#20139;&#38145;&#65292;&#24182;&#21152;&#20837;&#31561;&#24453;&#38431;&#21015;&#12290;</span>
</pre>
</div>

<p>
这时t2会阻塞在insert语句上。可以看到t1和t2插入的记录，它们在主键上是冲突的。如果t1提交，t2就会失败。如果t1回滚，t2就可以继续执行。唯一性检查使得t2对t1产生了一种动态的依赖关系。如果这时t1执行
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #FBDE2D;">insert</span> <span style="color: #FBDE2D;">into</span> my1 <span style="color: #FBDE2D;">values</span>(0); <span style="color: #AEAEAE; font-style: italic;">-- &#22312;&#20027;&#38190;sno=0&#19978;&#21152;&#25490;&#20182;&#38145;&#65292;&#35831;&#27714;&#22312;&#20027;&#38190;sno&#21306;&#38388;(0,1]&#19978;&#30340;&#25490;&#20182;&#38145;&#65292;&#21644;t2&#30340;&#20849;&#20139;&#38145;&#20914;&#31361;&#12290;</span>
</pre>
</div>
<p>
t2会立即报告死锁。为了避免幻读，在可重复读隔离级别下，在插入唯一索引k的时候，InnoDB会对k加排他锁，对k所在的区间(pk,nk]加排他next-key-lock锁。这里pk是小于k的键，nk是大于k的键。如果这时其他会话持有nk的共享锁或排他锁，InnoDB会报告错误。在例子中，t2已经持有了sno=1的共享锁，这和t1请求的next-key-lock冲突。如果把t1加入t2的等待队列，考虑到前面已经存在的t2对t1的依赖，就会产生循环依赖，进而导致死锁。从这里可以看出，插入导致死锁的主要原因是索引的唯一检查和next-key-lock锁。其实不只是插入，select for share和select for update也会产生next-lock-key，因此也有可能引发死锁。关于InnoDB锁模型可以在<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-transaction-model.html">文档</a>找到详细的说明。
</p>
</div>
</div>

<div id="outline-container-org6e36ce2" class="outline-3">
<h3 id="org6e36ce2">MySQL在并发删除同一行数据时导致死锁的分析</h3>
</div>

<div id="outline-container-org138e117" class="outline-3">
<h3 id="org138e117">参数SQL_SLAVE_SKIP_COUNTER的奥秘</h3>
</div>

<div id="outline-container-org3ecc4d8" class="outline-3">
<h3 id="org3ecc4d8">Binlog中的时间戳</h3>
</div>

<div id="outline-container-orgd285499" class="outline-3">
<h3 id="orgd285499">InnoDB中Rowid对Binlog的影响</h3>
<div class="outline-text-3" id="text-orgd285499">
<p>
InnoDB会自动为没有主键的表增加Rowid作为主键。Rowid是存储引擎层面的，binlog无法感知Rowid，因此在使用binlog进行复制时，如果使用Rowid作为主键，效果和没有主键是一样的。
</p>
</div>
</div>

<div id="outline-container-org77a5ab0" class="outline-3">
<h3 id="org77a5ab0">MySQL备份：Percona XtraBackup的原理与实践</h3>
<div class="outline-text-3" id="text-org77a5ab0">
<p>
TODO 试验
</p>
</div>
</div>
<div id="outline-container-org8d33b83" class="outline-3">
<h3 id="org8d33b83">MySQL分库分表</h3>
<div class="outline-text-3" id="text-org8d33b83">
<p>
MySQL拆分有两种做法：垂直拆分和水平拆分。垂直拆分是将库、表、列按照业务相关性、活跃程度 重新划分。水平拆分是将一张表中的记录分别保存到几个结构相同、规模更小的表中。在进程拆分时首先应该考虑垂直拆分。先按照业务相关性拆分，再按照数据读写频率拆分。如果垂直拆分之后，性能仍然难以满足要求，可以考虑水平拆分。
</p>
</div>
</div>

<div id="outline-container-org9c61541" class="outline-3">
<h3 id="org9c61541">MySQL数据安全</h3>
<div class="outline-text-3" id="text-org9c61541">
<p>
传统MySQL复制都是基于binlog的。参数sync_binlog可以控制事务提交时binlog是否刷写磁盘。这是一个整数，MySQL在sync_binlog次事务提交后刷写磁盘。如果设置为0，MySQL不会刷写binlog，而是让操作系统负责。
</p>
</div>
</div>


<div id="outline-container-org311c745" class="outline-3">
<h3 id="org311c745">MySQL性能拾遗</h3>
<div class="outline-text-3" id="text-org311c745">
<p>
InnoDB有一个后台进程Purge Thread清理页面中标记为删除的部分，这回形成页面空洞。空洞越大，IO越多，访问效率越低。使用命令
</p>
<div class="org-src-container">
<pre class="src src-sql">optimize <span style="color: #FBDE2D;">table</span> tbl;
</pre>
</div>
<p>
可以手动清理这些空洞。
</p>


<p>
MySQL的索引采用最左匹配原则。对于多列索引idx_a_b_c(a,b,c)，实际上相当于建立了3个索引(a)，(a,b)，(a,b,c)。根据最左匹配原则，字符串的like 'abc%'可以使用索引，而like '%abc'不行。如果JOIN的字段类型不一致，MySQL也不会使用索引。这里有一个容易忽视的地方，即联接字符集不同的两个列也无法使用索引。
</p>


<p>
下面介绍一些和性能相关的MySQL参数
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">参数</td>
<td class="org-left">说明</td>
</tr>

<tr>
<td class="org-left">general_log</td>
<td class="org-left">如果为ON，MySQL会记录一切提交，便于排查问题，但是性能较低。</td>
</tr>

<tr>
<td class="org-left">query_cache_size</td>
<td class="org-left">大部分情况下，SQL是动态拼接的，命中查询缓存的概率很低，因此通常可以关闭。</td>
</tr>

<tr>
<td class="org-left">sort_buffer_size</td>
<td class="org-left">在排序时如果无法使用索引，MySQL会在内部进行排序，这就用到了排序缓冲区。排序缓冲区是会话级别的。</td>
</tr>

<tr>
<td class="org-left">tmp_table_size</td>
<td class="org-left">执行group by或distinct时如果无法使用索引，MySQL会建立一个内部临时表。</td>
</tr>

<tr>
<td class="org-left">innodb_buffer_pool_size</td>
<td class="org-left">建立配置为物理内存的50%-75%。</td>
</tr>

<tr>
<td class="org-left">innodb_buffer_pool_instances</td>
<td class="org-left">当innodb_buffer_pool_size大于1GB时，该配置默认为8。</td>
</tr>

<tr>
<td class="org-left">innodb_log_file_size</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">innodb_log_files_in_group</td>
<td class="org-left">结合innodb_log_file_size可以控制REDO空间大小。REDO空间越大，性能越高，但需要更长的时间进行故障恢复。</td>
</tr>

<tr>
<td class="org-left">innodb_old_blocks_pct</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">innodb_old_blocks_time</td>
<td class="org-left">结合innodb_old_blocks_pct可以控制buffer pool中缓存声明周期。</td>
</tr>

<tr>
<td class="org-left">innodb_flush_method</td>
<td class="org-left">在UNIX系统上默认为fsync，在Windows上默认为async_unbuffered。使用SSD或PCIE时可以设置为O_DIRECT。</td>
</tr>

<tr>
<td class="org-left">innodb_doublewrite</td>
<td class="org-left">如果辅助存储设备支持原子写，可以关闭两次写。</td>
</tr>

<tr>
<td class="org-left">innodb_io_capacity</td>
<td class="org-left">后台进程刷写磁盘频率。</td>
</tr>

<tr>
<td class="org-left">innodb_thread_concurrency</td>
<td class="org-left">并发线程。</td>
</tr>

<tr>
<td class="org-left">innodb_flush_log_at_trx_commit</td>
<td class="org-left">InnoDB刷写磁盘方式。</td>
</tr>

<tr>
<td class="org-left">sync_binlog</td>
<td class="org-left">同步binlog到磁盘的方式。</td>
</tr>

<tr>
<td class="org-left">binlog_format</td>
<td class="org-left">从5.7.7开始默认为ROW。</td>
</tr>

<tr>
<td class="org-left">binlog_order_commits</td>
<td class="org-left">为了安全性，最好设置为ON。</td>
</tr>

<tr>
<td class="org-left">tx_isolation</td>
<td class="org-left">事务隔离级别。根据业务要求配置。</td>
</tr>

<tr>
<td class="org-left">slave_parallel_works</td>
<td class="org-left">并发复制线程数。</td>
</tr>
</tbody>
</table>


<p>
相比传统磁盘，SSD具有以下优点：
</p>
<ul class="org-ul">
<li>IOPS高。传统磁盘IOPS在200左右，SSD可以得到60万。</li>
<li>延迟低。传统磁盘单个IO延迟约为2000微秒，SSD不到100微秒。</li>
<li>功耗低。</li>
<li>容量大。企业级磁盘单个容量通常在4TB以下，而SSD可以达到12TB以上。</li>
<li>故障率低。</li>
<li>抗震能力强。</li>
<li>无噪音。</li>
<li>（部分SSD）支持原子写。</li>
</ul>
</div>
</div>

<div id="outline-container-orgd796d2b" class="outline-3">
<h3 id="orgd796d2b">MySQL Group Replication</h3>
<div class="outline-text-3" id="text-orgd796d2b">
<p>
MySQL Group Replication是随MySQL发布的一个插件，它提供了不同于异步复制和半同步复制的新的数据复制机制。Group Replication的一个核心概念是组，组指的是通过Group Replication连接到一起的若干个MySQL实例，这些实例叫做组的成员。组支持三种操作：创建组、添加成员、移除成员。第一个被添加的成员自动称为Master，后续成员自动从Master复制数据。Group Replication使用paxos算法保证数据的一致性。
</p>


<p>
一个组向外提供服务时可以选择单主模式或多主模式。在单主模式下，只有一个成员提供写数据服务，它叫做主成员。其他成员叫做辅助成员，只提供查询服务。主成员的UUID可以从任意成员中查到：
</p>
<div class="org-src-container">
<pre class="src src-sql">show <span style="color: #FBDE2D;">global</span> status <span style="color: #FBDE2D;">like</span> <span style="color: #61CE3C;">'group_replication_primary_member'</span>
<span style="color: #AEAEAE; font-style: italic;">-- or</span>
<span style="color: #FBDE2D;">select</span> * <span style="color: #FBDE2D;">from</span> performance_schema.global_status <span style="color: #FBDE2D;">where</span> variable_name=<span style="color: #61CE3C;">'group_replication_primary_member'</span>
</pre>
</div>

<p>
当成员加入组时，成员被自动设置为制度。如果主成员发生故障，组自动选择新的主成员。
</p>


<p>
在多主模式下，所有成员都可以写入和查询。这时要注意自增字段的设置。Group Replication提供了配置项
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #FBDE2D;">set</span> <span style="color: #FBDE2D;">global</span> group_replication_auto_increment_increment = N; <span style="color: #AEAEAE; font-style: italic;">-- default value: 7</span>
</pre>
</div>
<p>
同时，Group Replication会以server-id为自增字段的偏移量。自增的偏移量和增量也可以逐个成员手动设置：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #FBDE2D;">set</span> <span style="color: #FBDE2D;">global</span> auto_increment_offset=N;
<span style="color: #FBDE2D;">set</span> <span style="color: #FBDE2D;">global</span> auto_increment_increment=N;
</pre>
</div>

<p>
此外，多主模式还有以下限制：
</p>
<ul class="org-ul">
<li>不支持串行隔离级别。</li>
<li>不支持外键级联。</li>
</ul>

<p>
Group Replication提供了变量group_replication_enforce_update_everywhere_checks来开启对上述限制的检查。
</p>


<p>
默认情况下Group Replication使用单主模式。如果要使用多组模式，在将成员加入组之前需要关闭：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #FBDE2D;">set</span> <span style="color: #FBDE2D;">global</span> group_replication_single_primary_mode=<span style="color: #FBDE2D;">off</span>;
</pre>
</div>


<p>
Group Replication插件会启动一个通道（Channle）来接收Binlog event。通道的名字是group_replication_applier。可以手动关闭或开启通道：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #FBDE2D;">start</span> slave sql_thread <span style="color: #FBDE2D;">for</span> channel <span style="color: #61CE3C;">'group_replication_applier'</span>;
stop slave sql_thread <span style="color: #FBDE2D;">for</span> channel <span style="color: #61CE3C;">'group_replication_applier'</span>;
</pre>
</div>

<p>
Group Repliation也可以并行复制：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #FBDE2D;">set</span> <span style="color: #FBDE2D;">global</span> slave_parallel_type=<span style="color: #61CE3C;">'LOGICAL_CLOCK'</span>;
<span style="color: #FBDE2D;">set</span> <span style="color: #FBDE2D;">global</span> slave_parallel_workers = N;
<span style="color: #FBDE2D;">set</span> <span style="color: #FBDE2D;">global</span> slave_parallel_commit_order = <span style="color: #FBDE2D;">ON</span>;
</pre>
</div>


<p>
下面介绍如何搭建Group Replication。首先配置成员：
</p>
<div class="org-src-container">
<pre class="src src-ini">server_id = 1
log_bin = binlog
binlog_format = on
binlog_checksum = none
log_slave_updates = on
relay_log = relay-log

# 需要使用GTID
gtid_mode = on
enforce_gtid_consistency = on

# 多源复制要求将通道信息保存到系统表
master_info_repository = table
relay_log_info_repository = table

# 并发复制
slave_parallel_type = logical_clock
slave_parallel_workers = 4
slave_parallel_commit_order = on

# 采集主键信息
transaction_write_set_extraction = XXHASH64

# loose-前缀允许在加载插件之前配置。
loose-group_replication_group_name = USER_DEFINED_GROUP_NAME
# 用于Group Replication的地址，不同于MySQL服务地址。
loose-group_replication_local_address = IP:PORT
loose-group_replication_whitelist = &lt;IP,NET,...&gt;
</pre>
</div>

<p>
然后MySQL，安装插件。
</p>
<div class="org-src-container">
<pre class="src src-sql">install plugin group_replication SONAME <span style="color: #61CE3C;">'group_replication.so'</span>;
</pre>
</div>

<p>
如果实例是第一个成员，需要完成一些组初始化工作并启动Group Replication。
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #FBDE2D;">set</span> <span style="color: #FBDE2D;">global</span> group_replication_bootstrap_group = <span style="color: #FBDE2D;">on</span>;
<span style="color: #FBDE2D;">start</span> <span style="color: #FBDE2D;">group</span> replication;
<span style="color: #FBDE2D;">set</span> <span style="color: #FBDE2D;">global</span> group_replication_bootstrap_group = <span style="color: #FBDE2D;">off</span>;
</pre>
</div>

<p>
如果示例是新成员，首先需要从组内的其他成员复制数据，再启动Group Replication。
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #FBDE2D;">set</span> <span style="color: #FBDE2D;">global</span> group_replication_group_seeds = "127.0.0.1:20001";
change master <span style="color: #FBDE2D;">to</span> master_user=<span style="color: #61CE3C;">'rpl_user'</span>, master_password=<span style="color: #61CE3C;">'rpl_pass'</span> <span style="color: #FBDE2D;">for</span> channel <span style="color: #61CE3C;">'group_replication_recovery'</span>;
<span style="color: #FBDE2D;">start</span> <span style="color: #FBDE2D;">group</span> replication;
</pre>
</div>

<p>
一个组最多支持9个成员。只有两个成员时，组不具备冗余能力。Group Replication在维护数据时会创建账户_gr_user@loaclhost。Group Replication允许强制移除成员，但是这么做有脑裂的风险：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #FBDE2D;">set</span> <span style="color: #FBDE2D;">global</span> group_replication_force_members=&lt;ip:port,ip:port...&gt;
</pre>
</div>


<p>
Group Replication的信息存储在下列表中：
</p>
<ul class="org-ul">
<li>replication_group_members 组内成员信息</li>
<li>replication_group_member_stats 本地成员信息</li>
<li>replication_connection_status</li>
<li>replication_applier_status</li>
<li>threads</li>
</ul>

<p>
Group Replication插件的主要功能是binlog event分发，分发是在事务即将结束时进行的。这种方式叫做乐观事务执行策略。这种策略性能更好，但存在冲突的可能性。Group Replication插件会监控事务的提交。在before_commit阶段（before_commit在prepare之后，在将binlog写入磁盘之前），Group Replication插件将事务信息发送到组内各成员，等待投票结果。如果没有冲突，在收到结果后，事务继续提交。为了避免事务冲突，Group Replication记录了每个事务发生时的全局状态，即GTID。当收到一个新的事务同步请求时，Group Replication将这个事务当时的状态和本地状态向比较，如果两个状态不相容，说明事务发生冲突。如果是本地事务发生冲突，Group Replication回滚事务。如果是远程事务发生冲突，Group Replication直接丢弃收到的binlog event。随着事务数量的增加，内存中的GTID记录表也不断增加。Group Replication会启动全局认证模块，每60秒同步一次GTID，清理已经不再使用的记录。在应用binlog event时，Group Replication采用基于主键的并发机制。
</p>


<p>
在进行成员管理时，Group Replication使用了一个组视图的概念。组视图是组内成员的状态。每当成员状态发生变化，组视图也会随之改变，并被赋予一个新的编号。组视图的编号可以从performance_schema.replication_group_member_stats中找到。当新成员加入组的时候，成员首先会从group_replication_group_seeds中寻找一个种子成员，把加入请求发送给种子成员。种子成员把消息广播给组内的其他成员，这些成员开始进行视图切换。当所有成员都完成视图切换后，新成员正式加入到组内。新加入的成员还不能立即开始服务，需要完成数据恢复，以保证同其他成员的数据是一致的。新成员的数据恢复过程如下：如果这个实例曾经加入过组中，group_replication_applier的relay log可能还有一些binlog event没有执行。Group Replication插件会首先执行执行binlog。这个过程叫做本地恢复。接下来是全局恢复。Group Replication插件选择一个成员（叫做Donor），通过group_replication_recovery连接到Donor进行数据同步。如果在本地恢复和全局恢复的过程中如果收到了一些事务，这些事务也要被应用到新成员。这个步骤叫做缓存事务执行。缓存事务执行完毕后，成员设置为ONLINE状态，正式对外提供服务。
</p>


<p>
Group Replication是非常易用的，但不是万能的。如果Group Replication运行了很长时间，早前的binlog可能被删除了，这时无法通过全局恢复完成数据同步。同时如果binlog很大，全局恢复效率很低。这两种情况下都需要手动将数据同步到一个较为接近的状态，然后再通过Group Replication进行数据恢复。
</p>
</div>
</div>

<div id="outline-container-orgc018b53" class="outline-3">
<h3 id="orgc018b53">MySQL Document Store面面观</h3>
<div class="outline-text-3" id="text-orgc018b53">
<p>
从版本5.7.8开始，MySQL加入了对JSON的支持，增加了数据类型JSON和一些列相关的操作。下面就是一个例子：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #FBDE2D;">create</span> <span style="color: #FBDE2D;">table</span> <span style="color: #FF6400;">t1</span> (<span style="color: #FBDE2D;">data</span> JSON);

<span style="color: #FBDE2D;">insert</span> <span style="color: #FBDE2D;">into</span> t1 (<span style="color: #FBDE2D;">data</span>) <span style="color: #FBDE2D;">values</span> (<span style="color: #61CE3C;">'{"series":1}'</span>), (<span style="color: #61CE3C;">'{"series":2}'</span>), (<span style="color: #61CE3C;">'{"series":3}'</span>), (<span style="color: #61CE3C;">'{"series":4}'</span>), (<span style="color: #61CE3C;">'{"series":5}'</span>);
<span style="color: #FBDE2D;">select</span> * <span style="color: #FBDE2D;">from</span> t1 <span style="color: #FBDE2D;">where</span> json_extract(<span style="color: #FBDE2D;">data</span>, "$.series") &gt; 2;
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org4764ddf" class="outline-2">
<h2 id="org4764ddf">附录：MySQL 8.0.15 提供的系统表</h2>
<div class="outline-text-2" id="text-org4764ddf">
<blockquote>
<p>
sys.host_summary
sys.host_summary_by_file_io
sys.host_summary_by_file_io_type
sys.host_summary_by_stages
sys.host_summary_by_statement_latency
sys.host_summary_by_statement_type
sys.innodb_buffer_stats_by_schema
sys.innodb_buffer_stats_by_table
sys.innodb_lock_waits
sys.io_by_thread_by_latency
sys.io_global_by_file_by_bytes
sys.io_global_by_file_by_latency
sys.io_global_by_wait_by_bytes
sys.io_global_by_wait_by_latency
sys.latest_file_io
sys.memory_by_host_by_current_bytes
sys.memory_by_thread_by_current_bytes
sys.memory_by_user_by_current_bytes
sys.memory_global_by_current_bytes
sys.memory_global_total
sys.metrics
sys.processlist
sys.ps_check_lost_instrumentation
sys.schema_auto_increment_columns
sys.schema_index_statistics
sys.schema_object_overview
sys.schema_redundant_indexes
sys.schema_table_lock_waits
sys.schema_table_statistics
sys.schema_table_statistics_with_buffer
sys.schema_tables_with_full_table_scans
sys.schema_unused_indexes
sys.session
sys.session_ssl_status
sys.statement_analysis
sys.statements_with_errors_or_warnings
sys.statements_with_full_table_scans
sys.statements_with_runtimes_in_95th_percentile
sys.statements_with_sorting
sys.statements_with_temp_tables
sys.sys_config
sys.user_summary
sys.user_summary_by_file_io
sys.user_summary_by_file_io_type
sys.user_summary_by_stages
sys.user_summary_by_statement_latency
sys.user_summary_by_statement_type
sys.version
sys.wait_classes_global_by_avg_latency
sys.wait_classes_global_by_latency
sys.waits_by_host_by_latency
sys.waits_by_user_by_latency
sys.waits_global_by_latency
sys.x$host_summary
sys.x$host_summary_by_file_io
sys.x$host_summary_by_file_io_type
sys.x$host_summary_by_stages
sys.x$host_summary_by_statement_latency
sys.x$host_summary_by_statement_type
sys.x$innodb_buffer_stats_by_schema
sys.x$innodb_buffer_stats_by_table
sys.x$innodb_lock_waits
sys.x$io_by_thread_by_latency
sys.x$io_global_by_file_by_bytes
sys.x$io_global_by_file_by_latency
sys.x$io_global_by_wait_by_bytes
sys.x$io_global_by_wait_by_latency
sys.x$latest_file_io
sys.x$memory_by_host_by_current_bytes
sys.x$memory_by_thread_by_current_bytes
sys.x$memory_by_user_by_current_bytes
sys.x$memory_global_by_current_bytes
sys.x$memory_global_total
sys.x$processlist
sys.x$ps_digest_95th_percentile_by_avg_us
sys.x$ps_digest_avg_latency_distribution
sys.x$ps_schema_table_statistics_io
sys.x$schema_flattened_keys
sys.x$schema_index_statistics
sys.x$schema_table_lock_waits
sys.x$schema_table_statistics
sys.x$schema_table_statistics_with_buffer
sys.x$schema_tables_with_full_table_scans
sys.x$session
sys.x$statement_analysis
sys.x$statements_with_errors_or_warnings
sys.x$statements_with_full_table_scans
sys.x$statements_with_runtimes_in_95th_percentile
sys.x$statements_with_sorting
sys.x$statements_with_temp_tables
sys.x$user_summary
sys.x$user_summary_by_file_io
sys.x$user_summary_by_file_io_type
sys.x$user_summary_by_stages
sys.x$user_summary_by_statement_latency
sys.x$user_summary_by_statement_type
sys.x$wait_classes_global_by_avg_latency
sys.x$wait_classes_global_by_latency
sys.x$waits_by_host_by_latency
sys.x$waits_by_user_by_latency
sys.x$waits_global_by_latency
information_schema.CHARACTER_SETS
information_schema.COLLATION_CHARACTER_SET_APPLICABILITY
information_schema.COLLATIONS
information_schema.COLUMN_PRIVILEGES
information_schema.COLUMN_STATISTICS
information_schema.COLUMNS
information_schema.ENGINES
information_schema.EVENTS
information_schema.FILES
information_schema.INNODB_BUFFER_PAGE
information_schema.INNODB_BUFFER_PAGE_LRU
information_schema.INNODB_BUFFER_POOL_STATS
information_schema.INNODB_CACHED_INDEXES
information_schema.INNODB_CMP
information_schema.INNODB_CMP_PER_INDEX
information_schema.INNODB_CMP_PER_INDEX_RESET
information_schema.INNODB_CMP_RESET
information_schema.INNODB_CMPMEM
information_schema.INNODB_CMPMEM_RESET
information_schema.INNODB_COLUMNS
information_schema.INNODB_DATAFILES
information_schema.INNODB_FIELDS
information_schema.INNODB_FOREIGN
information_schema.INNODB_FOREIGN_COLS
information_schema.INNODB_FT_BEING_DELETED
information_schema.INNODB_FT_CONFIG
information_schema.INNODB_FT_DEFAULT_STOPWORD
information_schema.INNODB_FT_DELETED
information_schema.INNODB_FT_INDEX_CACHE
information_schema.INNODB_FT_INDEX_TABLE
information_schema.INNODB_INDEXES
information_schema.INNODB_METRICS
information_schema.INNODB_SESSION_TEMP_TABLESPACES
information_schema.INNODB_TABLES
information_schema.INNODB_TABLESPACES
information_schema.INNODB_TABLESPACES_BRIEF
information_schema.INNODB_TABLESTATS
information_schema.INNODB_TEMP_TABLE_INFO
information_schema.INNODB_TRX
information_schema.INNODB_VIRTUAL
information_schema.KEY_COLUMN_USAGE
information_schema.KEYWORDS
information_schema.OPTIMIZER_TRACE
information_schema.PARAMETERS
information_schema.PARTITIONS
information_schema.PLUGINS
information_schema.PROCESSLIST
information_schema.PROFILING
information_schema.REFERENTIAL_CONSTRAINTS
information_schema.RESOURCE_GROUPS
information_schema.ROUTINES
information_schema.SCHEMA_PRIVILEGES
information_schema.SCHEMATA
information_schema.ST_GEOMETRY_COLUMNS
information_schema.ST_SPATIAL_REFERENCE_SYSTEMS
information_schema.ST_UNITS_OF_MEASURE
information_schema.STATISTICS
information_schema.TABLE_CONSTRAINTS
information_schema.TABLE_PRIVILEGES
information_schema.TABLES
information_schema.TABLESPACES
information_schema.TRIGGERS
information_schema.USER_PRIVILEGES
information_schema.VIEW_ROUTINE_USAGE
information_schema.VIEW_TABLE_USAGE
information_schema.VIEWS
performance_schema.accounts
performance_schema.cond_instances
performance_schema.data_lock_waits
performance_schema.data_locks
performance_schema.events_errors_summary_by_account_by_error
performance_schema.events_errors_summary_by_host_by_error
performance_schema.events_errors_summary_by_thread_by_error
performance_schema.events_errors_summary_by_user_by_error
performance_schema.events_errors_summary_global_by_error
performance_schema.events_stages_current
performance_schema.events_stages_history
performance_schema.events_stages_history_long
performance_schema.events_stages_summary_by_account_by_event_name
performance_schema.events_stages_summary_by_host_by_event_name
performance_schema.events_stages_summary_by_thread_by_event_name
performance_schema.events_stages_summary_by_user_by_event_name
performance_schema.events_stages_summary_global_by_event_name
performance_schema.events_statements_current
performance_schema.events_statements_histogram_by_digest
performance_schema.events_statements_histogram_global
performance_schema.events_statements_history
performance_schema.events_statements_history_long
performance_schema.events_statements_summary_by_account_by_event_name
performance_schema.events_statements_summary_by_digest
performance_schema.events_statements_summary_by_host_by_event_name
performance_schema.events_statements_summary_by_program
performance_schema.events_statements_summary_by_thread_by_event_name
performance_schema.events_statements_summary_by_user_by_event_name
performance_schema.events_statements_summary_global_by_event_name
performance_schema.events_transactions_current
performance_schema.events_transactions_history
performance_schema.events_transactions_history_long
performance_schema.events_transactions_summary_by_account_by_event_name
performance_schema.events_transactions_summary_by_host_by_event_name
performance_schema.events_transactions_summary_by_thread_by_event_name
performance_schema.events_transactions_summary_by_user_by_event_name
performance_schema.events_transactions_summary_global_by_event_name
performance_schema.events_waits_current
performance_schema.events_waits_history
performance_schema.events_waits_history_long
performance_schema.events_waits_summary_by_account_by_event_name
performance_schema.events_waits_summary_by_host_by_event_name
performance_schema.events_waits_summary_by_instance
performance_schema.events_waits_summary_by_thread_by_event_name
performance_schema.events_waits_summary_by_user_by_event_name
performance_schema.events_waits_summary_global_by_event_name
performance_schema.file_instances
performance_schema.file_summary_by_event_name
performance_schema.file_summary_by_instance
performance_schema.global_status
performance_schema.global_variables
performance_schema.host_cache
performance_schema.hosts
performance_schema.log_status
performance_schema.memory_summary_by_account_by_event_name
performance_schema.memory_summary_by_host_by_event_name
performance_schema.memory_summary_by_thread_by_event_name
performance_schema.memory_summary_by_user_by_event_name
performance_schema.memory_summary_global_by_event_name
performance_schema.metadata_locks
performance_schema.mutex_instances
performance_schema.objects_summary_global_by_type
performance_schema.performance_timers
performance_schema.persisted_variables
performance_schema.prepared_statements_instances
performance_schema.replication_applier_configuration
performance_schema.replication_applier_filters
performance_schema.replication_applier_global_filters
performance_schema.replication_applier_status
performance_schema.replication_applier_status_by_coordinator
performance_schema.replication_applier_status_by_worker
performance_schema.replication_connection_configuration
performance_schema.replication_connection_status
performance_schema.replication_group_member_stats
performance_schema.replication_group_members
performance_schema.rwlock_instances
performance_schema.session_account_connect_attrs
performance_schema.session_connect_attrs
performance_schema.session_status
performance_schema.session_variables
performance_schema.setup_actors
performance_schema.setup_consumers
performance_schema.setup_instruments
performance_schema.setup_objects
performance_schema.setup_threads
performance_schema.socket_instances
performance_schema.socket_summary_by_event_name
performance_schema.socket_summary_by_instance
performance_schema.status_by_account
performance_schema.status_by_host
performance_schema.status_by_thread
performance_schema.status_by_user
performance_schema.table_handles
performance_schema.table_io_waits_summary_by_index_usage
performance_schema.table_io_waits_summary_by_table
performance_schema.table_lock_waits_summary_by_table
performance_schema.threads
performance_schema.user_defined_functions
performance_schema.user_variables_by_thread
performance_schema.users
performance_schema.variables_by_thread
performance_schema.variables_info
</p>
</blockquote>
</div>
</div>
<div id="outline-container-orge12c1cd" class="outline-2">
<h2 id="orge12c1cd">附录：参考资料</h2>
<div class="outline-text-2" id="text-orge12c1cd">
<p>
<a href="http://mysql.taobao.org/monthly/">http://mysql.taobao.org/monthly/</a>
</p>
</div>
</div>
<div id="outline-container-org975ab0e" class="outline-2">
<h2 id="org975ab0e">试验</h2>
<div class="outline-text-2" id="text-org975ab0e">
</div>
<div id="outline-container-org45863e1" class="outline-3">
<h3 id="org45863e1">在Windows上编译MySQL</h3>
</div>
<div id="outline-container-org0218338" class="outline-3">
<h3 id="org0218338">在Linux上编译MySQL</h3>
</div>
<div id="outline-container-org04fad78" class="outline-3">
<h3 id="org04fad78">Master-Slave</h3>
</div>
<div id="outline-container-org0fe8fcb" class="outline-3">
<h3 id="org0fe8fcb">Master-Master</h3>
</div>
<div id="outline-container-org998e33c" class="outline-3">
<h3 id="org998e33c">搭建Group Replication集群</h3>
</div>
<div id="outline-container-orga6dba09" class="outline-3">
<h3 id="orga6dba09">编写MySQL插件</h3>
</div>
<div id="outline-container-org4de2e2f" class="outline-3">
<h3 id="org4de2e2f">搭建PXC集群</h3>
</div>
<div id="outline-container-orgb768789" class="outline-3">
<h3 id="orgb768789">手动同步数据库</h3>
</div>
<div id="outline-container-org6966809" class="outline-3">
<h3 id="org6966809">使用sysbench进行测试</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2019年09月30日</p>
<p class="date">Created: 2019-10-28 周一 19:45</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-10-28 周一 19:45 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>算法导论笔记</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">算法导论笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org220e988">第一部分 基础知识</a>
<ul>
<li><a href="#org1724e40">第一章 算法在计算中的作用</a></li>
<li><a href="#orgfcdfc8c">第二章 算法入门</a></li>
<li><a href="#org0779fa9">第三章 函数的增长</a></li>
<li><a href="#org31b0f9b">第四章 递归式</a></li>
<li><a href="#org5a567d6">第五章 概率分析和随机算法</a></li>
</ul>
</li>
<li><a href="#org55f9c9a">第二部分 排序和顺序统计学</a>
<ul>
<li><a href="#orgafeed4f">第六章 堆排序</a></li>
<li><a href="#org0d76cb3">第七章 快速排序</a></li>
<li><a href="#orgb77e664">第八章 线性时间排序</a></li>
<li><a href="#orgf067d67">第九章 中位数和顺序统计学</a></li>
</ul>
</li>
<li><a href="#org909df6f">第三部分 数据结构</a>
<ul>
<li><a href="#org65bc6da">第十章 基本数据结构</a></li>
<li><a href="#org25e9e4f">第十一章 散列表</a></li>
<li><a href="#orgb3235cf">第十二章 二叉查找树</a></li>
<li><a href="#orgc5c5453">第十三章 红黑树</a></li>
<li><a href="#org13971c5">第十四章 数据结构的扩张</a></li>
</ul>
</li>
<li><a href="#orgca36da5">第四部分 高级设计和分析技术</a>
<ul>
<li><a href="#org613537d">第十五章 动态规划</a></li>
<li><a href="#orga05d2ba">第十六章 贪心算法</a></li>
<li><a href="#org61dcc7c">第十七章 平摊分析</a></li>
</ul>
</li>
<li><a href="#orgb2c4417">第五部分 高级数据结构</a>
<ul>
<li><a href="#org944e61e">第十八章 B树</a></li>
<li><a href="#orgd7679b9">第十九章 二项堆</a></li>
</ul>
</li>
<li><a href="#org2ee23b9">第六部分 图算法</a>
<ul>
<li><a href="#org151ffc7">第二十二章 图的基本算法</a></li>
<li><a href="#org640fa8b">第二十三章 最小生成树</a></li>
<li><a href="#org071cf07">第二十四章 单源最短路径</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org220e988" class="outline-2">
<h2 id="org220e988">第一部分 基础知识</h2>
<div class="outline-text-2" id="text-org220e988">
</div>
<div id="outline-container-org1724e40" class="outline-3">
<h3 id="org1724e40">第一章 算法在计算中的作用</h3>
<div class="outline-text-3" id="text-org1724e40">
<p>
算法是定义良好的计算步骤。如果一个算法对每输入实例都可以产生正确的输出，这个算法就是正确的。
</p>
</div>
</div>


<div id="outline-container-orgfcdfc8c" class="outline-3">
<h3 id="orgfcdfc8c">第二章 算法入门</h3>
<div class="outline-text-3" id="text-orgfcdfc8c">
<p>
排序算法的输入是n个数 \(a_1, a_2, \ldots a_n\) ，这些数也叫做键。排序算法产生键的一个排列 \(a'_1, a'_2, \ldots, a'_n\) ，使得 \(a'_1 \le a'_2 \le \ldots \le a'_n\) 。插入排序算法采用的策略是，将键分为已排序集和未排序集两部分，每次从未排序集取出一个键插入到已排序集。当未排序集变成空集时，排序就完成了。下面是插入排序代码：
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">insert_sort</span>(<span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">array</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">length</span>) {
        <span style="color: #FBDE2D;">for</span> (<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">i</span> = 1; i &lt; length; i++) {
                <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">key</span> = array[i];
                <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">j</span>;
                <span style="color: #FBDE2D;">for</span> (j = i - 1; j &gt;= 0; j--) {
                        <span style="color: #FBDE2D;">if</span> (key &gt;= array[j]) {
                                <span style="color: #FBDE2D;">break</span>;
                        }

                        array[j + 1] = array[j];
                }
                array[j + 1] = key;
        }
}  
</pre>
</div>

<p>
对于包含循环或迭代的算法，证明这类算法准确性的一个常用工具是循环不变量。循环不变量是在循环开始前、循环进行中和循环结束后都不变的条件。以上面的插入排序代码为例，在外层的i循环中，在每次循环前数组array[0..(i-1)]是有序的，这个不变性保证了算法的准确。
</p>


<p>
在分析算法时，通常采用拥有单处理器的随机存取机（random-access machine，RAM）模型。RAM模型只有一个处理器，指令依次执行，没有并发操作。RAM模型包含真实的常见指令，如算术指令、数据移动指令、控制指令等，并假定每条指令的执行时间是1个单位。RAM没有对存储层次（高速缓存、内存、磁盘）进行建模，如果包含了存储层次，模型将变得过于复杂而难以应用。算法执行的时间，就是算法在RAM上执行的指令数，也叫做算法的时间复杂度。算法执行的时间通常和输入规模有关，因此时间复杂度表示为输入规模 \(n\) 的函数，通常用 \(T(n)\) 标记。
</p>


<p>
即使对于同样的输入规模，在不同的输入实例下，算法消耗的时间也是不一样的。因此时间复杂度也分为最好情况，最坏情况和平均情况。通常我们更关心最坏情况，原因如下：
</p>

<ul class="org-ul">
<li>最坏情况给出了算法耗时的界限。</li>
<li>对于很多算法，最坏情况出现的概率并不低。</li>
<li>很多算法的“平均情况”实际上和最坏情况差不多。</li>
</ul>

<p>
但是对于随机化算法，平均情况也需要重视。插入排序的时间复杂度是 \(\Theta(n)\) 。
</p>



<p>
选择排序是另一种排序算法。选择排序步骤如下，首先选择数组array[0..(n-1)]中的最小值，将它和array[0]交换。接着找出array[1..(n-1)]的最小值，和array[1]交换。以此类推。下面是选择排序的代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">selection_sort</span>(<span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">array</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">length</span>) {
        <span style="color: #FBDE2D;">for</span> (<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">i</span> = 0; i &lt; length - 1; i++) {
                <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">min_index</span> = i;
                <span style="color: #FBDE2D;">for</span> (<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">j</span> = i + 1; j &lt; length; j++) {
                        <span style="color: #FBDE2D;">if</span> (array[j] &lt; array[min_index]) {
                                min_index = j;
                        }
                }

                <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">tmp</span> = array[i];
                array[i] = array[min_index];
                array[min_index] = tmp;
        }
}
</pre>
</div>

<p>
选择排序的时间复杂度也是 \(\Theta(n)\) 。
</p>


<p>
插入排序和选择排序采用的是增量策略，每次向已排序集添加一个元素。还有一些算法采用分治策略，将问题划分为若干个小规模的子问题，求解子问题，然后将子问题的解归并，得到原问题的解。分治策略通常分为三步：
</p>
<ul class="org-ul">
<li>分治。将原问题分解为子问题。</li>
<li>解决。递归的求解子问题。如果子问题足够小，直接求解。</li>
<li>合并。将子问题的解合并组成原问题的解。</li>
</ul>

<p>
归并排序就是这么做的。下面是归并排序的代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">merge</span>(<span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">array</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">middle</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">length</span>) {
        <span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">buffer</span> = (<span style="color: #8DA6CE;">int</span> *) malloc(<span style="color: #FBDE2D;">sizeof</span>(<span style="color: #8DA6CE;">int</span>) * length);
        <span style="color: #FBDE2D;">if</span> (buffer == <span style="color: #D8FA3C;">NULL</span>) {
                abort();
        }

        memcpy(buffer, array, <span style="color: #FBDE2D;">sizeof</span>(<span style="color: #8DA6CE;">int</span>) * length);
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">i</span> = 0;
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">j</span> = middle;
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">p</span> = 0;

        <span style="color: #FBDE2D;">while</span> (i &lt; middle &amp;&amp; j &lt; length) {
                <span style="color: #FBDE2D;">if</span> (buffer[i] &lt; buffer[j]) {
                        array[p++] = buffer[i++];
                } <span style="color: #FBDE2D;">else</span> {
                        array[p++] = buffer[j++];
                }
        }

        <span style="color: #FBDE2D;">while</span> (i &lt; middle) {
                array[p++] = buffer[i++];
        }

        <span style="color: #FBDE2D;">while</span> (j &lt; length) {
                array[p++] = buffer[j++];
        }

        free(buffer);
}

<span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">merge_sort</span>(<span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">array</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">length</span>) {
        <span style="color: #FBDE2D;">if</span> (length &lt;= 1) {
                <span style="color: #FBDE2D;">return</span>;
        }

        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">middle</span> = length / 2;
        merge_sort(array, middle);
        merge_sort(array + middle, length - middle);
        merge(array, middle, length);
}
</pre>
</div>


<p>
假设一个分治算法将原问题分解为 \(a\) 个子问题，每个子问题的规模是原问题规模的 \(\frac{1}{b}\) 。我们用 \(T(n)\) 表示算法的时间复杂度，那么有
\[
T(n) = \Theta(1), if n \le c 
\]
</p>

<p>
\[
T(n) = aT(\frac{n}{b}) + D(n) + C(n), otherwise
\]
</p>


<p>
冒泡排序是选择排序的一个变种。冒泡排序的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">bubble_sort</span>(<span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">array</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">length</span>) {
        <span style="color: #FBDE2D;">for</span> (<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">i</span> = 0; i &lt; length; i++) {
                <span style="color: #FBDE2D;">for</span> (<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">j</span> = length - 1; j &gt; i; j--) {
                        <span style="color: #FBDE2D;">if</span> (array[j - 1] &gt; array[j]) {
                                <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">tmp</span> = array[j - 1];
                                array[j - 1] = array[j];
                                array[j] = tmp;
                        }
                }
        }
}
</pre>
</div>


<p>
霍纳法则是计算多项式的一种方法。霍纳法则的公式是：
\[
P(x) = \sum_{k=0}^na_kx^k = a_0 + x(a_1 + x(a_2 + \cdots + x(a_{n-1} + xa_n) \cdots ))
\]
</p>
</div>
</div>

<div id="outline-container-org0779fa9" class="outline-3">
<h3 id="org0779fa9">第三章 函数的增长</h3>
<div class="outline-text-3" id="text-org0779fa9">
<p>
对于一个函数 \(g(n)\) ，我们用 \(\Theta(n)\) 表示当 \(n\) 增大时，值与 \(g(n)\) 接近的函数集合。具体定义如下
\[
\Theta(g(n)) = \{ f(n) \mid \exists c_1, c_2, n_0, \forall n \ge n_0: c_1g(n) \le f(n) \le c_2g(n) \}
\]
</p>

<p>
如果 \(f(n) \in \Theta(g(n))\) ，我们就说 \(g(n)\) 是的 \(f(n)\) 的渐进确界。 \(\Theta(1)\) 表示常数。
</p>


<p>
和 \(\Theta(n)\) 类似的还有 \(O(n)\) 和 \(\Sigma(n)\) ，分别表示函数的渐进上界和渐进下界：
\[
O(g(n)) = \{ f(n) \mid \exists c, n_0, \forall n > n_0 : 0 \le f(n) \le cg(n) \}
\]
</p>

<p>
\[
\Omega(g(n)) = \{ f(n) \mid  \exists c, n_0, \forall n > n_0 : 0 \le cg(n) \le f(n) \}
\]
</p>

<p>
此外还有两个不太常用的符号：
\[
o(g(n)) = \{ f(n) \mid  \exists n_0, \forall c > 0, n > n_0 : 0 \le f(n) \le cg(n) \}
\]
</p>

<p>
\[
\omega(g(n)) = \{ f(n) \mid  \exists n_0, \forall c > 0, n > n_0 : 0 \le cg(n) \le f(n) \}
\]
</p>

<p>
取模运算定义为：
\[
a \equiv n = a - \lfloor \frac{a}{n} \rfloor n
\]
</p>

<p>
如果 \(a \equiv n\) 等于 \(b \equiv n\) ，则称 \(a\) 和 \(b\) 模 \(n\) 同余，记为 \(a \equiv b (mod n)\) 。
</p>


<p>
斐波那契数列定义为：
\[
F_0 = 0, F_1 = 1, F_i = F_{i-1} + F_{i-2}
\]
</p>


<p>
\[
\phi = \frac{1 + \sqrt{5}}{2}
\]
</p>

<p>
\[
\hat{\phi} = \frac{1 - \sqrt{5}}{2}
\]
</p>

<p>
\[
F_i = \frac{\phi^i - \hat{\phi}^i}{\sqrt{5}}
\]
</p>


<p>
斯特林公式
\[
n! = \sqrt{2 \pi n} \frac{n}{e}^2 e^{a_n}, \frac{1}{12n+1} \le a_n \le \frac{1}{12n}
\]
</p>
</div>
</div>


<div id="outline-container-org31b0f9b" class="outline-3">
<h3 id="org31b0f9b">第四章 递归式</h3>
<div class="outline-text-3" id="text-org31b0f9b">
<p>
计算一个递归式的渐进界限有三种方法：代换法、递归树法和主方法。代换法首先猜测解的形式，然后代入递归式，用归纳法证实。以 \(T(n) = 2T(\frac{n}{2}) + n\) 为例。我们猜测 \(T(n) = O(nlgn)\) 。要使猜测成立，需要满足 \(\exists c >0: T(n) \le cnlgn\) 。假设这个条件对 \(\frac{n}{2}\) 成立，即 \(T(\frac{n}{2}) \le c(\frac{n}{2})lg(\frac{n}{2})\) 。对递归式进行替换，得到
\[
T(n) \le 2 c\frac{n}{2} lg(\frac{n}{2}) + n
\]
</p>

<p>
\[
T(n) \le cnlgn
\]
</p>

<p>
到这里工作并没有完成，我们还必须证明在边界条件下等式成立，也就是要找到一个 \(c\) ，当 \(n=1\) （或n较小）时成立。当 \(n=2\) 或 \(n=3\) 时，只要 \(c \ge 2\) ，\(T(n) \le cnlgn\) 总是成立。因此对于递归式 \(T(n) = 2T(\frac{n}{2}) + n\) 有 \(T(n) \le cnlgn\) 。使用代入法必须避免陷阱。对于这个例子，如果假设 \(T(n) = O(n)\) ，代入后看起来是成立的。这个错误在于没有证明假设 \(T(n) \le cn\) 是成立的。
</p>


<p>
代换法需要一个好的猜想，递归树方法可以帮助我们找到猜想。在递归树中，一棵子树所有节点之和就是子树代表的递归调用所消耗的时间。一开始递归树只有一个根节点的 \(T(n)\) 。通过不断将递归式的右边代入叶节点，逐渐扩展递归树。我们以 \(T(n) = 3T(\frac{n}{4}) + cn\) 为例。为了简化计算，我们假定n是4的方幂。一开始，递归树只有一个根节点 \(T(n)\) 。接着用递归式对叶节点展开，根节点增加了3个子 \(T(\frac{n}{4})\) 节点，并且根节点的值变为 \(cn\) 。然后继续对叶节点展开，直到叶节点比变成 \(T(1)\) 。当子节点扩展到 \(T(1)\) 时，递归式已经被完全展开了，将递归树的所有节点相加，就得到了 \(T(n)\) 。
</p>


<p>
主方法给出了递归式 \(T(n) = aT(\frac{n}{b}) + f(n)\) 的一般解。主方法要求 \(a \ge 1\) 和 \(b > 1\) ，并且 \(f(n)\) 在渐进情况下是正值函数。当这些条件满足时， \(T(n)\) 的解可以分为三种情况。如果 \(\exists \epsilon > 0: f(n) = O(n^{log_ba - \epsilon})\) ，则 \(T(n) = \Theta(n^{log_ba})\) 。如果 \(f(n) = \Theta(n^{log_ba})\) ，则 \(T(n) = \Theta(n^{log_ba}lgn)\) 。如果 \(\exists \epsilon > 0: f(n)=\Omega(n^{log_ba+\epsilon})\) ，并且 \(\exists c < 1, n_0, \forall n > n_0: af(\frac{n}{b}) \le cf(n)\) ，则 \(T(n) = \Theta(f(n))\) 。
</p>


<p>
现在我们来证明主定理对 \(b\) 的方幂成立。假设 \(a \ge 1, b > 1\) 是常数， \(f(n)\) 在 \({b^k \mid k \in Z}\) 上有定义， \(T(n)\) 定义为
</p>

<p>
\[
T(n) = aT(\frac{n}{b}) + f(n), n = b^i
\]
</p>

<p>
\[
T(n) = \Theta(1), n = 1
\]
</p>

<p>
根据递归树我们可以知道：
\[
T(n) = \Theta(n^{log_ba}) + \sum_{j=0}^{log_bn-1}a^jf(\frac{n}{b^j})
\]
</p>

<p>
我们将和的右边定义为函数 \(g(n)\) ：
\[
g(n) = \sum_{j=0}^{log_bn-1}a^jf(\frac{n}{b^j})
\]
</p>

<p>
下面我们证明：
</p>
<ul class="org-ul">
<li>如果 \(\exists \epsilon > 0: f(n) = O(n^{log_ba - \epsilon}\) ，则 \(g(n) = O(n^{log_ba})\) 。</li>
<li>如果 \(f(n) = \Theta(n^{log_ba})\) ，则 \(g(n) = \Theta(n^{log_ba}lgn)\) 。</li>
<li>如果 \(\exists c > 0 \forall n \ge b: af(\frac{n}{b}) \le cf(n)\) ，则 \(g(n) = \Theta(f(n))\) 。</li>
</ul>

<p>
首先看第一种情况。令 \(p = log_ba - \epsilon, k = log_bn-1\) ，将 \(f(n)\) 代入 \(g(n)\) 得到：
\[
g(n) = O(\sum_{j=0}^ka^j(\frac{n}{b^j})^p)
\]
</p>

<p>
由
\[
b^p = b^{log_ba - \epsilon} = \frac{b^log_ba}{b^\epsilon} = \frac{a}{b^\epsilon}
\]
</p>

<p>
可知
\[
\sum_{j=0}^ka^j(\frac{n}{b^j})^p = n^p\sum_{j=0}^k\frac{a}{b^p}^j = n^p\sum_{j=0}^kb^{\epsilon j} = n^p\frac{b^{\epsilon (k+1)} - 1}{b^\epsilon - 1}
\]
</p>

<p>
由
\[
b^{\epsilon (k+1)} = b^{\epsilon log_bn} = n^\epsilon
\]
可知
\[
g(n) = n^p\frac{n^\epsilon - 1}{b^\epsilon - 1}
\]
</p>

<p>
由于 \(b\) 和 \(\epsilon\) 是常数，因此
\[
O(g(n)) = O(n^p O(n^\epsilon)) = O(n^{log_ba - \epsilon} O(n^\epsilon)) = O(n^{logb_a})
\]
</p>

<p>
第二种情况也可以用类似的方法证明。下面我们来看第三种情况。由于 \(af(\frac{n}{b}) \le cf(n)\) ，因此 
\[
f(\frac{n}{b}) \le \frac{c}{a}f(n)
\]
</p>

<p>
\[
f(\frac{n}{b^k}) \le (\frac{c}{a})^kf(n)
\]
</p>

<p>
将上式代入 \(g(n)\) 有：
\[
g(n) = \sum_{j=0}^ka^jf(\frac{n}{b^j}) = \sum_{j=0}^ka^j(\frac{c}{a})^jf(n) = f(n)\sum_{j=0}^kc^j
\]
</p>

<p>
从这里我们就可以知道，为什么要求 \(c < 1\) 了。到这里就证明了第一部分，即对 \(b\) 的方幂而言，主定理成立。
</p>


<p>
主定理存在一些扩展。如果 \(f(n) = \Theta(n^{log_ba}lg^kn), k \ge 0\) ，则 \(T(n) = \Theta(n^{log_ba}lg^{k+1}n)\) 。
</p>


<p>
对于递归式的计算规则，有一个更一般化的公式。假设 \(k \ge 1, a_i > 0, \suma_i \ge 1, b_i \ge 2\) ,假设 \(f(n)\) 是正的函数，有界且非递减，假设 \(\exists c > 0, n_0, d > 0, \forall n \ge n_0: f(\frac{n}{c}) \ge df(n)\) ，则递归式
\[
T(n) = \sum_{i=1}^ka_iT(\lfloor\frac{n}{b_i}\rfloor) + f(n)
\]
的解为
\[
T(n) = \Theta(n^p) + \Theta(n^p \int_{n'}^n \frac{f(x)}{x^{p+1}} dx)
\]
</p>

<p>
其中 \(n'\) 是一个足够大的常数， \(p\) 是满足 \(\sum_{i=1}^pa_ib_i^{-p} = 1\) 的值。这样的值是唯一存在的。
</p>
</div>
</div>


<div id="outline-container-org5a567d6" class="outline-3">
<h3 id="org5a567d6">第五章 概率分析和随机算法</h3>
<div class="outline-text-3" id="text-org5a567d6">
<p>
如果一个算法的行为不仅由输入决定，还和一个随机数生成器有关，这个算法就称为是随机算法。在分析随机算法时，通常需要使用指示器随机变量。对于事件A，指示器随机变量的定义为：
\[
I\{A\} = 1, 如果A发生
\]
</p>

<p>
\[
I\{A\} = 0, 如果A不发生
\]
</p>

<p>
根据指示器随机变量的定义可以知道，对于 \(X_A=I\{A\}\) 有 \(E[X_A]=Pr\{A\}\) 。
</p>


<p>
下面我们用一个例子来学习如何分析随机算法。这个例子叫做雇佣问题。问题的描述如下：
</p>

<blockquote>
<p>
你打算雇佣一名助理。你找到一名代理人，让他每天为你推荐一名候选人。收到推荐后，你会进行面试，并支付给代理人一笔小费。你决定，在任何时候，总是要聘请最好的候选人。当然，一旦你决定雇佣候选人，你需要支付更多的费用。
</p>
</blockquote>


<p>
雇佣问题的伪代码如下：
</p>
<div class="org-src-container">
<pre class="src src-text">HIRE-ASSISTANT(N)
1 best &lt;- 0
2 for i &lt;- 1 to n
3     do interview candidate i
4         if candidate i is better than candidate best
5             then best &lt;- i
6                 hire candidate i
</pre>
</div>

<p>
假设面试的费用是 \(c_i\) ，雇佣的费用是 \(c_h\) 。假设已经雇佣 \(m\) 个人，那么总的费用是 \(O(nc_i + mc_h)\) 。根据算法，你总是要面试 \(n\) 个候选人，因此面试的总费用固定为 \(nc_i\) ，我们主要关注 \(mc_h\) 部分，即雇佣费用。可以看到，雇佣费用不仅取决于候选人，也取决于代理人的推荐顺序。这是一个典型的随机算法。我们用指示器随机变量来分析这个算法，令 \(X_i = I\{第i位候选人被雇佣\}, X=\sum_{i=1}^nX_i\) 。考虑到第i位候选人被雇佣的条件是他比前面的 \(i-1\) 位候选人更优秀，这个条件的概率是 \(\frac{(i-1)!}{i!} = \frac{1}{i}\) ，因此
\[
E[X] = E[\sum_{i=1}^{n}X_i] = \sum_{i=1}^{n}E[X_i] = \sum_{i=1}^{n}\frac{1}{n} = O(lnn)
\]
</p>

<p>
由此可知，当候选人以随机的次序被面试时，雇佣问题的费用是 \(O(c_hlnn)\) 。这个成本比最坏情况 \(O(c_hn)\) 更好。
</p>



<p>
级数 \(\sum_{i=1}^\inf{\frac{1}{i}}\) 叫做调和级数。调和级数的前 \(n\) 项之和是 \(ln(n+1) + \gamma = O(lnn)\) ，\(\gamma\) 是欧拉常数。调和级数前 \(n\) 项和的计算过程如下：
\[
\sum_{i=1}^n = \sum_{i=1}^n\int_i^{i+1} \frac{1}{\lfloor x \rfloor} dx = \int_1^{n+1}\frac{1}{x} + \frac{1}{\lfloor x \rfloor} - \frac{1}{n} dx = \int_1^{n+1}\frac{1}{x}dx + \int_1^{n+1}\frac{1}{\lfloor x \rfloor} - \frac{1}{x}dx = ln(n+1) + \gamma
\]
</p>



<p>
指示器随机变量也可以用来解决帽子保管问题（hat-check problem）。当顾客到达饭店时会将自己的帽子交给服务生保管。在顾客离开时，服务生随机选择一顶帽子交还给顾客。假设一共来了 \(n\) 位顾客，拿到自己帽子的顾客平均有 \(lnn\) 位。下面再用几个例子来展示指示器随机变量的用法。
</p>


<p>
生日悖论。要使一群人中有两个人生日相同的概率超过50%，这群人最少要有多少人？不考虑闰年的情况，假设一年有 \(n=365\) 天。因此两个人生日相同的概率是 \(\frac{1}{n}\) 。令 \(A_i\) 表示事件 \(\forall i < j, i与j生日不同\) ， \(B_k\) 表示 \(k\) 个人的生日都不相同，则
\[
B_k = \bigcap_{i=1}^kA_i = A_k \bigcap B_{k-1}
\]
</p>

<p>
因此
</p>

<p>
\[
Pr\{B_k\} = Pr\{B_{k-1}\}Pr\{A_k \mid B_{k-1} \}
\]
</p>

<p>
考虑到
\[
Pr\{A_k \mid B_{k-1} \} = \frac{n-(k-1)}{n}
\]
</p>

<p>
将 \(Pr\{B_k\}\) 展开，有
</p>

<p>
\[
Pr\{B_k\} = Pr\{B_1\} Pr\{A_2 \mid B_1 \} \cdots Pr\{A_k \mid B_{k-1} \} = 1 \cdot \frac{n-1}{n} \frac{n-2}{n} \frac{n-k+1}{n}
\]
</p>

<p>
由 \(1 + x \le e^x\) 知，
\[
Pr\{B_k\} \le e^{-\sum_{i=1}^{k-1}\frac{i}{n}} = e^{-\frac{k(k-1)}{2n}}
\]
</p>

<p>
题目要求 \(Pr\{B_k\} \le \frac{1}{2}\) ，因此需要 \(k(k-1) \ge 2nln2\) 。解这个方程得 \(k \ge 23\) 。
</p>


<p>
下面我们用指示器随机变量来分析生日悖论问题。 \(\forall i < j\) ，我们定义 \(X_{ij} = I\{i和j生日相同\}\) 。二人生日相同的概率是 \(\frac{1}{n}\) ，因此 \(E[X_{ij}] = \frac{1}{n}\) 。我们用 \(X\) 表示二人生日相同事件的数量，则
\[
X = \sum_{i=1}^k \sum_{j=i+1}^k X_{ij}
\]
</p>

<p>
\[
E[X] = E[\sum_{i=1}^k \sum_{j=i+1}^k X_{ij}] = \frac{k(k-1)}{2n}
\]
</p>

<p>
因此当 \(k(k-1) \ge 2n\) 时，人群中二人生日相同的期望大于1。对于 \(n=365\) ， \(k=28\) 。两种方法的计算结果虽然不同，但两个结果在渐进意义下是相等的，都是 \(\Theta(\sqrt{n})\) 。
</p>



<p>
球与盒子。把相同的球随机投入到 \(b\) 个不同的盒子里。每次投球都是独立的，球落入任意一个盒子的概率都是 \(\frac{1}{b}\) 。对于一个给定的盒子，平均有多少球落入这个盒子中？落在特定盒子中的球数服从二项分布 \(b(k;n, \frac{1}{b})\) 。如果投 \(n\) 个球，平均有 \(\frac{n}{b}\) 个落入特定盒子中。需要投多少个球，才能让指定的盒子中至少包含一个球？这个随机变量服从概率为 \(\frac{1}{b}\) 的几何分布，需要投 \(\frac{1}{\frac{1}{b}} = b\) 个球。要投多少个球才能让每个盒子中都有球？我们把将球投入空盒子的事件叫做击中，这个问题等价于，要获得 \(b\) 次击中，需要进行多少次投球？考虑第 \(i-1\) 次命中之后，空箱子还有 \(b-i+1\) 个，投球击中的概率是 \(\frac{b-i+1}{b}\) 。假设在第 \(i-1\) 次命中后，到第 \(i\) 次命中，一共进行了 \(n_i\) 次投球。那么获得 \(b\) 次击中需要 \(n=\sum_{i=1}^bn_i\) 次投球。 \(n_i\) 服从几何分布，成功的概率是 \(\frac{b-i+1}{b}\) ，期望是 \(E[n_i] = \frac{b}{b-i+1}\) 。因此
\[
E[n] = \sum_{i=1}^b\frac{b}{b-i+1} = \frac{1}{b}\sum_{i=1}^b\frac{1}{b} = b(lnn + O(1))
\]
</p>

<p>
球与盒子问题也叫做折扣券收集者问题（coupon collector's problem）。
</p>


<p>
序列。连续抛一枚硬币 \(n\) 次，连续得到正面的次数，最大值的期望是 \(\Theta(n)\) 。
</p>
</div>
</div>
</div>


<div id="outline-container-org55f9c9a" class="outline-2">
<h2 id="org55f9c9a">第二部分 排序和顺序统计学</h2>
<div class="outline-text-2" id="text-org55f9c9a">
<p>
如果在排序过程中，只需要常数个外部空间，这个排序算法就叫做原地排序。插入排序是原地排序，归并排序不是。
</p>
</div>

<div id="outline-container-orgafeed4f" class="outline-3">
<h3 id="orgafeed4f">第六章 堆排序</h3>
<div class="outline-text-3" id="text-orgafeed4f">
<p>
堆排序是一种时间复杂度为 \(O(nlgn)\) 的原地排序算法。堆排序使用一种叫做堆的数据结构。（二叉）堆是用数组存储的完全二叉树。根节点保存在数组的首个元素中。第 \(i\) 个元素的子节点保存在 \(2i\) 和 \(2i+1\) 元素。堆排序使用的是最大堆，即父节点的值大于任一子节点值的堆。堆排序和选择排序的思路有些相似，每次选择最大的元素移动到数组尾部。堆排序首先构造一个最大堆，堆顶元素就是最大值。将最大值和数组尾部元素互换，然后将堆的大小减一，调整元素以满足堆的性质，得到第二大元素。依次循环执行。堆排序的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">max_heapify</span>(<span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">array</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">length</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">index</span>) {
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">max</span> = index;
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">left_child</span> = index * 2 + 1;
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">right_child</span> = left_child + 1;

        <span style="color: #FBDE2D;">if</span> (left_child &lt; length &amp;&amp; array[left_child] &gt; array[index]) {
                max = left_child;
        }
        <span style="color: #FBDE2D;">if</span> (right_child &lt; length &amp;&amp; array[right_child] &gt; array[max]) {
                max = right_child;
        }

        <span style="color: #FBDE2D;">if</span> (max == index) {
                <span style="color: #FBDE2D;">return</span>;
        }

        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">tmp</span> = array[index];
        array[index] = array[max];
        array[max] = tmp;

        max_heapify(array, length, max);
}

<span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">build_max_heap</span>(<span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">array</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">length</span>) {
        <span style="color: #FBDE2D;">for</span> (<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">i</span> = length / 2; i &gt;= 0; i--) {
                max_heapify(array, length, i);
        }
}

<span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">heap_sort</span>(<span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">array</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">length</span>) {
        build_max_heap(array, length);
        <span style="color: #FBDE2D;">for</span> (<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">i</span> = length - 1; i &gt; 0; i--) {
                <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">tmp</span> = array[0];
                array[0] = array[i];
                array[i] = tmp;

                max_heapify(array, i, 0);
        }
}
</pre>
</div>


<p>
我们来考察构造堆的时间复杂度。很容易可以得到一个上界 \(O(nlgn)\) ，不过还可以更精确。有 \(n\) 个元素的堆的高度是 \(\lfloor lgn \rfloor\) ，在高度为 \(h\) 的节点上最多有 \(\lceil \frac{n}{2^{h+1}} \rceil\) 个子节点，并且max_heapify的时间复杂度是 \(O(h)\) 。因此构建堆的时间复杂度是
\[
\sum_{h=0}^{\lfloor lgn \rfloor}\lceil \frac{n}{2^{h+1}}\rceil O(h) = O(n \sum_{h=0}^{\lfloor lgn \rfloor} \frac{h}{2^h}) = O(n)
\]
</p>

<p>
每次调整堆的时间是 \(O(lgn)\) ，一共 \(n-1\) 次循环，因此堆排序的时间复杂度是 \(O(nlgn)\) 。
</p>


<p>
堆排序最常见的应用场景是优先级队列。后者可以用于调度作业或事件驱动模拟程序。
</p>
</div>
</div>

<div id="outline-container-org0d76cb3" class="outline-3">
<h3 id="org0d76cb3">第七章 快速排序</h3>
<div class="outline-text-3" id="text-org0d76cb3">
<p>
快速排序是实践中最常用的排序算法。快速排序是一种原地排序算法，最坏运行时间是 \(\Theta(n)\) ，平均运行时间是 \(\Theta(nlgn)\) 。快速排序采用分治策略。首先从数组中选择一个数，这个数叫做支点。将剩余的元素分大于支点和小于支点的两部分，接着在这两部分上递归进行快速排序。快速排序的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">partition</span>(<span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">array</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">length</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">left</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">right</span>) {
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">pivot</span> = array[right];
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">i</span> = left - 1;
        <span style="color: #FBDE2D;">for</span> (<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">j</span> = left; j &lt; right; j++) {
                <span style="color: #FBDE2D;">if</span> (array[j] &lt;= pivot) {
                        i = i + 1;
                        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">tmp</span> = array[i];
                        array[i] = array[j];
                        array[j] = tmp;
                }
        }

        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">tmp</span> = array[i + 1];
        array[i + 1] = array[right];
        array[right] = tmp;

        <span style="color: #FBDE2D;">return</span> i + 1;
}

<span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">quick_sort</span>(<span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">array</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">length</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">left</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">right</span>) {
        <span style="color: #FBDE2D;">if</span> (left &gt;= right) {
                <span style="color: #FBDE2D;">return</span>;
        }

        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">middle</span> = partition(array, length, left,right);
        quick_sort(array, length, left, middle - 1);
        quick_sort(array, length, middle + 1, right);
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgb77e664" class="outline-3">
<h3 id="orgb77e664">第八章 线性时间排序</h3>
<div class="outline-text-3" id="text-orgb77e664">
<p>
前面介绍的排序算法都是基于比较的，这类算法存在这 \(\Omega(nlgn)\) 的下限。这一章介绍一些线性时间的排序算法。如果待排序的元素都是介于 \(0\) 到 \(k\) 整数，如果 \(k=O(n)\) ，存在一种 \(\Theta(n)\) 的排序算法，叫做计数排序。计数排序建立一个 \(0\) 到 \(k\) 的数组 \(c\) 。当遇到数 $0 &le; i &le; k$时，将 \(c[i]\) 的值加一。输入读取完毕后，依次输出 \(c[i]\) 个 \(i\) 即得到排序结果。计数排序的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">counting_sort</span>(<span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">array</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">length</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">max</span>, <span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">output</span>) {
        <span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">count</span> = (<span style="color: #8DA6CE;">int</span>*) malloc(<span style="color: #FBDE2D;">sizeof</span>(<span style="color: #8DA6CE;">int</span>) * (max + 1));
        <span style="color: #FBDE2D;">if</span> (count == <span style="color: #D8FA3C;">NULL</span>) {
                abort();
        }

        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">i</span>;
        <span style="color: #FBDE2D;">for</span> (i = 0; i &lt;= max; i++) {
                count[i] = 0;
        }

        <span style="color: #FBDE2D;">for</span> (<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">i</span> = 0; i &lt; length; i++) {
                count[array[i]]++;
        }

        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">k</span> = 0;
        <span style="color: #FBDE2D;">for</span> (i = 0; i &lt;= max; i++) {
                <span style="color: #FBDE2D;">while</span> (count[i]-- !=0) {
                        output[k++] = i;
                }
        }

        free(count);
}
</pre>
</div>


<p>
基数排序是一种特殊场景下的排序算法。在基数排序中，整数表示为以某个数为基的级数，比如 \(12_{10} = 1100_2\) ，从低位开始，逐位将各数对应位组成的数组，以稳定排序算法排序。当最高位完成排序后，整个数组就排好序了。基数排序的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">stable_sort</span>(<span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">array</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">length</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">bit</span>) {
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">mask</span> = 1 &lt;&lt; (bit - 1);

        <span style="color: #FBDE2D;">for</span> (<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">i</span> = 1; i &lt; length; i++) {
                <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">key</span> = array[i];
                <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">j</span>;
                <span style="color: #FBDE2D;">for</span> (j = i - 1; j &gt;= 0; j--) {
                        <span style="color: #FBDE2D;">if</span> ((key &amp; mask) &gt;= (array[j] &amp; mask)) {
                                <span style="color: #FBDE2D;">break</span>;
                        }

                        array[j + 1] = array[j];
                }
                array[j + 1] = key;
        }
}

<span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">radix_sort</span>(<span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">array</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">length</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">bit_number</span>) {
        <span style="color: #FBDE2D;">for</span> (<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">i</span> = 1; i &lt;= bit_number; i++) {
                stable_sort(array, length, i);
        }
}
</pre>
</div>


<p>
桶排序适用于输入的数属于 \([0,1)\) 的情况。桶排序类似散列表，将区间 \([0,1)\) 分为 \(n\) 个大小相同的子区间，叫做桶。桶排序的伪代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">bucket_sort</span>(<span style="color: #8DA6CE;">float</span> *<span style="color: #FF6400;">array</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">length</span>) {

        <span style="color: #8DA6CE;">float</span> *<span style="color: #FF6400;">buckets</span> = (<span style="color: #8DA6CE;">float</span>*) malloc(<span style="color: #FBDE2D;">sizeof</span>(<span style="color: #8DA6CE;">float</span>) * length);
        <span style="color: #FBDE2D;">if</span> (buckets == <span style="color: #D8FA3C;">NULL</span>) {
                abort();
        }

        <span style="color: #FBDE2D;">for</span> (<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">i</span> = 0; i &lt; length; i++) {
                insert_to_bucket(array[i], buckets[length * array[i]]);
        }

        <span style="color: #FBDE2D;">for</span> (<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">i</span> = 0; i &lt; length; i++) {
                sort(buckets[i]);
        }

        free(buckets);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf067d67" class="outline-3">
<h3 id="orgf067d67">第九章 中位数和顺序统计学</h3>
<div class="outline-text-3" id="text-orgf067d67">
<p>
在一个 \(n\) 个元素的集合中，第 \(i\) 小的元素叫做第 \(i\) 个顺序统计量（order statistic）。中位数（median）是位于“中间”的元素。从集合中选择第 \(i\) 个元素的问题叫做选择问题。选择问题可以通过排序完成，不过存在更高效的算法。参考快速排序，可以构造一个 \(O(n)\) 算法：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">random_select</span>(<span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">array</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">length</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">left</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">right</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">order</span>) {
        <span style="color: #FBDE2D;">if</span> (left == right) {
                <span style="color: #FBDE2D;">return</span> array[left];
        }

        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">middle</span> = partition(array, length, left, right);
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">pivot</span> = middle - left + 1;
        <span style="color: #FBDE2D;">if</span> (order == pivot) {
                <span style="color: #FBDE2D;">return</span> array[middle];
        } <span style="color: #FBDE2D;">else</span> <span style="color: #FBDE2D;">if</span> (order &lt; pivot) {
                <span style="color: #FBDE2D;">return</span> random_select(array, length, left, middle - 1, order);
        } <span style="color: #FBDE2D;">else</span> {
                <span style="color: #FBDE2D;">return</span> random_select(array, length, middle + 1, right, order - pivot);
        }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org909df6f" class="outline-2">
<h2 id="org909df6f">第三部分 数据结构</h2>
<div class="outline-text-2" id="text-org909df6f">
</div>
<div id="outline-container-org65bc6da" class="outline-3">
<h3 id="org65bc6da">第十章 基本数据结构</h3>
<div class="outline-text-3" id="text-org65bc6da">
<p>
栈是一种后进先出（LIFO）策略的队列。栈上插入元素的操作叫做压栈，删除元素的操作叫做弹栈。栈的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7fffd4;">#include</span> <span style="color: #61CE3C;">&lt;stdio.h&gt;</span>

<span style="color: #FBDE2D;">struct</span> <span style="color: #8DA6CE;">stack</span>;
<span style="color: #FBDE2D;">typedef</span> <span style="color: #FBDE2D;">struct</span> <span style="color: #8DA6CE;">stack</span> <span style="color: #8DA6CE;">stack_t</span>;

<span style="color: #FBDE2D;">const</span> <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">error</span> = 1;
<span style="color: #FBDE2D;">const</span> <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">ok</span> = 0;

<span style="color: #FBDE2D;">struct</span> <span style="color: #8DA6CE;">stack</span> {
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">size</span>;
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">capacity</span>;
        <span style="color: #8DA6CE;">void</span> **<span style="color: #FF6400;">data</span>;
};

<span style="color: #8DA6CE;">stack_t</span>* <span style="color: #FF6400;">stack_create</span>(<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">capacity</span>) {
        <span style="color: #8DA6CE;">stack_t</span> *<span style="color: #FF6400;">stack</span> = (<span style="color: #8DA6CE;">stack_t</span>*) malloc(<span style="color: #FBDE2D;">sizeof</span>(stack_t));
        <span style="color: #FBDE2D;">if</span> (stack == <span style="color: #D8FA3C;">NULL</span>) {
                <span style="color: #FBDE2D;">return</span> <span style="color: #D8FA3C;">NULL</span>;
        }

        stack-&gt;size = 0;
        stack-&gt;capacity = capacity;
        stack-&gt;data = (<span style="color: #8DA6CE;">void</span>*) malloc(<span style="color: #FBDE2D;">sizeof</span>(<span style="color: #8DA6CE;">void</span>*) * capacity);
        <span style="color: #FBDE2D;">if</span> (stack-&gt;data == <span style="color: #D8FA3C;">NULL</span>) {
                free(stack);
                <span style="color: #FBDE2D;">return</span> <span style="color: #D8FA3C;">NULL</span>;
        }

        <span style="color: #FBDE2D;">return</span> stack;
}

<span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">stack_release</span>(<span style="color: #8DA6CE;">stack_t</span> *<span style="color: #FF6400;">stack</span>) {
        <span style="color: #FBDE2D;">if</span> (stack == <span style="color: #D8FA3C;">NULL</span>) {
                <span style="color: #FBDE2D;">return</span>;
        }

        free(stack-&gt;data);
        free(stack);
}

<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">stack_push</span>(<span style="color: #8DA6CE;">stack_t</span> *<span style="color: #FF6400;">stack</span>, <span style="color: #8DA6CE;">void</span> *<span style="color: #FF6400;">element</span>) {
        <span style="color: #FBDE2D;">if</span> (stack == <span style="color: #D8FA3C;">NULL</span>) {
                <span style="color: #FBDE2D;">return</span> error;
        }

        <span style="color: #FBDE2D;">if</span> (stack-&gt;size &gt;= stack-&gt;capacity) {
                <span style="color: #FBDE2D;">return</span> error;
        }

        stack-&gt;data[stack-&gt;size++] = element;
        <span style="color: #FBDE2D;">return</span> ok;
}

<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">stack_pop</span>(<span style="color: #8DA6CE;">stack_t</span> *<span style="color: #FF6400;">stack</span>) {
        <span style="color: #FBDE2D;">if</span> (stack == <span style="color: #D8FA3C;">NULL</span>) {
                <span style="color: #FBDE2D;">return</span> error;
        }

        <span style="color: #FBDE2D;">if</span> (stack-&gt;size &lt;= 0) {
                <span style="color: #FBDE2D;">return</span> error;
        }

        stack-&gt;size--;
        <span style="color: #FBDE2D;">return</span> ok;
}

<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">stack_is_empty</span>(<span style="color: #8DA6CE;">stack_t</span> *<span style="color: #FF6400;">stack</span>, <span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">empty</span>) {
        <span style="color: #FBDE2D;">if</span> (stack == <span style="color: #D8FA3C;">NULL</span> || stack-&gt;size == 0 || empty == <span style="color: #D8FA3C;">NULL</span>) {
                <span style="color: #FBDE2D;">return</span> error;
        }

        *empty = stack-&gt;size == 0 ? 1 : 0;

        <span style="color: #FBDE2D;">return</span> ok;
}

<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">stack_top</span>(<span style="color: #8DA6CE;">stack_t</span> *<span style="color: #FF6400;">stack</span>, <span style="color: #8DA6CE;">void</span> **<span style="color: #FF6400;">result</span>) {
        <span style="color: #FBDE2D;">if</span> (stack == <span style="color: #D8FA3C;">NULL</span>) {
                <span style="color: #FBDE2D;">return</span> error;
        }

        <span style="color: #FBDE2D;">if</span> (stack-&gt;size &lt;= 0) {
                <span style="color: #FBDE2D;">return</span> error;
        }

        <span style="color: #FBDE2D;">if</span> (result == <span style="color: #D8FA3C;">NULL</span>) {
                <span style="color: #FBDE2D;">return</span> error;
        }

        *result = stack-&gt;data[stack-&gt;size - 1];
        <span style="color: #FBDE2D;">return</span> ok;
}

<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">stack_capacity</span>(<span style="color: #8DA6CE;">stack_t</span> *<span style="color: #FF6400;">stack</span>) {
        <span style="color: #FBDE2D;">return</span> stack == <span style="color: #D8FA3C;">NULL</span> ? 0 : stack-&gt;capacity;
}

<span style="color: #FBDE2D;">typedef</span> <span style="color: #8DA6CE;">int</span> (*<span style="color: #8DA6CE;">element_visitor</span>)(<span style="color: #8DA6CE;">void</span> *);
<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">stack_visit</span>(<span style="color: #8DA6CE;">stack_t</span> *<span style="color: #FF6400;">stack</span>, <span style="color: #8DA6CE;">element_visitor</span> <span style="color: #FF6400;">visitor</span>) {
        <span style="color: #FBDE2D;">if</span> (stack == <span style="color: #D8FA3C;">NULL</span> &amp;&amp; visitor == <span style="color: #D8FA3C;">NULL</span>) {
                <span style="color: #FBDE2D;">return</span> error;
        }

        <span style="color: #FBDE2D;">for</span> (<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">i</span> = stack-&gt;size - 1; i &gt;= 0; i--) {
                <span style="color: #FBDE2D;">if</span> (visitor(stack-&gt;data[i]) == error) {
                        <span style="color: #FBDE2D;">return</span> error;
                }
        }

        <span style="color: #FBDE2D;">return</span> ok;
}

<span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">print_result</span>(<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">result</span>) {
        printf(<span style="color: #61CE3C;">"%s\n"</span>, result == error ? <span style="color: #61CE3C;">"error"</span> : <span style="color: #61CE3C;">"ok"</span>);
}

<span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">print_int</span>(<span style="color: #8DA6CE;">void</span> *<span style="color: #FF6400;">element</span>) {
        printf(<span style="color: #61CE3C;">"%d\n"</span>, (<span style="color: #8DA6CE;">int</span>) element);
}


<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">main</span>() {
        <span style="color: #8DA6CE;">stack_t</span> *<span style="color: #FF6400;">stack</span> = stack_create(10);

        stack_push(stack, (<span style="color: #8DA6CE;">void</span>*) 1);
        stack_push(stack, (<span style="color: #8DA6CE;">void</span>*) 2);
        stack_push(stack, (<span style="color: #8DA6CE;">void</span>*) 3);

        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">empty</span>;

        stack_visit(stack, print_int);

        <span style="color: #FBDE2D;">while</span> (1) {
                <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">ret</span> = stack_is_empty(stack, &amp;empty);
                <span style="color: #FBDE2D;">if</span> (ret == error || empty) {
                        <span style="color: #FBDE2D;">break</span>;
                }

                <span style="color: #8DA6CE;">void</span> *<span style="color: #FF6400;">element</span>;
                stack_top(stack, &amp;element);
                stack_pop(stack);
                printf(<span style="color: #61CE3C;">"POP %d\n"</span>, (<span style="color: #8DA6CE;">int</span>) element);
        }
        stack_release(stack);

        <span style="color: #FBDE2D;">return</span> 0;
}
</pre>
</div>

<p>
队列是FIFO线性表。队列的插入操作叫做入队，删除操作叫做出队。队列的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7fffd4;">#include</span> <span style="color: #61CE3C;">&lt;stdio.h&gt;</span>

<span style="color: #FBDE2D;">const</span> <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">error</span> = 1;
<span style="color: #FBDE2D;">const</span> <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">ok</span> = 0;

<span style="color: #FBDE2D;">struct</span> <span style="color: #8DA6CE;">queue</span> {
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">size</span>;
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">capacity</span>;
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">begin</span>;
        <span style="color: #8DA6CE;">void</span> **<span style="color: #FF6400;">data</span>;
};

<span style="color: #FBDE2D;">typedef</span> <span style="color: #FBDE2D;">struct</span> <span style="color: #8DA6CE;">queue</span> <span style="color: #8DA6CE;">queue_t</span>;

<span style="color: #8DA6CE;">queue_t</span>* <span style="color: #FF6400;">queue_create</span>(<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">capacity</span>) {
        <span style="color: #8DA6CE;">queue_t</span> *<span style="color: #FF6400;">queue</span> = (<span style="color: #8DA6CE;">queue_t</span>*) malloc(<span style="color: #FBDE2D;">sizeof</span>(queue_t));
        <span style="color: #FBDE2D;">if</span> (queue == <span style="color: #D8FA3C;">NULL</span>) {
                <span style="color: #FBDE2D;">return</span> <span style="color: #D8FA3C;">NULL</span>;
        }

        queue-&gt;begin = 0;
        queue-&gt;size = 0;
        queue-&gt;capacity = capacity;
        queue-&gt;data = (<span style="color: #8DA6CE;">void</span>*) malloc(<span style="color: #FBDE2D;">sizeof</span>(<span style="color: #8DA6CE;">void</span>*) * capacity);
        <span style="color: #FBDE2D;">if</span> (queue-&gt;data == <span style="color: #D8FA3C;">NULL</span>) {
                free(queue);
                <span style="color: #FBDE2D;">return</span> <span style="color: #D8FA3C;">NULL</span>;
        }

        <span style="color: #FBDE2D;">return</span> queue;        
}

<span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">queue_release</span>(<span style="color: #8DA6CE;">queue_t</span> *<span style="color: #FF6400;">queue</span>) {
        <span style="color: #FBDE2D;">if</span> (queue == <span style="color: #D8FA3C;">NULL</span>) {
                <span style="color: #FBDE2D;">return</span>;
        }

        free(queue-&gt;data);
        free(queue);        
}

<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">queue_enqueue</span>(<span style="color: #8DA6CE;">queue_t</span> *<span style="color: #FF6400;">queue</span>, <span style="color: #8DA6CE;">void</span> *<span style="color: #FF6400;">element</span>) {
        <span style="color: #FBDE2D;">if</span> (queue == <span style="color: #D8FA3C;">NULL</span>) {
                <span style="color: #FBDE2D;">return</span> error;
        }

        <span style="color: #FBDE2D;">if</span> (queue-&gt;size &gt;= queue-&gt;capacity) {
                <span style="color: #FBDE2D;">return</span> error;
        }

        queue-&gt;size++;
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">index</span> = (queue-&gt;begin + queue-&gt;size) % queue-&gt;capacity;
        queue-&gt;data[index] = element;
        <span style="color: #FBDE2D;">return</span> ok;
}

<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">queue_dequeue</span>(<span style="color: #8DA6CE;">queue_t</span> *<span style="color: #FF6400;">queue</span>) {
        <span style="color: #FBDE2D;">if</span> (queue == <span style="color: #D8FA3C;">NULL</span>) {
                <span style="color: #FBDE2D;">return</span> error;
        }

        <span style="color: #FBDE2D;">if</span> (queue-&gt;size &lt;= 0) {
                <span style="color: #FBDE2D;">return</span> error;
        }

        queue-&gt;size--;
        queue-&gt;begin = (queue-&gt;begin + 1) % queue-&gt;capacity;
        <span style="color: #FBDE2D;">return</span> ok;
}

<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">main</span>() {

}
</pre>
</div>

<p>
链表。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #7fffd4;">#include</span> <span style="color: #61CE3C;">&lt;stdio.h&gt;</span>

<span style="color: #FBDE2D;">const</span> <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">error</span> = 1;
<span style="color: #FBDE2D;">const</span> <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">ok</span> = 0;

<span style="color: #FBDE2D;">struct</span> <span style="color: #8DA6CE;">list</span> {
        <span style="color: #8DA6CE;">void</span> *<span style="color: #FF6400;">data</span>;
        <span style="color: #FBDE2D;">struct</span> <span style="color: #8DA6CE;">list</span> *<span style="color: #FF6400;">prev</span>;
        <span style="color: #FBDE2D;">struct</span> <span style="color: #8DA6CE;">list</span> *<span style="color: #FF6400;">next</span>;
};

<span style="color: #FBDE2D;">typedef</span> <span style="color: #FBDE2D;">struct</span> <span style="color: #8DA6CE;">list</span> <span style="color: #8DA6CE;">list_t</span>;

<span style="color: #8DA6CE;">list_t</span>* <span style="color: #FF6400;">list_create</span>() {
        <span style="color: #8DA6CE;">list_t</span> *<span style="color: #FF6400;">list</span> = (<span style="color: #8DA6CE;">list_t</span>*) malloc(<span style="color: #FBDE2D;">sizeof</span>(list_t));
        <span style="color: #FBDE2D;">if</span> (list == <span style="color: #D8FA3C;">NULL</span>) {
                <span style="color: #FBDE2D;">return</span> <span style="color: #D8FA3C;">NULL</span>;
        }

        list-&gt;data = <span style="color: #D8FA3C;">NULL</span>;
        list-&gt;prev = <span style="color: #D8FA3C;">NULL</span>;
        list-&gt;next = <span style="color: #D8FA3C;">NULL</span>;
        <span style="color: #FBDE2D;">return</span> list;        
}

<span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">list_release</span>(<span style="color: #8DA6CE;">list_t</span> *<span style="color: #FF6400;">list</span>) {
        <span style="color: #FBDE2D;">if</span> (list == <span style="color: #D8FA3C;">NULL</span>) {
                <span style="color: #FBDE2D;">return</span>;
        }

        free(list-&gt;data);
        list_release(list-&gt;next);        
}

<span style="color: #8DA6CE;">list_t</span>* <span style="color: #FF6400;">list_insert</span>(<span style="color: #8DA6CE;">list_t</span> *<span style="color: #FF6400;">list</span>, <span style="color: #8DA6CE;">void</span> *<span style="color: #FF6400;">element</span>) {
        <span style="color: #FBDE2D;">if</span> (list == <span style="color: #D8FA3C;">NULL</span>) {
                <span style="color: #FBDE2D;">return</span> <span style="color: #D8FA3C;">NULL</span>;
        }

        <span style="color: #8DA6CE;">list_t</span> *<span style="color: #FF6400;">new_list</span> = list_create();
        new_list-&gt;data = element;
        new_list-&gt;next = list;
        list-&gt;prev = new_list;

        <span style="color: #FBDE2D;">return</span> new_list;
}

<span style="color: #8DA6CE;">list_t</span>* <span style="color: #FF6400;">list_remove</span>(<span style="color: #8DA6CE;">list_t</span> *<span style="color: #FF6400;">list</span>) {
        <span style="color: #FBDE2D;">if</span> (list == <span style="color: #D8FA3C;">NULL</span>) {
                <span style="color: #FBDE2D;">return</span> <span style="color: #D8FA3C;">NULL</span>;
        }

        <span style="color: #8DA6CE;">list_t</span> *<span style="color: #FF6400;">prev</span> = list-&gt;prev;
        <span style="color: #8DA6CE;">list_t</span> *<span style="color: #FF6400;">next</span> = list-&gt;next;

        <span style="color: #FBDE2D;">if</span> (prev != <span style="color: #D8FA3C;">NULL</span>) {
                prev-&gt;next = next;
        }

        <span style="color: #FBDE2D;">if</span> (next != <span style="color: #D8FA3C;">NULL</span>) {
                next-&gt;prev = prev;
        }

        <span style="color: #FBDE2D;">if</span> (prev != <span style="color: #D8FA3C;">NULL</span>) {
                <span style="color: #FBDE2D;">return</span> prev;
        }

        <span style="color: #FBDE2D;">return</span> next;
}

<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">main</span>() {

}
</pre>
</div>
</div>
</div>

<div id="outline-container-org25e9e4f" class="outline-3">
<h3 id="org25e9e4f">第十一章 散列表</h3>
<div class="outline-text-3" id="text-org25e9e4f">
<p>
散列表是数组的推广，可以直接进行寻址，因此访问时间是 \(O(1)\) 。当全域比较小的时候，采用直接寻址表是比较简单有效的技术。直接寻址表是一个记录了全域中所有值的数组，它的操作包括：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">Element</span>* <span style="color: #FF6400;">direct_address_search</span>(<span style="color: #8DA6CE;">Element</span> *<span style="color: #FF6400;">table</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">key</span>) {
        <span style="color: #FBDE2D;">return</span> table[key];
}

<span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">direct_address_insert</span>(<span style="color: #8DA6CE;">Element</span> *<span style="color: #FF6400;">table</span>, <span style="color: #8DA6CE;">Element</span> *<span style="color: #FF6400;">element</span>) {
        table[element-&gt;key] = element;
}

<span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">direct_address_delete</span>(<span style="color: #8DA6CE;">Element</span> *<span style="color: #FF6400;">table</span>, <span style="color: #8DA6CE;">Element</span> *<span style="color: #FF6400;">element</span>) {
        table[element-&gt;key] = <span style="color: #D8FA3C;">NULL</span>;
}
</pre>
</div>

<p>
如果全域范围很大，就需要采用散列表和散列函数。散列表小于全域，散列函数将值映射到散列表中。这就导致可能有多个元素映射到散列表的同一个位置上。为了解决碰撞问题，一种方法是将一个位置上的元素放到一个链表中，这种叫做链接法。链接法的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">chained_hash_insert</span>(<span style="color: #8DA6CE;">Element</span> *<span style="color: #FF6400;">table</span>, <span style="color: #8DA6CE;">Element</span> *<span style="color: #FF6400;">value</span>) {
        list_insert(table[hash(value-&gt;key)], value);
}

<span style="color: #8DA6CE;">Element</span>* <span style="color: #FF6400;">chained_hash_search</span>(<span style="color: #8DA6CE;">Element</span> *<span style="color: #FF6400;">table</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">key</span>) {
        <span style="color: #FBDE2D;">return</span> list_search(table[hash(key)], key);
}

<span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">chained_hash_delete</span>(<span style="color: #8DA6CE;">Element</span> *<span style="color: #FF6400;">table</span>, <span style="color: #8DA6CE;">Element</span> *<span style="color: #FF6400;">value</span>) {
        list_delete(table[hash(value-&gt;key)], value);
}
</pre>
</div>

<p>
下面分析一下链接法的性能。假设散列表有 \(m\) 个槽位，可以存储 \(n\) 个元素，我们将 \(\alpha = \frac{n}{m}\) 叫做装载因子（load factor）。对于链接发，在简单一致散列条件下，一次查找的时间平均是 \(\Theta(1+\alpha)\) 。简单平均散列是指各槽中链表长度的平均值是 \(\alpha\) 。如果槽数与域中的元素数成正比，即 \(n=O(m)\) ，那么 \(O(1+\alpha) = O(\frac{n}{m}) = \frac{O(m)}{m} = O(1)\) 。
</p>


<p>
现在讨论如何设计一个散列算法。好的散列算法应当满足简单一致假设。一种常见的算法是除数法：
\[
h(k) = k mod m
\]
</p>

<p>
\(m\) 通常选择一个原理 \(2^p\) 的质数。选择 \(m\) 的时候，可以首先评估域 \(n\) 的大小，然后选择合适的平均查找次数 \(1+\alpha\) ，根据公式 \(\alpha=\frac{n}{m}\) 在 \(m\) 附近搜索质数。
</p>


<p>
另一个构造散列函数的方法是乘法散列法。选择一个常数 \(A, 0 < A < 1\) ，散列函数定义为：
\[
h(k) = \lfloor m (kA - \lfloor kA \rfloor) \rfloor
\]
</p>

<p>
乘法散列法对 \(m\) 没有要求。为了便于计算， 通常选择2的方幂作为 \(m\) 。在这种方法中， \(A\) 的选择和待散列的数据有关。有人认为，让 \(A\) 接近 \(\frac{\sqrt{5} - 1}{2}\) 是比较好的选择。为了便于计算，通常将 \(A\) 设置为接近 \(\frac{\sqrt{5}-1}{2}\) 的一个可以表示为 \(\frac{s}{2^w}\) 的值。其 \(s\) 是一个整数， \(w\) 是计算机的字长。在64位计算机上， \(w=64\) 。
</p>


<p>
另外一种方法是全域散列。全域散列是一种随机化算法。首先设计一组函数。在程序初始化时，随机选择其中的一个作为散列函数。全域算列的平均性能较好，这是因为选中性能较差散列函数的概率很低。
</p>


<p>
除了链接法，开放地址法也是一种散列表设计方法。这种方法将元素直接保存在散列表中。在插入元素时，如果散列地址已经被占用，需要依次查看后面的探查地址。探查的顺序不一定是 \(0, 1, \dots m-1\) ，只要是它的一个排列就可以了。开放地址法的 \(\alpha\) 始终不超过1。下面是开放地址法伪代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">open_addressing_hash_insert</span>(<span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">hash_table</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">key</span>) {
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">position</span> = hash(key);
        <span style="color: #FBDE2D;">while</span> (postion != END_OF_TABLE &amp;&amp; position != EMPTY) {
                position = next_position(position);
        }

        <span style="color: #FBDE2D;">if</span> (position == END_OF_TABLE) {
                <span style="color: #AEAEAE; font-style: italic;">// </span><span style="color: #AEAEAE; font-style: italic;">full</span>
                abort();
        }

        hash_table[position] = key;
}

<span style="color: #8DA6CE;">int</span>* <span style="color: #FF6400;">open_addressing_hash_search</span>(<span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">hash_table</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">key</span>) {
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">position</span> = hash(key);
        <span style="color: #FBDE2D;">while</span> (postion != END_OF_TABLE &amp;&amp; position != EMPTY &amp;&amp; hash_table[position] != key) {
                position = next_position(position);
        }

        <span style="color: #FBDE2D;">if</span> (hash_table[position] == key) {
                <span style="color: #FBDE2D;">return</span> &amp;(hash_table[position]);
        }

        <span style="color: #FBDE2D;">return</span> <span style="color: #D8FA3C;">NULL</span>;
}

<span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">open_addressing_hash_delete</span>(<span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">hash_table</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">key</span>) {
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">target</span> = NIL;
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">last_same_key</span> = NIL;

        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">position</span> = hash(key);
        <span style="color: #FBDE2D;">while</span> (position != END_OF_TABLE &amp;&amp; position != EMPTY) {
                <span style="color: #FBDE2D;">if</span> (hash_table[position] == key) {
                        target = position;
                }
                last_same_key = position;
        }

        <span style="color: #FBDE2D;">if</span> (last_same_key == target) {
                hash_table[target] = NIL;
                <span style="color: #FBDE2D;">break</span>;
        }

        hash_table[target] = hash_table[last_same_key];
        hash_table[last_same_key] = NIL;
}
</pre>
</div>

<p>
上面的伪代码中，在删除元素时，将拥有相同键的元素覆盖删除的位置。另一种做法是用一个标记值“DELETE”写入槽。在寻找时跳过，在插入时当作空白槽写入。
</p>


<p>
前面讲过探查序列必须是 \(1, 2, \dots, m-1\) 的一个排列。有三种常见的生成探查序列的方法，分别是线性探查、二次探查和双重探查。其中双重探查效果最好，应用最广。对于给定的散列函数 \(h'(k)\) ，线性探查的散列函数为
\[
h(k,i) = (h'(k) + i) mod m
\]
</p>

<p>
随着散列表中的元素增加，连续占用的槽位增多，平均查找时间会增加。这种现象叫做一次集群。二次探查采用一个二次函数作为辅助函数。二次探查的散列函数是：
\[
h(k, i) = (h'(k) + c_1i + c_2i^2) mod m
\]
二次探查也存在轻微的聚集情况。双重探查采用两个散列函数 \(h_1, h_2\) 进行探查：
\[
h(k, i) = (h_1(k) + ih_2(k)) mod m
\]
</p>
</div>
</div>


<div id="outline-container-orgb3235cf" class="outline-3">
<h3 id="orgb3235cf">第十二章 二叉查找树</h3>
<div class="outline-text-3" id="text-orgb3235cf">
<p>
二叉查找树是一个二叉树，同时满足查找性质，即假设 \(x\) 是二叉查找树中的一个节点，\(y\) 是 \(x\) 左子树中的一个节点， \(z\) 是 \(x\) 右子树中的一个节点，那么 \(key[y] \le key[x] \le key[z]\) 。对二叉查找树进行中序遍历，即按照做“左子树-节点-右子树”的顺序遍历，就可以得到一个排序的关键字数组。这个过程的时间是 \(\Theta(n)\) 。二叉查找树的查找代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">tree_t</span>* <span style="color: #FF6400;">tree_search</span>(<span style="color: #8DA6CE;">tree_t</span> *<span style="color: #FF6400;">tree</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">key</span>) {
        <span style="color: #FBDE2D;">if</span> (tree == <span style="color: #D8FA3C;">NULL</span> || tree-&gt;key == key) {
                <span style="color: #FBDE2D;">return</span> tree;
        }

        <span style="color: #FBDE2D;">if</span> (key &lt; tree-&gt;key) {
                <span style="color: #FBDE2D;">return</span> tree_search(tree-&gt;left_child, key);
        } <span style="color: #FBDE2D;">else</span> {
                <span style="color: #FBDE2D;">return</span> tree_search(tree-&gt;right_child, key);
        }
}

<span style="color: #8DA6CE;">tree_t</span>* <span style="color: #FF6400;">tree_search_iterative</span>(<span style="color: #8DA6CE;">tree_t</span> *<span style="color: #FF6400;">tree</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">key</span>) {
        <span style="color: #FBDE2D;">while</span> (tree != <span style="color: #D8FA3C;">NULL</span> &amp;&amp; tree-&gt;key != key) {
                <span style="color: #FBDE2D;">if</span> (tree-&gt;key &lt; key) {
                        tree = tree-&gt;left_child;
                } <span style="color: #FBDE2D;">else</span> {
                        tree = tree-&gt;right_child;
                }
        }
}

<span style="color: #8DA6CE;">tree_t</span>* <span style="color: #FF6400;">tree_minimum</span>(<span style="color: #8DA6CE;">tree_t</span> *<span style="color: #FF6400;">tree</span>) {
        <span style="color: #FBDE2D;">while</span> (tree != <span style="color: #D8FA3C;">NULL</span> &amp;&amp; tree-&gt;left_child != <span style="color: #D8FA3C;">NULL</span>) {
                tree = tree-&gt;left_child;
        }
        <span style="color: #FBDE2D;">return</span> tree;
}

<span style="color: #8DA6CE;">tree_t</span>* <span style="color: #FF6400;">tree_maximum</span>(<span style="color: #8DA6CE;">tree_t</span> *<span style="color: #FF6400;">tree</span>) {
        <span style="color: #FBDE2D;">while</span> (tree != <span style="color: #D8FA3C;">NULL</span> &amp;&amp; tree-&gt;right_child != <span style="color: #D8FA3C;">NULL</span>) {
                tree = tree-&gt;right_child;
        }
        <span style="color: #FBDE2D;">return</span> tree;
}
</pre>
</div>

<p>
在二叉查找树中，节点 \(x\) 的后继就是它右子树的最小值。如果没有右子树， \(x\) 的是它的一个祖先节点 \(y\) ，满足 \(x\) 在 \(y\) 的左子树上，并且 \(y\) 到 \(x\) 的距离最短。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">tree_t</span>* <span style="color: #FF6400;">tree_successor</span>(<span style="color: #8DA6CE;">tree_t</span> *<span style="color: #FF6400;">node</span>) {
        <span style="color: #FBDE2D;">if</span> (node-&gt;right_child != <span style="color: #D8FA3C;">NULL</span>) {
                <span style="color: #FBDE2D;">return</span> tree_minimum(node-&gt;right_child);
        }

        <span style="color: #8DA6CE;">tree_t</span> *<span style="color: #FF6400;">parent</span> = node-&gt;parent;
        <span style="color: #FBDE2D;">while</span> (parent != <span style="color: #D8FA3C;">NULL</span> &amp;&amp; node == parent-&gt;right_child) {
                node = parent;
                parent = node-&gt;parent;
        }

        <span style="color: #FBDE2D;">return</span> parent;
}
</pre>
</div>

<p>
下面是二叉查找树的插入代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">tree_insert</span>(<span style="color: #8DA6CE;">tree_t</span> *<span style="color: #FF6400;">tree</span>, <span style="color: #8DA6CE;">tree_t</span> *<span style="color: #FF6400;">new_node</span>) {
        <span style="color: #8DA6CE;">tree_t</span> *<span style="color: #FF6400;">parent</span> = <span style="color: #D8FA3C;">NULL</span>;
        <span style="color: #8DA6CE;">tree_t</span> *<span style="color: #FF6400;">node</span> = <span style="color: #D8FA3C;">NULL</span>;

        <span style="color: #FBDE2D;">while</span> (node != <span style="color: #D8FA3C;">NULL</span>) {
                parent = node;
                <span style="color: #FBDE2D;">if</span> (new_node-&gt;key &lt; node-&gt;key) {
                        node = node-&gt;left_child;
                } <span style="color: #FBDE2D;">else</span> {
                        node = node-&gt;right_child;
                }
        }

        new_node-&gt;parent = parent;
        <span style="color: #FBDE2D;">if</span> (parent == <span style="color: #D8FA3C;">NULL</span>) {
                tree-&gt;root = new_node;
                <span style="color: #FBDE2D;">return</span>;
        } 

        <span style="color: #FBDE2D;">if</span> (new_node-&gt;key &lt; parent-&gt;key) {
                parent-&gt;left_child = new_node;
        } <span style="color: #FBDE2D;">else</span> {
                parent-&gt;right_child = new_node;
        }
}
</pre>
</div>


<p>
假设 \(x\) 是要删除的节点，根据 \(x\) 的位置，删除分为三种情况： \(x\) 是根节点、 \(x\) 最多有一个子树、 \(x\) 有两个子树。对于第一种情况，将树的根节点设置为NIL。对于第二种情况，将 \(x\) 的子树设置为父节点的子树。对于第三种情况，假设 \(y\) 是 \(x\) 的后继，将 \(x\) 和 \(y\) 的值互换，然后删除叶子节点 \(y\) 。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">tree_t</span>* <span style="color: #FF6400;">tree_delete</span>(<span style="color: #8DA6CE;">tree_t</span> *<span style="color: #FF6400;">tree</span>, <span style="color: #8DA6CE;">tree_t</span> *<span style="color: #FF6400;">node</span>) {
        <span style="color: #8DA6CE;">tree_t</span> *<span style="color: #FF6400;">parent</span> = node-&gt;parent;

        <span style="color: #AEAEAE; font-style: italic;">// </span><span style="color: #AEAEAE; font-style: italic;">&#31532;&#19968;&#31181;&#24773;&#20917;&#65306;node&#26159;&#26681;&#33410;&#28857;&#12290;</span>
        <span style="color: #FBDE2D;">if</span> (parent == <span style="color: #D8FA3C;">NULL</span>) {
                tree-&gt;root = <span style="color: #D8FA3C;">NULL</span>;
                <span style="color: #FBDE2D;">return</span> tree-&gt;root;
        }

        <span style="color: #AEAEAE; font-style: italic;">// </span><span style="color: #AEAEAE; font-style: italic;">&#31532;&#20108;&#31181;&#24773;&#20917;&#65306;&#26368;&#22810;&#26377;&#19968;&#20010;&#23376;&#26641;</span>
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">in_left_subtree</span> = 1;
        <span style="color: #FBDE2D;">if</span> (parent-&gt;right_child == node) {
                in_left_subtree = 0;
        }

        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">miss_left_child</span> = node-&gt;left_child == <span style="color: #D8FA3C;">NULL</span>;
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">miss_right_child</span> = node-&gt;right_child == <span style="color: #D8FA3C;">NULL</span>;
        <span style="color: #FBDE2D;">if</span> (miss_left_child || miss_right_child) {
                <span style="color: #8DA6CE;">tree_t</span> *<span style="color: #FF6400;">child</span> = node-&gt;left_child;
                <span style="color: #FBDE2D;">if</span> (miss_left_child) {
                        child = node-&gt;right_child;
                }

                <span style="color: #FBDE2D;">if</span> (in_left_subtree) {
                        parent-&gt;left_child = child;
                } <span style="color: #FBDE2D;">else</span> {
                        parent-&gt;right_child = child;
                }

                <span style="color: #FBDE2D;">if</span> (child != <span style="color: #D8FA3C;">NULL</span>) {
                        child-&gt;parent = parent;
                }

                <span style="color: #FBDE2D;">return</span> child;
        }

        <span style="color: #AEAEAE; font-style: italic;">// </span><span style="color: #AEAEAE; font-style: italic;">&#31532;&#19977;&#31181;&#24773;&#20917;&#65306;&#26377;&#20004;&#20010;&#23376;&#26641;</span>
        <span style="color: #8DA6CE;">tree_t</span> *<span style="color: #FF6400;">successor</span> = tree_successor(node);
        node-&gt;key = successor-&gt;key;

        <span style="color: #AEAEAE; font-style: italic;">// </span><span style="color: #AEAEAE; font-style: italic;">successor&#26159;node&#30340;&#21491;&#23376;&#33410;&#28857;</span>
        <span style="color: #FBDE2D;">if</span> (successor-&gt;parent == node) {
                node-&gt;left_child = <span style="color: #D8FA3C;">NULL</span>;
                <span style="color: #FBDE2D;">return</span> node;
        }

        <span style="color: #AEAEAE; font-style: italic;">// </span><span style="color: #AEAEAE; font-style: italic;">successor&#19981;&#26159;node&#30340;&#21491;&#23376;&#33410;&#28857;</span>
        in_left_subtree = parent-&gt;left_child == node;
        <span style="color: #FBDE2D;">if</span> (in_left_subtree) {
                successor-&gt;parent-&gt;left_child = <span style="color: #D8FA3C;">NULL</span>;
        } <span style="color: #FBDE2D;">else</span> {
                successor-&gt;parent-&gt;right_child = <span style="color: #D8FA3C;">NULL</span>;
        }

        <span style="color: #FBDE2D;">return</span> node;
}
</pre>
</div>

<p>
基数树是一种可以在 \(\Theta(n)\) 时间内完成字典序排序的数据结构。字典序的定义如下：假设有两个字符串 \(a=a_0a_1 \cdots a_p\) 和 \(b=b_0b_1 \cdots b_q\) 。如果下列两个条件之一得到满足，就称 \(a < b\) ：
</p>
<ul class="org-ul">
<li>\(\exists j, 0 \le j \le min(p,q): a_j < b_j, \forall i < j a_i = b_i\) 。</li>
<li>\(p < q, \forall i \le p: a_i = b_i\) 。</li>
</ul>

<p>
除了根节点之外，基数树的每个节点表示一位字符，这个节点表示的数据，就是从根节点到这个节点的路径上包含的字符组成的字符串。基数树可以在 \(\Theta(n)\) 中完成字典序排序。
</p>
</div>
</div>

<div id="outline-container-orgc5c5453" class="outline-3">
<h3 id="orgc5c5453">第十三章 红黑树</h3>
<div class="outline-text-3" id="text-orgc5c5453">
<p>
二叉查找树的性能取决于到叶子节点的最长路径。这个路径的长度从 \(lgn\) 到 \(n\) 。如果让这个路径保持在 \(O(lgn)\) 就可以提高二叉查找树的性能。要做到这一点，就要让各个路径的长度相等。这时就叫做二叉搜索树是平衡的。越接近平衡，查找树的性能越高。红黑树就是一种接近平衡的二叉搜索树。在红黑树中，最长路径的长度不会超过最短路径的两倍。红黑树的每个节点都有一个表示颜色的变量，可以取值为“红”或“黑”。如果满足下列条件，一棵二叉搜索树就是红黑树：
</p>
<ul class="org-ul">
<li>每个节点是红的或黑的。</li>
<li>根节点是黑的。</li>
<li>叶节点（NIL）是黑的。</li>
<li>如果一个节点是红的，它的子节点是黑的。</li>
<li>对每个节点，它到任一叶子节点的路径上，黑节点的数量是相同的。</li>
</ul>

<p>
假设 \(x\) 是红黑树的一个节点， \(x\) 到叶子节点路径上，黑节点的数量叫做 \(x\) 的黑高度，记为 \(bh(x)\) 。对于有 \(n\) 个节点的红黑树，节点的黑高度最多是 \(2lg(n+1)\) 。这个结论可以通过使用归纳法证明证明它的一个变形来得到：以 \(x\) 为根节点的红黑树至少包含 \(2^{bh(x)}-1\) 个节点。
</p>


<p>
红黑树中经常使用到旋转操作。旋转分为左旋和右旋。假设 \(y\) 是 \(x\) 的右子节点， \(p\) 是 \(x\) 的父节点。在左旋时， \(y\) 的父节点变成 \(p\) 。 \(x\) 变成 \(y\) 的左子节点， \(y\) 的左子节点变为 \(x\) 的右子节点。左旋的伪代码如下：
</p>
<div class="org-src-container">
<pre class="src src-text">p = x.parent
y = x.right

x.right = y.left
y.left.parent =x

y.left = x
x.parent = y
y.parent = p
if (p.left == x) {
    p.left = y
} else {
    p.right =y 
}
</pre>
</div>

<p>
右旋和左旋是类似的。右旋的伪代码如下：
</p>
<div class="org-src-container">
<pre class="src src-text">p = x.parent
y = x.left

x.left = y.right
y.right.parent =x

y.right = x
x.parent = y
y.parent = p
if (p.left == x) {
    p.left = y
} else {
    p.right =y 
}
</pre>
</div>


<p>
对于非空红黑树的插入可以分为两个步骤，第一步是采用二叉查找树插入算法，将节点插入树，并将节点染成红色。第二步是调整红黑树以保持红黑树性质。第二步又分为几种不同的情况：
</p>
<ul class="org-ul">
<li>如果父节点是黑色的，不需要做任何操作。</li>
<li>如果父节点是红色的，且叔叔节点也是红色的，将父节点和叔叔节点染成黑色，将祖父节点染成红色。然后将祖父节点设置为当前节点，继续进行调整。</li>
<li>如果父节点是红色的，叔叔节点是黑色的。这种情况又分为：
<ul class="org-ul">
<li>LL型，即当前节点是父节点的左子节点，父节点是祖父节点的左子节点。将祖父节点右旋，将原祖父节点染成红色，原父节点染成黑色。</li>
<li>LR型，即当前节点是父节点的右子节点，父节点是祖父节点的左子节点。将父节点左旋，变成LL型，并按照LL型进行调整。</li>
<li>RR型，即当前节点是父节点的右子节点，父节点是祖父节点的右子节点。将祖父节点左旋，将原祖父节点染成红色，原父节点染成黑色。</li>
<li>RL型，即当前节点是父节点的左子节点，父节点是祖父节点的右子节点。将父节点右旋，变成RR型，并按照RR型进行调整。</li>
</ul></li>
</ul>

<p>
下面是红黑树插入代码：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #FBDE2D;">public</span> <span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">rb_insert</span>(<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">key</span>) {
        <span style="color: #8DA6CE;">Node</span> <span style="color: #FF6400;">newNode</span> = <span style="color: #FBDE2D;">new</span> <span style="color: #8DA6CE;">Node</span>();<span style="color: #AEAEAE; font-style: italic;">//</span><span style="color: #AEAEAE; font-style: italic;">&#21253;&#35013;&#25104;&#26032;&#32467;&#28857;</span>
        newNode.key = key;
        newNode.left = NIL;
        newNode.right = NIL;
        newNode.parent = NIL;
        newNode.color = <span style="color: #D8FA3C;">Color</span>.RED;
        <span style="color: #AEAEAE; font-style: italic;">//</span><span style="color: #AEAEAE; font-style: italic;">&#23558;&#26032;&#32467;&#28857;&#20197;&#20108;&#21449;&#25628;&#32034;&#26641;&#30340;&#24615;&#36136;&#25554;&#20837;&#21040;&#26641;&#31181;</span>
        <span style="color: #8DA6CE;">Node</span> <span style="color: #FF6400;">x</span> = root;
        <span style="color: #8DA6CE;">Node</span> <span style="color: #FF6400;">y</span> = NIL;
        <span style="color: #FBDE2D;">while</span> (x != NIL) {
                y = x;
                <span style="color: #FBDE2D;">if</span> (key &lt; x.<span style="color: #8DA6CE;">key</span>) {
                        x = x.left;
                } <span style="color: #FBDE2D;">else</span> {
                        x = x.right;
                }
        }
        newNode.parent = y;
        <span style="color: #FBDE2D;">if</span> (y == NIL) {
                root = newNode;
        } <span style="color: #FBDE2D;">else</span> <span style="color: #FBDE2D;">if</span> (key &lt; y.<span style="color: #8DA6CE;">key</span>) {
                y.left = newNode;
        } <span style="color: #FBDE2D;">else</span> {
                y.right = newNode;
        }
        rb_insert_fixup(newNode); <span style="color: #AEAEAE; font-style: italic;">//</span><span style="color: #AEAEAE; font-style: italic;">&#20877;&#23545;&#26032;&#32467;&#28857;&#36827;&#34892;&#35843;&#25972;&#20197;&#28385;&#36275;&#32418;&#40657;&#26641;&#30340;&#24615;&#36136;</span>
}

<span style="color: #FBDE2D;">private</span> <span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">rb_insert_fixup</span>(<span style="color: #8DA6CE;">Node</span> <span style="color: #FF6400;">z</span>) {
        <span style="color: #FBDE2D;">while</span> (z.parent != NIL &amp;&amp; z.parent.color == <span style="color: #D8FA3C;">Color</span>.RED) {
                <span style="color: #FBDE2D;">if</span> (z.parent == z.parent.parent.left) {
                        <span style="color: #8DA6CE;">Node</span> <span style="color: #FF6400;">y</span> = z.parent.parent.right;
                        <span style="color: #FBDE2D;">if</span> (y.color == <span style="color: #D8FA3C;">Color</span>.RED) { <span style="color: #AEAEAE; font-style: italic;">//</span><span style="color: #AEAEAE; font-style: italic;">&#24773;&#20917;1</span>
                                y.color = <span style="color: #D8FA3C;">Color</span>.BLACK;
                                z.parent.color = <span style="color: #D8FA3C;">Color</span>.BLACK;
                                z.parent.parent.color = <span style="color: #D8FA3C;">Color</span>.RED;
                                z = z.parent.parent;
                        } <span style="color: #FBDE2D;">else</span> <span style="color: #FBDE2D;">if</span> (z == z.parent.right) { <span style="color: #AEAEAE; font-style: italic;">//</span><span style="color: #AEAEAE; font-style: italic;">&#24773;&#20917;2</span>
                                z = z.parent;
                                leftRotate(z);
                        } <span style="color: #FBDE2D;">else</span> { <span style="color: #AEAEAE; font-style: italic;">//</span><span style="color: #AEAEAE; font-style: italic;">&#24773;&#20917;3</span>
                                z.parent.color = <span style="color: #D8FA3C;">Color</span>.BLACK;
                                z.parent.parent.color = <span style="color: #D8FA3C;">Color</span>.RED;
                                rightRatate(z.parent.parent);
                        }
                } <span style="color: #FBDE2D;">else</span> {
                        <span style="color: #8DA6CE;">Node</span> <span style="color: #FF6400;">y</span> = z.parent.parent.left;
                        <span style="color: #FBDE2D;">if</span> (y.color == <span style="color: #D8FA3C;">Color</span>.RED) { <span style="color: #AEAEAE; font-style: italic;">//</span><span style="color: #AEAEAE; font-style: italic;">&#24773;&#20917;1 </span>
                                y.color = <span style="color: #D8FA3C;">Color</span>.BLACK;
                                z.parent.color = <span style="color: #D8FA3C;">Color</span>.BLACK;
                                z.parent.parent.color = <span style="color: #D8FA3C;">Color</span>.RED;
                                z = z.parent.parent;
                        } <span style="color: #FBDE2D;">else</span> <span style="color: #FBDE2D;">if</span> (z == z.parent.left) { <span style="color: #AEAEAE; font-style: italic;">//</span><span style="color: #AEAEAE; font-style: italic;">&#24773;&#20917;2</span>
                                z = z.parent;
                                rightRatate(z);
                        } <span style="color: #FBDE2D;">else</span> { <span style="color: #AEAEAE; font-style: italic;">//</span><span style="color: #AEAEAE; font-style: italic;">&#24773;&#20917;3</span>
                                z.parent.color = <span style="color: #D8FA3C;">Color</span>.BLACK;
                                z.parent.parent.color = <span style="color: #D8FA3C;">Color</span>.RED;
                                leftRotate(z.parent.parent);
                        }
                }
        }
        root.color = <span style="color: #D8FA3C;">Color</span>.BLACK; <span style="color: #AEAEAE; font-style: italic;">//</span><span style="color: #AEAEAE; font-style: italic;">&#28385;&#36275;&#32418;&#40657;&#26641;&#24615;&#36136;2 </span>
}
</pre>
</div>

<p>
红黑树的删除也是类似的。首先按照二叉查找树删除节点。如果被删除的节点是黑色的，在被删除的位置开始，调整红黑树。假设 \(x\) 待调整的节点， \(p\) 是 \(x\) 的父节点， \(w\) 是 \(x\) 的兄弟节点，假设 \(x\) 是 \(p\) 的左子节点，调整分为四种情况：
</p>
<ul class="org-ul">
<li>\(w\) 是红色的。将 \(x.parent\) 设置为红色，将 \(p\) 设置为红色，将 \(w\) 设置为黑色，将 \(p\) 左旋。继续调整左旋后 \(p\) 的左子节点。</li>
<li>\(w\) 和 \(w\) 的两个子节点都是黑色的。将 \(w\) 设置为红色，从 \(p\) 开始继续调整。</li>
<li>\(w\) 的右子节点是黑色的。将 \(w\) 的左子节点设置为黑色，将 \(w\) 设置为红色，右旋 \(w\) ，继续从 \(x\) 开始调整。</li>
<li>\(w\) 的两个子节点都是红色的。将 \(w\) 设置为 \(p\) 颜色，将 \(p\) 设置为黑色，将 \(w\) 右子节点设置为黑色，左旋 \(p\) ，结束。</li>
</ul>

<p>
红黑树删除节点的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">tree_t</span>* <span style="color: #FF6400;">red_black_tree_delete</span>(<span style="color: #8DA6CE;">tree_t</span> *<span style="color: #FF6400;">tree</span>, <span style="color: #8DA6CE;">tree_t</span> *<span style="color: #FF6400;">node</span>) {
        <span style="color: #8DA6CE;">tree_t</span>* <span style="color: #FF6400;">origin_position</span> = tree_delete(tree, node);
        <span style="color: #FBDE2D;">if</span> (node-&gt;color == BLACK) {
                delete_adjust(tree, origin_position);
        }
}

RB-DELETE-FIXUP(T, x)
<span style="color: #FBDE2D;">while</span> x &#8800; root[T] and color[x] = BLACK  
    <span style="color: #FBDE2D;">do</span> <span style="color: #FBDE2D;">if</span> x = left[p[x]]      
          then w &lt;- right[p[x]]                                             <span style="color: #AEAEAE; font-style: italic;">// </span><span style="color: #AEAEAE; font-style: italic;">&#33509; &#8220;x&#8221;&#26159;&#8220;&#23427;&#29238;&#33410;&#28857;&#30340;&#24038;&#23401;&#23376;&#8221;&#65292;&#21017;&#35774;&#32622; &#8220;w&#8221;&#20026;&#8220;x&#30340;&#21460;&#21460;&#8221;(&#21363;x&#20026;&#23427;&#29238;&#33410;&#28857;&#30340;&#21491;&#23401;&#23376;)                                          </span>
               <span style="color: #FBDE2D;">if</span> color[w] = RED                                           <span style="color: #AEAEAE; font-style: italic;">// </span><span style="color: #AEAEAE; font-style: italic;">Case 1: x&#26159;&#8220;&#40657;+&#40657;&#8221;&#33410;&#28857;&#65292;x&#30340;&#20804;&#24351;&#33410;&#28857;&#26159;&#32418;&#33394;&#12290;(&#27492;&#26102;x&#30340;&#29238;&#33410;&#28857;&#21644;x&#30340;&#20804;&#24351;&#33410;&#28857;&#30340;&#23376;&#33410;&#28857;&#37117;&#26159;&#40657;&#33410;&#28857;)&#12290;</span>
                  then color[w] &lt;- BLACK                        &#9657;  Case 1   <span style="color: #AEAEAE; font-style: italic;">//   </span><span style="color: #AEAEAE; font-style: italic;">(01) &#23558;x&#30340;&#20804;&#24351;&#33410;&#28857;&#35774;&#20026;&#8220;&#40657;&#33394;&#8221;&#12290;</span>
                       color[p[x]] &lt;- RED                       &#9657;  Case 1   <span style="color: #AEAEAE; font-style: italic;">//   </span><span style="color: #AEAEAE; font-style: italic;">(02) &#23558;x&#30340;&#29238;&#33410;&#28857;&#35774;&#20026;&#8220;&#32418;&#33394;&#8221;&#12290;</span>
                       LEFT-ROTATE(T, p[x])                    &#9657;  Case 1   <span style="color: #AEAEAE; font-style: italic;">//   </span><span style="color: #AEAEAE; font-style: italic;">(03) &#23545;x&#30340;&#29238;&#33410;&#28857;&#36827;&#34892;&#24038;&#26059;&#12290;</span>
                       w &lt;- right[p[x]]                         &#9657;  Case 1   <span style="color: #AEAEAE; font-style: italic;">//   </span><span style="color: #AEAEAE; font-style: italic;">(04) &#24038;&#26059;&#21518;&#65292;&#37325;&#26032;&#35774;&#32622;x&#30340;&#20804;&#24351;&#33410;&#28857;&#12290;</span>
               <span style="color: #FBDE2D;">if</span> color[left[w]] = BLACK and color[right[w]] = BLACK       <span style="color: #AEAEAE; font-style: italic;">// </span><span style="color: #AEAEAE; font-style: italic;">Case 2: x&#26159;&#8220;&#40657;+&#40657;&#8221;&#33410;&#28857;&#65292;x&#30340;&#20804;&#24351;&#33410;&#28857;&#26159;&#40657;&#33394;&#65292;x&#30340;&#20804;&#24351;&#33410;&#28857;&#30340;&#20004;&#20010;&#23401;&#23376;&#37117;&#26159;&#40657;&#33394;&#12290;</span>
                  then color[w] &lt;- RED                          &#9657;  Case 2   <span style="color: #AEAEAE; font-style: italic;">//   </span><span style="color: #AEAEAE; font-style: italic;">(01) &#23558;x&#30340;&#20804;&#24351;&#33410;&#28857;&#35774;&#20026;&#8220;&#32418;&#33394;&#8221;&#12290;</span>
                       x &lt;-  p[x]                               &#9657;  Case 2   <span style="color: #AEAEAE; font-style: italic;">//   </span><span style="color: #AEAEAE; font-style: italic;">(02) &#35774;&#32622;&#8220;x&#30340;&#29238;&#33410;&#28857;&#8221;&#20026;&#8220;&#26032;&#30340;x&#33410;&#28857;&#8221;&#12290;</span>
                  <span style="color: #FBDE2D;">else</span> <span style="color: #FBDE2D;">if</span> color[right[w]] = BLACK                          <span style="color: #AEAEAE; font-style: italic;">// </span><span style="color: #AEAEAE; font-style: italic;">Case 3: x&#26159;&#8220;&#40657;+&#40657;&#8221;&#33410;&#28857;&#65292;x&#30340;&#20804;&#24351;&#33410;&#28857;&#26159;&#40657;&#33394;&#65307;x&#30340;&#20804;&#24351;&#33410;&#28857;&#30340;&#24038;&#23401;&#23376;&#26159;&#32418;&#33394;&#65292;&#21491;&#23401;&#23376;&#26159;&#40657;&#33394;&#30340;&#12290;</span>
                          then color[left[w]] &lt;- BLACK          &#9657;  Case 3   <span style="color: #AEAEAE; font-style: italic;">//   </span><span style="color: #AEAEAE; font-style: italic;">(01) &#23558;x&#20804;&#24351;&#33410;&#28857;&#30340;&#24038;&#23401;&#23376;&#35774;&#20026;&#8220;&#40657;&#33394;&#8221;&#12290;</span>
                               color[w] &lt;- RED                  &#9657;  Case 3   <span style="color: #AEAEAE; font-style: italic;">//   </span><span style="color: #AEAEAE; font-style: italic;">(02) &#23558;x&#20804;&#24351;&#33410;&#28857;&#35774;&#20026;&#8220;&#32418;&#33394;&#8221;&#12290;</span>
                               RIGHT-ROTATE(T, w)              &#9657;  Case 3   <span style="color: #AEAEAE; font-style: italic;">//   </span><span style="color: #AEAEAE; font-style: italic;">(03) &#23545;x&#30340;&#20804;&#24351;&#33410;&#28857;&#36827;&#34892;&#21491;&#26059;&#12290;</span>
                               w &lt;- right[p[x]]                 &#9657;  Case 3   <span style="color: #AEAEAE; font-style: italic;">//   </span><span style="color: #AEAEAE; font-style: italic;">(04) &#21491;&#26059;&#21518;&#65292;&#37325;&#26032;&#35774;&#32622;x&#30340;&#20804;&#24351;&#33410;&#28857;&#12290;</span>
                  <span style="color: #FBDE2D;">else</span>  color[w] &lt;- color[p[x]]                 &#9657;  Case 4   <span style="color: #AEAEAE; font-style: italic;">// </span><span style="color: #AEAEAE; font-style: italic;">Case 4: x&#26159;&#8220;&#40657;+&#40657;&#8221;&#33410;&#28857;&#65292;x&#30340;&#20804;&#24351;&#33410;&#28857;&#26159;&#40657;&#33394;&#65307;x&#30340;&#20804;&#24351;&#33410;&#28857;&#30340;&#21491;&#23401;&#23376;&#26159;&#32418;&#33394;&#30340;&#12290;(01) &#23558;x&#29238;&#33410;&#28857;&#39068;&#33394; &#36171;&#20540;&#32473; x&#30340;&#20804;&#24351;&#33410;&#28857;&#12290;</span>
                        color[p[x]] &lt;- BLACK                    &#9657;  Case 4   <span style="color: #AEAEAE; font-style: italic;">//   </span><span style="color: #AEAEAE; font-style: italic;">(02) &#23558;x&#29238;&#33410;&#28857;&#35774;&#20026;&#8220;&#40657;&#33394;&#8221;&#12290;</span>
                        color[right[w]] &lt;- BLACK                &#9657;  Case 4   <span style="color: #AEAEAE; font-style: italic;">//   </span><span style="color: #AEAEAE; font-style: italic;">(03) &#23558;x&#20804;&#24351;&#33410;&#28857;&#30340;&#21491;&#23376;&#33410;&#35774;&#20026;&#8220;&#40657;&#33394;&#8221;&#12290;</span>
                        LEFT-ROTATE(T, p[x])                   &#9657;  Case 4   <span style="color: #AEAEAE; font-style: italic;">//   </span><span style="color: #AEAEAE; font-style: italic;">(04) &#23545;x&#30340;&#29238;&#33410;&#28857;&#36827;&#34892;&#24038;&#26059;&#12290;</span>
                        x &lt;- root[T]                            &#9657;  Case 4   <span style="color: #AEAEAE; font-style: italic;">//   </span><span style="color: #AEAEAE; font-style: italic;">(05) &#35774;&#32622;&#8220;x&#8221;&#20026;&#8220;&#26681;&#33410;&#28857;&#8221;&#12290;</span>
       <span style="color: #FBDE2D;">else</span> (same as then <span style="color: #8DA6CE;">clause</span> <span style="color: #FF6400;">with</span> <span style="color: #61CE3C;">"right"</span> and <span style="color: #61CE3C;">"left"</span> exchanged)        <span style="color: #AEAEAE; font-style: italic;">// </span><span style="color: #AEAEAE; font-style: italic;">&#33509; &#8220;x&#8221;&#26159;&#8220;&#23427;&#29238;&#33410;&#28857;&#30340;&#21491;&#23401;&#23376;&#8221;&#65292;&#23558;&#19978;&#38754;&#30340;&#25805;&#20316;&#20013;&#8220;right&#8221;&#21644;&#8220;left&#8221;&#20132;&#25442;&#20301;&#32622;&#65292;&#28982;&#21518;&#20381;&#27425;&#25191;&#34892;&#12290;</span>
<span style="color: #8DA6CE;">color</span>[x] &lt;- BLACK
</pre>
</div>
</div>
</div>


<div id="outline-container-org13971c5" class="outline-3">
<h3 id="org13971c5">第十四章 数据结构的扩张</h3>
<div class="outline-text-3" id="text-org13971c5">
<p>
采用红黑树支持动态顺序统计，可以在 \(O(lgn)\) 时间内找到第 \(i\) 小的元素，以及找到元素的序号。方法是在红黑树节点上增加域size，size记录了以当前节点为根的二叉树的大小，即
\[
x.size = x.left.size + x.right.size + 1
\]
这样的树叫做顺序统计树。顺序统计树的查找算法如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">tree_t</span>* <span style="color: #FF6400;">os_select</span>(<span style="color: #8DA6CE;">tree_t</span>* <span style="color: #FF6400;">x</span>, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">i</span>) {
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">r</span> = x-&gt;left_child-&gt;size + 1;
        <span style="color: #FBDE2D;">if</span> (i == r) {
                <span style="color: #FBDE2D;">return</span> x;
        } <span style="color: #FBDE2D;">else</span> <span style="color: #FBDE2D;">if</span> (i &lt; r) {
                <span style="color: #FBDE2D;">return</span> os_select(x-&gt;left_child, i);
        } <span style="color: #FBDE2D;">else</span> {
                <span style="color: #FBDE2D;">return</span> os_select(x-&gt;right_child, i - r);
        }
}
</pre>
</div>

<p>
确定一个元素序号的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">os_rank</span>(<span style="color: #8DA6CE;">tree_t</span>* <span style="color: #FF6400;">tree</span>, <span style="color: #8DA6CE;">tree_t</span>* <span style="color: #FF6400;">x</span>) {
        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">r</span> = x-&gt;left_child-&gt;size + 1;
        <span style="color: #8DA6CE;">tree_t</span>* <span style="color: #FF6400;">y</span> = x;
        <span style="color: #FBDE2D;">while</span> (y != tree-&gt;root) {
                <span style="color: #FBDE2D;">if</span> (y == y-&gt;parent-&gt;right_child) {
                        r = r + y-&gt;parent-&gt;left_child-&gt;size + 1;
                }
                y = y-&gt;parent;
        }

        <span style="color: #FBDE2D;">return</span> r;
}
</pre>
</div>

<p>
可以看到顺序统计树是通过对红黑树的扩张实现的。数据结构的扩张分为四个步骤：
</p>
<ul class="org-ul">
<li>选择基础数据结构。</li>
<li>确定要添加的信息。</li>
<li>验证基础数据结构上的修改操作足够维护新增信息。</li>
<li>设计新操作。</li>
</ul>

<p>
对于红黑树的扩张，假设节点 \(x\) 的新增信息仅依赖于 \(x\) 、 $x.left_child$、 \(x.right_child\) 的信息，那么删除和插入操作是 \(O(lgn)\) 的。
</p>
</div>
</div>
</div>

<div id="outline-container-orgca36da5" class="outline-2">
<h2 id="orgca36da5">第四部分 高级设计和分析技术</h2>
<div class="outline-text-2" id="text-orgca36da5">
</div>
<div id="outline-container-org613537d" class="outline-3">
<h3 id="org613537d">第十五章 动态规划</h3>
<div class="outline-text-3" id="text-org613537d">
<p>
动态规划和分治法相似之处，都是将问题划分为子问题来解决，区别在于子问题是否存在重叠。动态规划算法分为四个步骤：
</p>
<ul class="org-ul">
<li>描述最优解的结构。</li>
<li>递归定义最优解的值。</li>
<li>自底向上计算最优解。</li>
<li>由计算的结果构造最优解。</li>
</ul>
</div>
</div>

<div id="outline-container-orga05d2ba" class="outline-3">
<h3 id="orga05d2ba">第十六章 贪心算法</h3>
<div class="outline-text-3" id="text-orga05d2ba">
<p>
贪心算法也要求问题存在最优子结构。实际上贪心算法的基础正是动态规划算法。贪心算法的不同支出在于，通过设计合理的贪心策略，将子问题的数量降低到1。考虑下面的活动选择问题。大学里有一个剧场，很多社团都想借用剧场举办活动。一共有 \(n\) 个社团提出了申请，活动 \(a_i\) 的开始和结束时间分别是 \(s_i\) 和 \(f_i\) 。如何安排活动，使得剧场的使用时间最长呢？这个问题可以用动态规划来计算，但是还有更好的方法。我们假设活动按照结束时间 \(f_i\) 顺序排列。定义 \(S_{ij}\) 是介于活动 \(a_i\) 和 \(a_j\) 之间的活动：
\[
S_{ij} = \{ a_k \in S: f_i \le s_k < f_k \le s_j \}
\]
为了便于计算，我们增加两个虚拟活动 \(a_0\) 和 \(a_{n+1}\) ，并令 \(f_0 = 0, s_{n+1} =\inf\) 。假设 \(a_m\) 是 \(S_{ij}\) 中最早结束的活动，那么 \(S_{ij}\) 的最优解就是 \(a_m\) 和 \(S_{mj}\) 最优解的并集。
</p>


<p>
设计一个贪心算法要经过以下的步骤：
</p>
<ul class="org-ul">
<li>确定问题的最后子结构。</li>
<li>设计递归解。</li>
<li>选择一个贪心策略，使得在递归的任何阶段，贪心策略总能作出最优选择之一。</li>
<li>设计递归算法。</li>
<li>（可选）将递归转换为迭代。</li>
</ul>

<p>
如果问题中存在贪心策略，即全局最优解可以通过选择局部最优解达到，这个问题就称为具有贪心选择性质。有了贪心选择性质，就可以对子问题进行“剪枝”，加速计算。是否具有贪心选择性质往往和问题的约束条件有关。。我们考察三个相似的问题：背包问题和活动选择问题具有贪心选择性质，0-1背包问题则不具备。背包问题和0-1背包问题的区别在于物品是否可分割，活动选择问题和0-1背包问题的区别在于效用函数是重量还是价值。
</p>


<p>
贪心算法的一个重要应用是霍夫曼编码。霍夫曼编码是一种可变长的前缀编码。如果每个编码都不是其他编码的前缀，这种编码就叫做前缀编码（prefix code）。通过字符编码技术进行数据压缩的最优方法总是可以表示成某种前缀编码。一个文件的最优编码可以用一个满的二叉树表示。每个非叶子节点都有两个子节点，并且非叶子节点到其左子节点的路径对应的编码是0，到右子节点路径的编码是1。叶子节点是一个字符，它的编码就是从根节点到自身的路径。假设文件由字符表C中的字符组成。在文件中，字符c出现的频度是 \(f(c)\) ， \(d_T(c)\) 是c在树中的深度，同时也是c编码的长度。那么编码这个文件需要的位数是
\[
B(T) = \sum_{c \in C}f(c)d_T(c)
\]
</p>

<p>
这个值也叫做树T的代价。
</p>


<p>
霍夫曼编码是一种采用贪心算法求解文件最优前缀码的算法。它的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">binary_tree_node_t</span>* <span style="color: #FF6400;">huffman</span>(<span style="color: #8DA6CE;">array_t</span> <span style="color: #FF6400;">alphabet</span>, <span style="color: #8DA6CE;">hash_t</span> <span style="color: #FF6400;">frequency</span>) {

        <span style="color: #8DA6CE;">priority_queue_t</span> *<span style="color: #FF6400;">queue</span> = new_priority_queue();
        <span style="color: #FBDE2D;">for</span> (<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">i</span> = 0; i &lt; array_length(alphabet); i++) {
                <span style="color: #8DA6CE;">int</span> *<span style="color: #FF6400;">character</span> = (<span style="color: #8DA6CE;">int</span> *) malloc(<span style="color: #FBDE2D;">sizeof</span>(<span style="color: #8DA6CE;">int</span>));
                <span style="color: #FBDE2D;">if</span> (character == <span style="color: #D8FA3C;">NULL</span>) {
                        abort();
                }

                *character = array_get(alphabet, i);
                <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">priority</span> = hash_get(frequency, character);
                <span style="color: #8DA6CE;">binary_tree_node_t</span> *<span style="color: #FF6400;">node</span> = new_binary_tree_node(character, <span style="color: #D8FA3C;">NULL</span>, <span style="color: #D8FA3C;">NULL</span>);
                priority_queue_add(queue, node, priority);                
        }

        <span style="color: #FBDE2D;">for</span> (<span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">i</span> = 0; i &lt; array_length(alphabet) - 1; i++) {
                <span style="color: #8DA6CE;">binary_tree_node_t</span> *<span style="color: #FF6400;">node</span> = new_binary_tree_node(<span style="color: #D8FA3C;">NULL</span>, <span style="color: #D8FA3C;">NULL</span>, <span style="color: #D8FA3C;">NULL</span>);
                <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">priority</span> = 0;

                <span style="color: #8DA6CE;">pair_t</span> *<span style="color: #FF6400;">pair</span> = priority_queue_min(queue);
                <span style="color: #8DA6CE;">binary_tree_node_t</span> *<span style="color: #FF6400;">left</span> = pair-&gt;first;
                priority += pair-&gt;second;
                priority_queue_pop();

                pair = priority_queue_min(queue);
                <span style="color: #8DA6CE;">binary_tree_node_t</span> *<span style="color: #FF6400;">right</span> = pair-&gt;first;
                priority += pair-&gt;second;
                priority_queue_pop();

                node-&gt;left = left;
                node-&gt;right = right;
                priority_queue_add(queue, node, priority);
        }

        <span style="color: #8DA6CE;">binary_tree_node_t</span> *<span style="color: #FF6400;">root</span> = priority_queue_min(queue)-&gt;first;
        delete_priority_queue(queue);

        <span style="color: #FBDE2D;">return</span> root;
}
</pre>
</div>

<p>
霍夫曼编码的运行时间是 \(O(nlgn)\) 。
</p>
</div>
</div>


<div id="outline-container-org61dcc7c" class="outline-3">
<h3 id="org61dcc7c">第十七章 平摊分析</h3>
<div class="outline-text-3" id="text-org61dcc7c">
<p>
平摊分析可以进一步刻画算法的平均时间复杂度。和平均情况分析不同，平摊分析不涉及概率。最常用的平摊分析技术有聚集分析、记账法和势能法。
</p>


<p>
首先介绍聚集分析。聚集分析可以证明，如果由 \(n\) 个操作构成的序列的总时间最坏情况是 \(T(n)\) ，那么每个操作的平摊代价是 \(\frac{T(n)}{n}\) 。我们用栈作为例子。前面已经介绍了栈具有两个操作：PUSH(S,x)和POP(S)，每个操作的时间代价都是 \(O(1)\) 。我们为栈增加一个操作MULTIPOP(S,k)。假设栈中有 \(s\) 个元素，MULTIPOP(S,k)从栈顶弹出 \(min(s,k)\) 个元素。因此MULTIPOP的时间代价是 \(min(s,k)\) 。考虑一个由 \(n\) 个PUSH、POP、MULTIPOP操作组成的序列。表面上看，一次MULTIPOP操作的时间代价最坏情况是 \(O(n)\) ，因此这个序列的时间代价最坏情况是 \(O(n^2)\) 。可是如果进一步分析，执行 \(n\) 个操作的过程中，入栈和出栈的总次数最多是 \(O(n)\) ，因此每个操作的平摊代价是 \(\frac{O(n)}{n} = O(1)\) ，而序列时间代价的最坏情况是 \(O(n)\) 。
</p>
</div>
</div>
</div>


<div id="outline-container-orgb2c4417" class="outline-2">
<h2 id="orgb2c4417">第五部分 高级数据结构</h2>
<div class="outline-text-2" id="text-orgb2c4417">
</div>
<div id="outline-container-org944e61e" class="outline-3">
<h3 id="org944e61e">第十八章 B树</h3>
<div class="outline-text-3" id="text-org944e61e">
<p>
B树是针对磁盘等辅助存储设备设计的平衡查找数。B树可以在 \(O(lgn)\) 时间内完成动态集合操作。
</p>


<p>
假设 \(t\) 是一个大于1的整数。如果一个有根树具有以下性质，则称它是最小度数为 \(t\) 的B树：
</p>
<ul class="org-ul">
<li>每个节点都有一个闭区间与之关键。根节点关联的区间是 \([-\inf, +\inf]\) 。为了简化讨论，这里把正负无穷当作实数看待。</li>
<li>每个节点包含至少 \(t-1\) 个，至多 \(2t-1\) 个键。这些键是已排序的，记为 \(k_1, k_2, \cdots, k_p\) 。这些键都属于节点所关联的区间。</li>
<li>每个节点包含至少 \(t\) 个，至多 \(2t\) 个子节点。假设节点关联的区间是 \([a,b]\) ，并且包含 \(p\) 个键。令 \(k_0 = a, k_{p+1} = b\) ，则第 \(i\) 个子节点关联的闭区间是 \([k_{i-1}, k_i]\) 。如果一个节点包含 \(2t\) 个子节点，我们称它是满的。</li>
</ul>

<p>
最小度数为2的B树也叫做2-3-4树，因为每个节点可以有2、3、4个子节点。
</p>


<p>
根据B树的定义可以知道，对于一个包含了 \(n\) 个键，最小度数为 \(t\) 的B树，它的高度为：
\[
h \le log_t\frac{n+1}{2}
\]
</p>

<p>
如果我们把B树和红黑树进行对比就会发现，B树更加矮胖。
</p>


<p>
B树插入的难点在于对满节点的处理。满节点有 \(2t-1\) 个键。在插入前，满节点的中间键提升到父节点中，剩余的 \(2(t-1)\) 个键被分裂成两个包含 \(t-1\) 个键的节点。如果父节点也是慢的，父节点也要进行分裂。和插入相反，在删除节点时需要考虑节点的合并。假设要删除的键是 \(k\) ，并且节点只有 \(t-2\) 个键。我们用 \(c_{k-1}\) 和 \(c_{k}\) 分别表示位于 \(k\) 之前和之后的两个子节点。我们可以从 \(c_{k-1}\) 过 \(c_k\) 中借一个键，把这个键提升。如果借不到键（无法保证B树的性质），说明这两个子节点中键的数量小于 \(2t-2\) ，可以把这两个子节点合并成一个子节点。
</p>
</div>
</div>


<div id="outline-container-orgd7679b9" class="outline-3">
<h3 id="orgd7679b9">第十九章 二项堆</h3>
</div>
</div>


<div id="outline-container-org2ee23b9" class="outline-2">
<h2 id="org2ee23b9">第六部分 图算法</h2>
<div class="outline-text-2" id="text-org2ee23b9">
</div>
<div id="outline-container-org151ffc7" class="outline-3">
<h3 id="org151ffc7">第二十二章 图的基本算法</h3>
<div class="outline-text-3" id="text-org151ffc7">
<p>
从逻辑上看，图由顶点 \(V\) 和边 \(E\) 组成，我们记做 \(G=(V,E)\) 。如果边的数量远远小于顶点数量的平方（ \(|E| \ll |V|^2\) ），我们称这个图是稀疏图。反之称这个图是稠密图。图可以用邻接表和邻接矩阵存储，二者分别适合与存储稀疏图和稠密图。
</p>


<p>
邻接表是一个拥有 \(|V|\) 个列表的数组，每个列表对应一个顶点 \(u \in V\) 。如果列表包含顶点 \(v\) ，说明边 \((u,v)\) 是图中的一条边，即 \((u,v) \in E\) 。如果 \(G\) 是一个有向图，邻接表的长度之和是 \(|E|\) 。如果 \(G\) 是无向图，长度之和是 \(2|E|\) 。邻接表的存储空间是 \(O(V+E)\) 。邻接表的缺点在于无法快速检查一条边是否在图中。
</p>


<p>
邻接矩阵是一个 \(|V|*|V|\) 的矩阵，我们记为 \(A\) 。如果 \((i,j)\) 是图中的一条边， \(A_{ij} = 1\) ，否则 \(A_{ij}=0\) 。邻接矩阵的存储空间是 \(O(|V|^2)\) 。
</p>


<p>
对于图 \(G\) 中的两个点 \(u,v\) 。我们这两个点记为 \(u_0=u, v=u_{n+1}\) 。如果存在点 \(u_1, u_2, \cdots, u_n\) 使得 \((u_i, u_{i+1})\) 都是 \(G\) 中的边，那么就称 \(u\) 和 \(v\) 是连通的，这组首尾相连的边 \(u_0, u_1, \cdots, u_{n+1}\) 就叫做从 \(u\) 到 \(v\) 的路径。路径包含的边的数量叫做路径的长度。两个点之间可以存在多个路径，这些路径中长度的最小值叫做两点之间的距离。
</p>


<p>
广度优先遍历是一种图搜索算法。从给定的源顶点 \(s\) 开始，按照距离逐渐扩大搜索范围。广度优先搜索的伪代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">breadth_first_search</span>(Graph &amp;g, Vertex &amp;s) {
        <span style="color: #FBDE2D;">for</span> (Vertex &amp;v: g-&gt;vertexes()) {
                <span style="color: #FBDE2D;">if</span> (v == s) {
                        <span style="color: #FBDE2D;">continue</span>;
                }
                v.set_color(Color.white);
                v.set_distance(-1);
                v.set_parent(nullptr);
        }

        s.set_color(Color.Gray);
        s.set_distance(0);
        s.set_parent(nullptr);

        <span style="color: #8DA6CE;">Queue</span> <span style="color: #FF6400;">queue</span>;
        queue.enqueue(s);

        <span style="color: #FBDE2D;">while</span> (!queue.is_empty()) {
                Vertex &amp;u = queue.dequeue();
                <span style="color: #FBDE2D;">for</span> (Vertex &amp;v = u.neighbors()) {
                        <span style="color: #FBDE2D;">if</span> (!v.is_white()) {
                                <span style="color: #FBDE2D;">continue</span>;   
                        }
                        v.set_color(Color.Gray);
                        v.set_distance(u.distance() + 1);
                        v.set_parent(u);
                        queue.enqueue(v);
                }

                u.set_color(Color.black);
        }
}
</pre>
</div>

<p>
可以看到广度优先搜索中节点可以有3个状态：白色表示尚未搜索到，灰色表示已经搜索到，但其子邻接节点尚未搜索完毕，黑色表示节点本身和邻接节点都搜索完毕。广度优先搜索采用队列保存遇到的节点。在队列里，节点按照距离源节点的顺序排列。广度优先搜索的过程构造了一棵广度优先树。根节点是源顶点。在扫描节点 \(u\) 的邻接节点时，如果 \(v\) 是白色的，就把 \((u,v)\) 加到广度优先树中。在广度优先树中，根节点到某个节点的路径就是它们在图中的最短路径。考虑到每个节点和每条边都只扫描了一次，广度优先搜索的时间复杂度是 \(O(V+E)\) 。
</p>



<p>
和广度优先搜索不同，深度有限搜索总是首先寻找最长的路径。下面是它的代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">depth_first_visit</span>(Vertex &amp;v, <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">time</span>) {
        v.set_color(Color.Gray);
        time++;
        v.set_start_time(time);
        <span style="color: #FBDE2D;">for</span> (Vertex &amp;u: v.neighbors()) {
                <span style="color: #FBDE2D;">if</span> (u.is_white()) {
                        u.set_parent(v);
                        depth_first_visit(u);
                }
        }
        v.set_color(Color.Black);
        time++;
        v.set_finish_time(time);
        <span style="color: #FBDE2D;">return</span> time;
}

<span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">depth_first_search</span>(Graph &amp;g) {
        <span style="color: #FBDE2D;">for</span> (Vertex &amp;v: g.vertexes()) {
                v.set_color(Color.white);
                v.set_parent(nullptr);
        }

        <span style="color: #8DA6CE;">int</span> <span style="color: #FF6400;">time</span> = 0;
        <span style="color: #FBDE2D;">for</span> (Vertex &amp;v: g.vertexes()) {
                <span style="color: #FBDE2D;">if</span> (v.is_white()) {
                        time = depth_first_visit(v, time);
                }
        }
}
</pre>
</div>

<p>
深度优先搜索的时间也是 \(O(V+E)\) 。
</p>


<p>
深度优先搜索可以对有向无环图（DAG）进行拓扑排序。拓扑排序是顶点的一个序列，并且满足如果 \((u,v)\) 是图中的一条边， \(u\) 排在 \(v\) 之前。拓扑排序的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">List</span> <span style="color: #FF6400;">topological_sort</span>(Graph &amp;g) {

        <span style="color: #8DA6CE;">List</span> <span style="color: #FF6400;">list</span>;

        depth_first_search(g);
        <span style="color: #FBDE2D;">for</span> (Vertex &amp;v: g.vertexes()) {
                list.insert(v);
        }

        <span style="color: #FBDE2D;">return</span> list.sort(Vertex::get_finish_time).reverse();
}
</pre>
</div>

<p>
可以看出，拓扑排序就是将节点按照finish_time逆序排列而成。
</p>


<p>
深度优先搜索的另一个经典应用是将图分解为若干个强连通分支（strongly connected component）。强连通分支 \(C\) 是图 \(G\) 的一个子图，满足对于任意的 \(u,v \in C\) ， \(u\) 和 \(v\) 是相互可达的。很多图算法都会使用强连通分支，首先在强连通分支上运行，再将解合并起来。计算强连通分支前首先引入图的转置这个概念。对于图 \(G=(V,E)\) ，我们定义 \(E^T = \{ (u,v) \mid (v,u) \in E \}\) ，则图 \(G^T=(V,E^T)\) 叫做图 \(G\) 的转置。显然，如果两个节点在图中相互可达，在图的转置中仍然相互可达。计算强连通分支的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">strongly_connected_component</span>(Graph &amp;g) {
        <span style="color: #8DA6CE;">List</span> <span style="color: #FF6400;">vertices</span> = topological_sort(g); <span style="color: #AEAEAE; font-style: italic;">// </span><span style="color: #AEAEAE; font-style: italic;">invoke depth_first_search(g) </span>
        <span style="color: #8DA6CE;">Graph</span> <span style="color: #FF6400;">gt</span> = transpose(g);
        <span style="color: #FBDE2D;">for</span> (Vertex &amp;v: vertices) {
                <span style="color: #8DA6CE;">Tree</span> <span style="color: #FF6400;">component</span> = depth_first_visit(gt, v);
                print(componet);
        }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org640fa8b" class="outline-3">
<h3 id="org640fa8b">第二十三章 最小生成树</h3>
<div class="outline-text-3" id="text-org640fa8b">
<p>
假设 \(G=(V,E)\) 是一个无相连通图， \(T \subseteq E\) 是一个包含了所有顶点的无回路的子集，并且满足
\[
w(T) = \sum_{(u,v) \in T}w(u,v)
\]
是这些无回路子集中的最小值，那么 \(T\) 就叫做生成树（spanning tree）。最小生成树问题就是研究如何得到图的生成树的。常用的算法有Kruskal算法和Prim算法。它们的运行时间是 \(O(ElgV)\) 。如果使用斐波那契堆替换二叉堆，Prim算法可以达到 \(O(E+VlgV)\) 。
</p>


<p>
Kruskal算法的思路是：不断将权重最小的边加入到树中，直到树包含了全部顶点。它的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">Set</span> <span style="color: #FF6400;">mst_kruskal</span>(Graph &amp;g) {
        <span style="color: #8DA6CE;">Set</span> <span style="color: #FF6400;">set</span> = Set.empty;

        <span style="color: #FBDE2D;">for</span> (Vertex &amp;v: g.vertices()) {
                v.set_belong_set(Set.empty);
        }

        <span style="color: #8DA6CE;">List</span> <span style="color: #FF6400;">edges</span> = g.edges();
        edges.sort(Edge::weight, Order.increase); <span style="color: #AEAEAE; font-style: italic;">// </span><span style="color: #AEAEAE; font-style: italic;">&#25353;&#26435;&#37325;&#36882;&#22686;&#25490;&#24207;</span>
        <span style="color: #FBDE2D;">for</span> (Edge &amp;edge: edges) {
                Vertex &amp;u = edge.vertex1();
                Vertex &amp;v = edge.vertex2();
                <span style="color: #FBDE2D;">if</span> (u.get_belong_set() != v.get_belong_set()) {
                        set.add(edge);
                        u.set_belong_set(set);
                        v.set_belong_set(set);
                }
        }

        <span style="color: #FBDE2D;">return</span> set;
}
</pre>
</div>


<p>
Prim算法的原理是每次将距离树最近（权重最小）的节点加入树中。它的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8DA6CE;">void</span> <span style="color: #FF6400;">mst_prim</span>(Graph &amp;g) {
        <span style="color: #FBDE2D;">for</span> (Vertex &amp;v: g.vertices()) {
                v.set_key(Number.Infinite);
                v.set_parent(nullptr);
        }

        Vertex &amp;root = g.vertices().get(0);
        root.set_key(0);

        <span style="color: #8DA6CE;">PriorityQueue</span> <span style="color: #FF6400;">queue</span>;
        queue.add_all(g.vertices(), Vertex::get_key);
        <span style="color: #FBDE2D;">while</span> (!queue.is_empty()) {
                Vertex &amp;u = queue.min();
                queue.pop();
                <span style="color: #FBDE2D;">for</span> (Vertex &amp;v: u.neighbors()) {
                        <span style="color: #FBDE2D;">if</span> (queue.has_contain(v) &amp;&amp; g.get_edge(u,v).get_weight() &lt; v.get_key()) {
                                v.set_parent(u);
                                v.set_key(g.get_edge(u,v).get_weight()); <span style="color: #AEAEAE; font-style: italic;">// </span><span style="color: #AEAEAE; font-style: italic;">set_key&#20250;&#26356;&#26032;v&#22312;&#20248;&#20808;&#38431;&#21015;&#20013;&#30340;&#20301;&#32622;</span>
                        }
                }
        }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org071cf07" class="outline-3">
<h3 id="org071cf07">第二十四章 单源最短路径</h3>
<div class="outline-text-3" id="text-org071cf07">
<p>
两点之间的最短路径，也是路径上各点之间的最短路径。这表明最短路径具有最优子结构。
</p>

<p>
开始：p344
当前：p359
</p>

<p>
重读：8.4，9，11.3全域散列，11.4，红黑树，17章，19、20、21章。
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2019年09月25日</p>
<p class="date">Created: 2019-10-28 周一 19:45</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>

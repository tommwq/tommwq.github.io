<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-09-23 周一 21:12 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb948bbc">线程安全的对象生命期管理</a></li>
<li><a href="#org498d676">线程同步精要</a></li>
<li><a href="#org2124c40">多线程服务器的适用场景与常用编程模型</a></li>
<li><a href="#orgc577304">C++多线程系统编程精要</a></li>
<li><a href="#orge94e2c1">高效的多线程日志</a></li>
<li><a href="#org6c9ee41">moduo网络库简介</a></li>
<li><a href="#orgea367b2">muduo编程示例</a></li>
<li><a href="#org5832c73">muduo网络库设计与实现</a></li>
<li><a href="#org95f38a6">分布式系统工程实践</a></li>
<li><a href="#orgf467cbb">C++编译连接模型精要</a></li>
<li><a href="#org8209ff3">反思C++面向对象与虚函数</a></li>
<li><a href="#orgb57543d">C++经验谈</a></li>
<li><a href="#org4c4773c">附录</a></li>
</ul>
</div>
</div>
<p>
Linux多线程服务端编程笔记
</p>

<div id="outline-container-orgb948bbc" class="outline-2">
<h2 id="orgb948bbc">线程安全的对象生命期管理</h2>
<div class="outline-text-2" id="text-orgb948bbc">
<p>
编写线程安全的类需要使用同步原语保护其内部状态，通常将这个同步对象作为类的数据成员。但是对象的构造和析构不能由作为对象自身一部分的同步对象来保护。
多线程环境下面临的一个基本问题就是，如何安全的访问对象，或者说，在使用一个对象的过程中，如何保证对象是存在（没有被析构）和完整（已经构造完毕，且没有在析构中）的。
存在性检查相对简单，只要判断指针是否为空。完整性检查就比较复杂了。假设代码中没有缺陷，在C++中，改变对象完整性的操作有构造函数和析构函数。
因此，C++多线程编程首先要保证构造函数和析构函数没有竞态条件。对于构造函数，这一点比较容易满足，只要避免在对象构造完成前暴露this指针。
这里需要注意的是，在存在继承的情况下，构造函数运行到最后一行，也不能说明对象已经完成构造，可能只是实际对象中的基类子对象完成构造。
</p>


<p>
下面是两个例子，第一个例子中，对象尚未构造完毕就保留了this指针，这在多线程环境下是非常危险的。第二个例子则避免了这种情况。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b22222;">// </span><span style="color: #b22222;">&#20363;1</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">MyObserver</span>: <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Observer</span> {
<span style="color: #a020f0;">public</span>:
    <span style="color: #0000ff;">MyObserver</span>(<span style="color: #228b22;">Observable</span> *<span style="color: #a0522d;">observable</span>) {
        observable-&gt;<span style="color: #a020f0;">register</span>(<span style="color: #a020f0;">this</span>); <span style="color: #b22222;">// </span><span style="color: #b22222;">&#19981;&#22909;&#65292;&#23558;&#26410;&#23436;&#25104;&#21021;&#22987;&#21270;&#30340;&#23545;&#35937;&#25552;&#20379;&#32473;&#22806;&#37096;&#20351;&#29992;&#12290;</span>
    }
};
</pre>
</div>

<p>
// 例2
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">MyObserver</span>: <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Observer</span> {
<span style="color: #a020f0;">public</span>:
    <span style="color: #0000ff;">MyObserver</span>() {
    }

    <span style="color: #228b22;">void</span> <span style="color: #0000ff;">observe</span>(<span style="color: #228b22;">Observable</span> *<span style="color: #a0522d;">observable</span>) {
        observable-&gt;<span style="color: #a020f0;">register</span>(<span style="color: #a020f0;">this</span>);
    }
};

<span style="color: #228b22;">MyObserver</span> *<span style="color: #a0522d;">observer</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">MyObserver</span>();
observer-&gt;observe(observable);
</pre>
</div>

<p>
对于析构的情况，为了避免在析构过程中其他线程访问对象，必须将析构函数设置成临界区，这就需要信号量来进行保护。
同时，为了及时回收内存，也必须在适当的时候析构对象。
这就产生了一个方案：不再使用裸指针，而是使用有信号量和引用计数保护的智能指针。
shared<sub>ptr控制对象的生命周期</sub>，是一个带有计数器的强引用。当shared<sub>ptr析构或调用reset时</sub>，实际对象析构。
weak<sub>ptr不会控制对象的生命周期</sub>，但是知道对象是否有效。weak<sub>ptr可以提升为shared</sub><sub>ptr</sub>，如果对象有效，提升得到的shared<sub>ptr引用实际对象</sub>。这个提升过程是线程安全的。
shared<sub>ptr的计数器使用无锁操作</sub>，速度较快。shared<sub>ptr的引用计数是线程安全的</sub>，但是对其引用对象的读写，不保证线程安全性。
</p>

<p>
C++里的内存问题主要有：
</p>
<ul class="org-ul">
<li>缓冲器溢出。</li>
<li>空悬指针/野指针。</li>
<li>重复释放。</li>
<li>内存泄漏。</li>
<li>不匹配的new[]/delete</li>
<li>内存碎片。</li>
</ul>

<p>
智能指针可以解决前面5个问题。 
</p>


<p>
shared<sub>ptr在使用时</sub>，有几点需要注意：
</p>
<ul class="org-ul">
<li>延长对象生命周期。只要还有副本，对象就不会被释放。</li>
<li>函数参数。shared<sub>ptr作为参数传递时</sub>，会修改引用计数，成本较高。不过通常可以在外层函数使用shared<sub>ptr</sub>，内层函数直接使用由shared<sub>ptr保护的对象</sub>。</li>
<li>对象创建时绑定析构动作。这使得：
<ul class="org-ul">
<li>虚析构函数不再是必需的。</li>
<li>shared<sub>ptr</sub>&lt;void&gt;可以持有任何对象，并且能安全释放。</li>
<li>shared<sub>ptr对象可以跨越模块边界</sub>，比如从dll中返回，而不会出现模块A分配的内存由模块B释放的错误。</li>
<li>二进制兼容性。只要头文件中没有访问对象的inline函数，且对象由Factory构造，这时，即使对象大小变了，旧客户代码仍然可以使用新版本动态库。</li>
<li>析构动作可以定制。</li>
</ul></li>
<li>进行析构位置。对象的析构是同步的，当最后一个shared<sub>ptr离开作用域时</sub>，对象会进行析构。这有可能降低关键线程的性能。我们可以启动一个独立的线程负责对象析构，通过BlockingQueue&lt;shared<sub>ptr</sub>&lt;void&gt;&gt;将对象传递过去。</li>
<li>RAII handler。每个明确的资源配置动作（如new）都应在单一语句中执行，并立即将得到的资源交给handler对象（如shared<sub>ptr</sub>）。程序中一般不出现delete。shared<sub>ptr是管理共享资源的工具</sub>，但要注意避免循环引用。通常的方法是owner持有shared<sub>ptr</sub>&lt;Child&gt;，child持有weak<sub>ptr</sub>&lt;Owner&gt;。</li>
</ul>

<p>
如果一个类可以从this构造shared<sub>ptr指针</sub>，可以让这个类继承自std:enable<sub>shared</sub><sub>from</sub><sub>this</sub>，并通过shared<sub>from</sub><sub>this</sub>()得到智能指针。
</p>
</div>
</div>

<div id="outline-container-org498d676" class="outline-2">
<h2 id="org498d676">线程同步精要</h2>
<div class="outline-text-2" id="text-org498d676">
<p>
并发编程有2种模型：一种基于消息传递，一种基于共享内存。在多台服务器上多进程并行运行的系统中，主要使用基于消息传递的模型。
</p>

<p>
线程同步有一些经验原则：
</p>
<ul class="org-ul">
<li>降低共享对象大小，优先使用不可变对象。</li>
<li>使用高层级并发构件，如TaskQueue等。</li>
<li>如果需要低层级同步原语，尽量只使用非递归互斥体和条件变量。慎用读写锁和信号量。</li>
<li>除atomic外，避免编写lock-free代码。避免使用“内核级”同步原语。</li>
</ul>

<p>
互斥体（mutex）是最常用到的同步原语。互斥体保证最多一个线程进入临界区工作。互斥体的使用要遵守以下几个原则：
</p>
<ul class="org-ul">
<li>使用RAII封装互斥体的建立、销毁、加锁和解锁。</li>
<li>优先使用非递归（不可重入）互斥体。</li>
<li>避免手动调用lock/unlock，使用Guard对象保证互斥体的生命周期在同一个域（scope）中。</li>
<li>在构造Guard对象时必须考虑如何避免死锁。</li>
<li>不要在进程间共享mutex，使用TCP套接字进行IPC。</li>
<li>在加锁线程中解锁。</li>
<li>避免遗忘解锁。</li>
<li>避免重复解锁。</li>
</ul>


<p>
Linux的Pthreads mutex采用futex实现，不需要每次加解锁都执行系统调用。
</p>


<p>
对于需要锁保护的方法，最好使用extract method重构方法，写成
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">do_something_unsafe</span>() { ... }
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">do_something</span>() {
  <span style="color: #228b22;">lock_guard</span> <span style="color: #a0522d;">guard</span>(mutex);
  do_something_unsafe();
}
</pre>
</div>

<p>
条件变量的使用方法如下：
等待端：
</p>
<ul class="org-ul">
<li>使用互斥体保护。</li>
<li>在互斥体上锁时调用wait()。</li>
<li>wait()返回后仍然持有锁。</li>
<li>必须在while循环中调用wait()。// 避免惊群效应（spurious wakeup）。</li>
</ul>
<p>
唤醒/广播端：
</p>
<ul class="org-ul">
<li>signal表示资源可用。</li>
<li>broadcast表示状态变化。</li>
</ul>

<p>
条件变量通常不会直接使用，而是作为实现高层同步数据结构（如BlockingQueue、CountDownLatch）的基础。互斥体和条件变量构成了多线程编程的全部必备同步原语，使用它们可以完成任何多线程同步任务。
</p>


<p>
在实际开发中，读写锁的作用很小，完全可以使用互斥体替代。读写锁的问题在于：
</p>
<ul class="org-ul">
<li>在维护阶段，容易在持有读锁时修改共享数据，导致状态一致性被破坏。</li>
<li>在性能方面，由于要维护读线程数量，读锁的性能未必比互斥体更好。在竞争激烈的情况下可能更糟。</li>
<li>通常，读锁是可重入的，写锁不可重入。为了防止饥饿，写锁会阻塞后续的读锁请求，因此读锁在重入是可能导致死锁，程序延迟也会增加。</li>
</ul>


<p>
LockGuard对象必须是具名对象，否则可能被当做临时变量优化掉，没有起到保护临界区的效果：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #a020f0;">do</span>() {
    LockGuard(mutex); <span style="color: #b22222;">// </span><span style="color: #b22222;">&#38169;&#35823;</span>
    <span style="color: #228b22;">LockGuard</span> <span style="color: #a0522d;">g</span>(mutex); <span style="color: #b22222;">// </span><span style="color: #b22222;">&#27491;&#30830;&#12290;</span>
}
</pre>
</div>

<p>
为了避免这种错误用法，可以定义一个宏进行保护
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">LockGard</span>(<span style="color: #a0522d;">x</span>) static_assert(<span style="color: #008b8b;">false</span>, <span style="color: #8b2252;">"missing mutex guard variable name"</span>)
</pre>
</div>

<p>
C++中的单例可以用pthread<sub>once来实现只执行一次的语义</sub>。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">template</span>&lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>&gt;
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Singleton</span>: <span style="color: #008b8b;">boost</span>::<span style="color: #228b22;">noncopyable</span> {
<span style="color: #a020f0;">public</span>:
    <span style="color: #a020f0;">static</span> <span style="color: #228b22;">T</span>&amp; <span style="color: #0000ff;">instance</span>() {
        pthread_once(&amp;ponce_, &amp;<span style="color: #008b8b;">Singleton</span>::init);
        <span style="color: #a020f0;">return</span> *value_;
    }

<span style="color: #a020f0;">private</span>:
    <span style="color: #0000ff;">Singleton</span>();
    ~<span style="color: #0000ff;">Singleton</span>();

    <span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">init</span>() {
        value_ = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">T</span>();
    }
<span style="color: #a020f0;">private</span>:
    <span style="color: #a020f0;">static</span> <span style="color: #228b22;">pthread_once_t</span> <span style="color: #a0522d;">ponce_</span>;
    <span style="color: #a020f0;">static</span> <span style="color: #228b22;">T</span>* <span style="color: #a0522d;">value_</span>;
};

<span style="color: #a020f0;">template</span>&lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>&gt;
<span style="color: #228b22;">pthread_once_t</span> <span style="color: #008b8b;">Singleton</span>&lt;<span style="color: #228b22;">T</span>&gt;::<span style="color: #a0522d;">ponce_</span> = PTHREAD_ONCE_INIT;

<span style="color: #a020f0;">template</span>&lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>&gt;
<span style="color: #228b22;">T</span>* <span style="color: #008b8b;">Singleton</span>&lt;<span style="color: #228b22;">T</span>&gt;::<span style="color: #a0522d;">value_</span> = <span style="color: #008b8b;">NULL</span>;

<span style="color: #228b22;">Foo</span>&amp; <span style="color: #a0522d;">foo</span> = <span style="color: #008b8b;">Singleton</span>&lt;<span style="color: #228b22;">Foo</span>&gt;::instance();
</pre>
</div>
</div>
</div>

<div id="outline-container-org2124c40" class="outline-2">
<h2 id="org2124c40">多线程服务器的适用场景与常用编程模型</h2>
<div class="outline-text-2" id="text-org2124c40">
<p>
线程的特点是共享地址空间。多线程的作用在于充分发挥多核处理器的效能。
</p>

<p>
单线程服务器常用编程模型：
</p>
<ul class="org-ul">
<li>reactor模式：非阻塞IO+IO多路复用。事件驱动。轮询事件，调用相应处理函数。缺点：业务逻辑割裂。</li>
<li>proactor模式：在事件发生后，系统调用回调函数。</li>
</ul>

<p>
多线程常用编程模型：
</p>
<ul class="org-ul">
<li>thread per request/connection</li>
<li>线程池+阻塞IO。</li>
<li>非阻塞IO+IO多路复用。</li>
<li>leader/follower</li>
</ul>

<p>
对于常见的服务器软件，建议使用多线程模式中的第三种，即非阻塞IO+one loop per thread。这个模型简单描述如下：
</p>
<ul class="org-ul">
<li>每个IO线程由一个事件循环，用于处理读写事件和定时事件。</li>
<li>线程数目基本固定。</li>
<li>便于在线程间调配负载。</li>
<li>IO事件绑定在线程上，同一个TCP连接不需要考虑事件并发。</li>
<li>对于没有IO的计算线程，从阻塞队列中读取任务并执行。</li>
</ul>

<p>
单线程模型优点：结构简单。缺点：event loop是非抢占的。单线程适合于批处理和计算密集型。吞吐量高。多线程适合于多任务，延迟低。和单线程IO多路复用相比，多线程不能提高并发连接数，但是在同样并发连接数下，提供更低的延迟。对于计算密集型任务，多线程不能提高吞吐量。多线程适合于应对突发（burst）请求，可以提高吞吐量，降低响应时间。对于多线程任务，建议使用一个独立的日志线程。
</p>

<p>
关于进程间通信的方案选择，除非由特殊需求，最好统一采用TCP套接字。TCP协议的好处有：
</p>
<ul class="org-ul">
<li>可以跨主机，伸缩性好。</li>
<li>可记录、可重现。</li>
<li>跨语言。</li>
</ul>

<p>
对于服务器程序的设计，通常有4中方案：
</p>
<ul class="org-ul">
<li>一个单线程进程。</li>
<li>一个多线程进程。</li>
<li>多个单线程进程。</li>
<li>多个多线程进程。</li>
</ul>

<p>
第一种方案不具有可伸缩性，不能发挥多核处理器的能力。第三个方案是较为主流的方案，又可以分为两种：
</p>
<ul class="org-ul">
<li>对等进程。</li>
<li>控制-工作进程。</li>
</ul>

<p>
要如何选择合适的方案呢？首先要考虑程序是IO bound还是CPU bound的。
这两种程序，多线程相比单线程没有太多优势，反而存在编码复杂、易出错的缺点。
单线程的优点是编码简单，但是由于事件循环的非抢占特点，可能导致优先级翻转。
通常对于以下的情况，必须使用单线程：
</p>
<ul class="org-ul">
<li>程序会调用fork。</li>
<li>限制程序的CPU使用率。</li>
</ul>

<p>
而多线程程序适用的场景是：提高响应速度，将IO和计算相互重叠，降低延迟。多线程可以提供平均响应性能。
在多线程程序中，线程可以分为三类：
</p>
<ul class="org-ul">
<li>IO线程。主循环是IO多路复用，处理读写事件和定时事件，以及消息的编码和解码。</li>
<li>计算线程。从阻塞队列中获取任务并执行。</li>
<li>支持线程。如日志、数据库连接等第三方库使用的线程。</li>
</ul>

<p>
所有网络写操作都可以异步执行。但是这么做每次都要在线程之间传递数据。Netty采用了一种优化方法，如果TCP缓冲区是空的，会在工作线程中执行写操作。这样可以进一步降低延迟。
</p>
</div>
</div>

<div id="outline-container-orgc577304" class="outline-2">
<h2 id="orgc577304">C++多线程系统编程精要</h2>
<div class="outline-text-2" id="text-orgc577304">
<p>
多线程开发时必须时刻意识到，看上去顺序执行的代码，可能随时被其他线程抢占（preempt）。
因此除非特殊处理，从全局上看，无法保证事件的顺序。
对于多线程程序，重要的是定义内存模型，并证明在该内存模型下，程序的行为是正确的。
内存模型中比较重要的是内存顺序（memory ordering），也叫内存可见性（memory visibility）。
它定义了一个线程对共享变量的修改何时可以被其他线程观察到。
</p>


<p>
在Linux上，要标识一个线程时，使用gettid()比pthread<sub>t更好</sub>。
gettid()返回的是pid<sub>t</sub>，这是一个整数，并且是内核调度编号，可以在/proc/tid或/proc/pid/task/tid中找到。
它是操作系统唯一的。pthread<sub>t的缺点在于</sub>，无法打印输出，无法和系统的任务调度关联，并且存在pthread<sub>t复用的情况</sub>。
muduo库通过将结果缓存在变量中的方式，避免反复调用gettid()。为了处理fork()的情况，
通过pthread<sub>atfork</sub>()注册回调函数，清理缓存的线程编号。
</p>


<p>
在执行exit()时，C++会析构全局对象，因此不是线程安全的。在多线程环境下，
一个文件描述符（包括TCP套接字）只应该由一个线程操作。否则消息收发的顺序性难以保证。
对于UDP套接字，这种限制可以放宽。Linux文件描述符是位于地址空间中，用于标识已经打开的文件的整数。Linux分配文件描述符的策略是选择最小可用整数。
在一个文件描述符回收后，后续的分配申请会复用这个整数。
假设文件描述符F发生了复用，先后关联到文件a.txt和b.txt。在多线程环境下，如果管理不当，就会出现线程试图向a.txt写入数据，但却写入到b.txt的情况。
这会导致b.txt的数据一致性遭到破坏。Linux程序初始会分配3个文件描述符，它们是标准输入（1）、标准输出（2）和标准错误（3）。
有些第三方库在紧急情况下会使用标准输出和标准错误。为了避免前面提到的情况，程序不应关闭这3个文件描述符。
可以将它们重定向到文件，以免遗失第三方库输出的重要信息。由于套接字也是文件描述符，在编写C++多线程程序时，不能简单的用套接字来标识连接，
需要封装到Connection对象中，并用shared<sub>ptr在线程间共享</sub>。
</p>


<p>
多线程程序中调用fork()是非常危险的操作。fork()之后，子进程只有一个线程，如果父进程的其他线程在fork()之前持有锁，子进程将无法解锁。
而且子进程会也会调用父进程中对象的析构函数。如果这个对象引用了某种系统资源，而这种资源没有被子进程所继承，析构函数的行为是难以预料的。
</p>


<p>
多线程程序处理信号也非常复杂。首先，和单线程程序一样，信号处理函数必须是可重入的。如果处理函数修改了全局变量，这个变量必须是sig<sub>atomic</sub><sub>t类型</sub>，
否则被打断的函数在恢复后无法立即观察到变量的值。此外，在多线程环境下，必须考虑发给特定线程的信号、发给进程的信号，以及信号掩码的处理。
因此应当避免使用信号。如果必须处理信号，可以使用signalfd，把信号转换为文件描述符事件。
</p>
</div>
</div>

<div id="outline-container-orge94e2c1" class="outline-2">
<h2 id="orge94e2c1">高效的多线程日志</h2>
<div class="outline-text-2" id="text-orge94e2c1">
<p>
日志可以分为诊断日志（diagnostic log）和交易日志（transaction log）。通常程序中提到的日志都是诊断日志，
是为了了解程序运行情况，诊断故障而输出的文本信息。数据库库和文件系统中的提到的日志通常是交易日志，
即记录对象变化历史的记录。这里提到的日志指的是诊断日志。常见的日志库设计通常分为前端和后端。
前端是提供给应用程序的编程接口（API），负责生成日志消息。后端把日志消息写入磁盘。在多线程环境下，通常每个线程
拥有私有的前端，同时共用一个后端。这是一个典型的多生产者单消费者的问题。对前端而言，需要的是低延迟，低CPU开销、
无阻塞。对后端而言，需要的是高吞吐量，低资源消耗。
</p>


<p>
日志的基础功能需求有：
</p>
<ul class="org-ul">
<li>多级别。如TRACE、DEBUG、INFO、WARN、ERROR、FATAL。</li>
<li>多目的。如文件、套接字等。</li>
<li>消息格式可配置。</li>
<li>可过滤。控制不同组件日志的级别和目的。</li>
</ul>

<p>
为了便于调试和维护，日志级别的调整应该不需要重启程序。对于分布式系统而言，日志的目的只有一个，即本地文件。
向其他目的写日志，都会放大单机故障。而已本地文件为目的时，日志需要支持滚动和归档。为了避免日志丢失，
muduo采取了两个策略，一是定时刷写磁盘，二是将内存中的日志消息加上cookie（也加sentry）。
cookie的值是某个函数的地址。当程序崩溃时，从核心转储文件中可以恢复尚未写入磁盘的日志。在实现日志库时还有
一些技巧，比如：
</p>
<ul class="org-ul">
<li>每个日志尽量只占一行，以支持awk、sed、grep等工具。</li>
<li>在获取时间时，使用gettimeofday()。这个函数不会进行内核态切换。</li>
<li>使用GMT时区。</li>
<li>打印线程ID。</li>
<li>打印日志级别。</li>
<li>打印源文件和行号。</li>
</ul>

<p>
muduo将日志库后端放到单独的线程中，并使用双缓冲（double buffering）技术提高效率。后端准备两个缓冲区。
前端向其中一个缓冲区写入数据，同时后端将另一个缓冲区的日志写入磁盘。每当刷写完毕，或者收到定时事件，将两个缓冲区交换。
如果两个缓冲区都填满，再分配一个缓冲区记录日志。如果前端产生日志的速度太快，后端会直接丢失部分日志以进行自我保护。
</p>
</div>
</div>

<div id="outline-container-org6c9ee41" class="outline-2">
<h2 id="org6c9ee41">moduo网络库简介</h2>
<div class="outline-text-2" id="text-org6c9ee41">
<p>
编写高性能并发网络服务程序的主流模式是基于事件的非阻塞网络编程。TCP网络编程的本质是处理三个半事件：
</p>
<ul class="org-ul">
<li>连接的建立。包括服务端接受新连接和客户端成功发起连接。</li>
<li>连接的断开。包括主动断开（close、shutdown）和被动断开（read返回0）。</li>
<li>消息到达（或文件描述符可读）。</li>
<li>消息发送完毕（算半个事件）。</li>
</ul>

<p>
在处理这些事件时，有些细节需要考虑：
</p>
<ul class="org-ul">
<li>如果是主动断开连接，如何保证对方已经收到全部数据？</li>
<li>如果主动发起连接，对方主动拒绝，如何定期（带back-off）重试？</li>
<li>应当使用边缘触发（edge trigger）还是水平触发（level trigger）？</li>
<li>如果使用水平触发，什么时候要关注EPOLLOUT事件？会不会造成busy-loop？</li>
<li>如果使用边缘触发，如何防止漏读造成的饥饿？</li>
<li>如果使用应用层缓冲区，要发送的输出超过缓冲区剩余容量怎么办？</li>
<li>如果一次读取的数据不是完整的数据包，将如何保存这些数据？</li>
<li>如何合理的设计缓冲区，以同时降低系统调用次数和内存占用？</li>
<li>如何进行应用层流量控制？</li>
<li>如何设计定时器，并避免锁？</li>
</ul>


<p>
常见网络服务开发方案如下：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">并发模型</td>
<td class="org-left">多进程</td>
<td class="org-left">多线程</td>
<td class="org-left">阻塞IO</td>
<td class="org-left">IO多路复用</td>
<td class="org-left">长连接</td>
<td class="org-left">并发性</td>
<td class="org-left">多核</td>
<td class="org-left">开销</td>
<td class="org-left">互通</td>
<td class="org-left">顺序性</td>
<td class="org-left">线程数</td>
<td class="org-left">特点</td>
</tr>

<tr>
<td class="org-left">accept+read/write</td>
<td class="org-left">N</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">N</td>
<td class="org-left">N/A</td>
<td class="org-left">N</td>
<td class="org-left">低</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">常数</td>
<td class="org-left">一次服务一个客户</td>
</tr>

<tr>
<td class="org-left">accept+fork</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">低</td>
<td class="org-left">Y</td>
<td class="org-left">高</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">变化</td>
<td class="org-left">process-per-connection</td>
</tr>

<tr>
<td class="org-left">accept+thread</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">中</td>
<td class="org-left">Y</td>
<td class="org-left">中</td>
<td class="org-left">Y</td>
<td class="org-left">Y</td>
<td class="org-left">变化</td>
<td class="org-left">thread-per-connection</td>
</tr>

<tr>
<td class="org-left">prefork</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">低</td>
<td class="org-left">Y</td>
<td class="org-left">高</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">变化</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">pre threaded</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">中</td>
<td class="org-left">Y</td>
<td class="org-left">中</td>
<td class="org-left">Y</td>
<td class="org-left">Y</td>
<td class="org-left">变化</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">poll (reactor)</td>
<td class="org-left">N</td>
<td class="org-left">N</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">Y</td>
<td class="org-left">高</td>
<td class="org-left">N</td>
<td class="org-left">低</td>
<td class="org-left">Y</td>
<td class="org-left">Y</td>
<td class="org-left">常数</td>
<td class="org-left">单线程reactor</td>
</tr>

<tr>
<td class="org-left">reactor + thread-per-task</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">Y</td>
<td class="org-left">中</td>
<td class="org-left">Y</td>
<td class="org-left">中</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">变化</td>
<td class="org-left">thread-per-request</td>
</tr>

<tr>
<td class="org-left">reactor + worker thread</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">Y</td>
<td class="org-left">中</td>
<td class="org-left">Y</td>
<td class="org-left">中</td>
<td class="org-left">Y</td>
<td class="org-left">Y</td>
<td class="org-left">变化</td>
<td class="org-left">worker-thread-per-connection</td>
</tr>

<tr>
<td class="org-left">reactor + thread poll</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">Y</td>
<td class="org-left">高</td>
<td class="org-left">Y</td>
<td class="org-left">低</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">常数</td>
<td class="org-left">主线程IO，工作现场工作</td>
</tr>

<tr>
<td class="org-left">reactors in threads</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">Y</td>
<td class="org-left">高</td>
<td class="org-left">Y</td>
<td class="org-left">低</td>
<td class="org-left">Y</td>
<td class="org-left">Y</td>
<td class="org-left">常数</td>
<td class="org-left">one loop per thread</td>
</tr>

<tr>
<td class="org-left">reactors in process</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">Y</td>
<td class="org-left">高</td>
<td class="org-left">Y</td>
<td class="org-left">低</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">常数</td>
<td class="org-left">nginx</td>
</tr>

<tr>
<td class="org-left">reactors + thread pool</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">Y</td>
<td class="org-left">Y</td>
<td class="org-left">高</td>
<td class="org-left">Y</td>
<td class="org-left">低</td>
<td class="org-left">Y</td>
<td class="org-left">N</td>
<td class="org-left">常数</td>
<td class="org-left">灵活的IO和CPU配置</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgea367b2" class="outline-2">
<h2 id="orgea367b2">muduo编程示例</h2>
<div class="outline-text-2" id="text-orgea367b2">
<p>
在处理长连接TCP分包时有四种方法：
</p>
<ul class="org-ul">
<li>消息长度固定。</li>
<li>使用特殊字符作为边界。如HTTP中的"\r\n"。</li>
<li>头部增加消息长度。</li>
<li>使用消息本身的格式。如XML消息中的&lt;root&gt;&#x2026;&lt;/root&gt;或JSON中的{&#x2026;}。</li>
</ul>

<p>
Unix/Linux有5个IO模型：
</p>
<ul class="org-ul">
<li>阻塞</li>
<li>非阻塞</li>
<li>IO多路复用</li>
<li>信号驱动</li>
<li>异步IO</li>
</ul>

<p>
muduo的缓冲区设计如下：在栈上分配一个65536字节的extrabuf，通过readv读取数据。readv的原型如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;sys/uio.h&gt;</span>

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">iovec</span> {
    <span style="color: #228b22;">void</span>* <span style="color: #a0522d;">iov_base</span>;
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">iov_len</span>;
};

<span style="color: #228b22;">ssize_t</span> <span style="color: #0000ff;">readv</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">fd</span>, <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">iovec</span>* <span style="color: #a0522d;">iov</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">iovcnt</span>);
</pre>
</div>

<p>
muduo传递给readv的iovec对象有2个，第一个指向muduo Buffer对象中缓冲区尾部，
第二个指向本地栈上的extrabuf。如果收到的数据不多，muduo Buffer对象的剩余空间就可以容纳。否则将extra追加到Buffer对象中。
这么做可以避免反复调用read()的开销。如果栈空间紧张，可以把extrabuf做成thread<sub>local</sub>。muduo采用水平触发，避免反复调用read()。
Buffer对象内部有两个索引：readIndex和writeIndex。它们将缓冲区分为3个部分：prependable、readable和writable。
prependable块是预留给序列化使用的。如果消息头包含消息体长度，在序列化时，将消息头写入prependable，将消息体写入readable，
然后将消息体的长度写入消息头，并移动readIndex，将其指向消息头。随着readIndex的移动，prependable空间不断增长，writable空间不断减少。
当收到新数据是，如果prependable+writable空间足够大，而writable又不足以容纳数据，这时需要移动readable数据，将prependable重置为初始大小。
muduo在线程之间传递数据时采用的是拷贝。这里存在一个优化点，改用交换（swap）性能表现更好。
</p>


<p>
如果对性能有极高的要求，可以用zero copy buffer配合gather scatter IO。思路是将一个大缓冲区拆解为一组小缓冲区组成的链表，
通过一次系统调用，读取全部数据。这么做到缺点是解析消息变得复杂。如果采用Google Protobuf进行序列化，可以实现接口ZeroCopyInputStream，
让Protobuf Message取处理缓冲区不连续的问题。
</p>


<p>
下面简单计算一下千兆网卡的最大吞吐量。如果不考虑jumbo frame，千兆网卡每秒可以传输1000M bit，即125 000 000 B/s。
每个以太网帧的固定开销有：
</p>
<ul class="org-ul">
<li>preamble 8B</li>
<li>MAC 12B</li>
<li>type 2B</li>
<li>payload 46B - 1500B</li>
<li>CRC 4B</li>
<li>gap 12B</li>
</ul>
<p>
最小的以太网帧是84B，每秒可以发送1 488 000 帧。因此对于一问一答式的RPC，QPS上线是约700k/s。最大的以太网帧是1538B，每秒可以发送
81 274帧。一个TCP segment包含IP头20B和TCP头20B，以及时间戳选项12B，因此TCP的最大吞吐量是81 274 * (1500 - 52) = 117MB/s，
合112MiB/s。
</p>


<p>
ProtoBuffer可以根据类型名创建对象。步骤如下：
</p>
<ul class="org-ul">
<li>调用DescriptorPool::generated<sub>pool</sub>()获得DescriptorPool对象。它包含了编译时所链接的全部消息类型。</li>
<li>将消息类型名传递给DescriptorPool::FindMessageTypeByName()，得到类型相关的Descriptor对象。</li>
<li>调用MessageFactory::generated<sub>factory</sub>()得到MessageFactory对象，它可以建立消息对象。</li>
<li>通过MessageFactory::GetPrototype()得到消息的默认实例。</li>
<li>通过prototype-&gt;New()创建消息对象。</li>
</ul>

<p>
如果一个连接允许传递多种类型的ProtoBuffer消息，就需要一个消息分发器，把消息投递给需要的模块。在muduo中，
ProtobufDispatcher就是这样一个角色。模块将回调函数注册到分发器。分发器收到消息后，根据消息描述符，找到并执行回调函数。
由于每个模块处理的消息不同，muduo采用了一种叫做模板化派生类（templated derived class）的技术，代码示例如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Callback</span> {
<span style="color: #a020f0;">public</span>:
    <span style="color: #228b22;">void</span> <span style="color: #0000ff;">onMessage</span>(<span style="color: #228b22;">Message</span>*);
};

<span style="color: #a020f0;">template</span>&lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>&gt;
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">CallbackT</span> {
<span style="color: #a020f0;">public</span>:
    <span style="color: #228b22;">void</span> <span style="color: #0000ff;">onMessage</span>(<span style="color: #228b22;">Message</span> *<span style="color: #a0522d;">messag</span>) <span style="color: #a020f0;">override</span> {
        callback(<span style="color: #a020f0;">dynamic_cast</span>&lt;<span style="color: #228b22;">T</span>*&gt;(message));
    }
<span style="color: #a020f0;">private</span>:
    <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">function</span>&lt;<span style="color: #228b22;">void</span>(<span style="color: #228b22;">T</span>*)&gt; <span style="color: #a0522d;">callback</span>;
};

<span style="color: #a020f0;">class</span> <span style="color: #228b22;">ProtobufDispatcher</span> {
<span style="color: #a020f0;">public</span>:
    <span style="color: #228b22;">void</span> <span style="color: #0000ff;">onMessage</span>(<span style="color: #228b22;">Message</span>*);

    <span style="color: #a020f0;">template</span>&lt;<span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span>&gt;
    <span style="color: #0000ff;">registerCallback</span>(<span style="color: #228b22;">Descriptor</span>*, <span style="color: #228b22;">CallbackT</span>&lt;<span style="color: #228b22;">T</span>&gt;);
<span style="color: #a020f0;">private</span>:
    <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">map</span>&lt;<span style="color: #228b22;">Descriptor</span>*, <span style="color: #228b22;">Callback</span>*&gt; <span style="color: #a0522d;">table</span>;
};
</pre>
</div>

<p>
文件描述符是一种稀缺资源，并且文件描述符耗尽的情况非常难以处理。为了保护服务器，应该限制最大并发连接数。
如果文件描述符耗尽，accept()将返回EMFILE。由于无法为新连接分配文件描述符，我们无法close()它。如果置之不理，
epoll认为存在尚未处理的新连接，epoll<sub>wait</sub>()会立即返回，程序陷入busy loop。针对这种情况，libev的作者Marc Lehmann提出：
</p>
<ul class="org-ul">
<li>提高fd数量。这种方案指标不治本。一旦客户端数量增加，文件描述符迟早会消耗尽。</li>
<li>死等。鸵鸟算法。</li>
<li>退出程序。小题大做。</li>
<li>关闭listening fd。何时重新打开呢？又是一个难题。</li>
<li>改用edge trigger。但如果漏掉一次accept(2)，后续再无法收到新连接。</li>
<li>准备一个空闲的fd。关闭空间fd，让accept得到文件描述符，然后立即close()新连接。接着再次打开一个空闲文件。</li>
</ul>

<p>
如果在服务端限制最大并发连接数，就可以避免上述各种复杂的方案。
</p>


<p>
在服务端程序中，和时间相关的任务有：
</p>
<ul class="org-ul">
<li>获取当前时间，计算时间间隔。</li>
<li>时区转换和日期计算。</li>
<li>定时操作。</li>
</ul>

<p>
非高精度计时可以使用gettimeofday，它的精度是1微妙，满足大部分需要，而且不是系统调用，不会产生上下文切换和内核开销。
时区转换和日期计算可以用Julian Day Number。而定时操作可以通过timerfd完成。
</p>


<p>
两台服务器之间的网络延迟也叫做RTT（round trip time）。测量RTT的方法如下：
</p>
<ul class="org-ul">
<li>服务器A发送消息给服务器B，包含服务器A的本地时间。</li>
<li>服务器B收到消息后，将原始消息直接返回给服务器A。</li>
<li>服务器A收到消息后，用系统当前时间减去消息中的时间，就得到了RTT。</li>
</ul>

<p>
NTP协议在计算RTT时稍有不同。假设服务器A发送消息和收到应答的本地时间分别是T1和T4，服务器B收到消息和发送消息的本地时间分别是T2和T3，
则RTT=(T4-T1)-(T3-T2)，两个服务器的时间戳clock offset=[(T4+T1)-(T2+T3)]/2。
如果服务器B收到消息后立即应答，T3=T2，这时两种算法是一样的。
</p>


<p>
处理连接超时的一个有力工具是timing wheel。timing wheel是一个环形队列，长度是超时的秒数。
有一个指针指向队列尾部，当新的连接建立时，将连接放到当前的格子中。如果某个连接有读事件发生，也把它放到当前格子里。
指针每秒钟移动一格，将新格子中的连接都是超时连接，需要断开。muduo没有把Connection对象直接放到timing wheel中，而是
封装了一个Entry对象。Entry持有weak<sub>ptr</sub>&lt;Connection&gt;，timing wheel持有shared<sub>ptr</sub>&lt;Entry&gt;。
这样，当timing wheel把格子清空时，shared<sub>ptr</sub>&lt;Entry&gt;的计数归0，析构Entry对象。在这个过程中，如果Entry发现连接仍然可用，将会断开连接。
</p>


<p>
另外一种处理超时的方法是将Connection对象链接起来，按照读事件发生时间排序。每次收到消息，将Connection对象放到链表尾部。
然后定时从链表头部找出并移除超时连接。
</p>
</div>
</div>

<div id="outline-container-org5832c73" class="outline-2">
<h2 id="org5832c73">muduo网络库设计与实现</h2>
</div>
<div id="outline-container-org95f38a6" class="outline-2">
<h2 id="org95f38a6">分布式系统工程实践</h2>
<div class="outline-text-2" id="text-org95f38a6">
<p>
分布式系统的本质困难在于partial failure。比如一次RPC调用超时，调用方无法区分：
</p>
<ul class="org-ul">
<li>是网络故障还是对方服务器崩溃？</li>
<li>是软件错误还是硬件错误？</li>
<li>是发送失败还是接收失败？</li>
<li>对方是否收到请求，能否重试？</li>
</ul>

<p>
这些情况不是RPC独有的，而是分布式系统的固有特性。
</p>


<p>
考虑一个缩略图（thumbnailer）服务，它将用户上传的图片缩小为固定尺寸。假设系统中有多台Web服务器，连接到多台Thumbnailer服务器。
在这个系统中，如何进行负载均衡呢？下面是4种常见的做法：
</p>
<ul class="org-ul">
<li>每个Web轮训Thumbnail服务器。可能导致“潮涌”现象。</li>
<li>每个Web随机选择Thumbnail服务器。无法避免潮涌。</li>
<li>Thumbnail定期向Web汇报负载情况。导致每个周期发送M*N条消息。伸缩性差。</li>
<li>一个集中的负载均衡器收集并分发负载情况。存在单点故障。（Single Point of Failure，SPoF）</li>
</ul>


<p>
更合理的做法是放弃全局负载这个概念，从Web的视角出发，让Web选择自己视角下负载最小的Thumbnail服务器。
Web把Thumbnail看做一个环形队列，一开始循环分配任务，记录下自己对每个Thumbnail产生的负载，选择负载较小的服务器。算法如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">int</span> <span style="color: #0000ff;">selectLeastLoad</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">vector</span>&lt;Endpoint&gt;&amp; <span style="color: #a0522d;">endpoints</span>, <span style="color: #228b22;">int</span>* <span style="color: #a0522d;">last</span>) {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">N</span> = endpoints.size();
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">start</span> = (*last + 1) % N;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">min_load_idx</span> = start;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">min_load</span> = endpoints[start].active_reqs();

    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; N; ++i) {
        <span style="color: #228b22;">int</span> <span style="color: #a0522d;">idx</span> = (start + i) % N;
        <span style="color: #228b22;">int</span> <span style="color: #a0522d;">load</span> = endpoints[idx].active_reqs();

        <span style="color: #a020f0;">if</span> (load &lt; min_load) {
            min_load = load;
            min_load_idx = idx;
            <span style="color: #a020f0;">if</span> (min_load == 0) {
                <span style="color: #a020f0;">break</span>;
            }
        }
    }

    *last = min_load_idx;
    <span style="color: #a020f0;">return</span> min_load_idx;
}
</pre>
</div>

<p>
为了避免潮涌，Web服务器选择last值时应该具有足够的随机性。
</p>


<p>
分布式系统的另一个问题是不存在全局顺序。不同节点观察到的事件发生顺序也不同。
</p>


<p>
下面讨论分布式系统的可靠性。可靠性的定义如下：
</p>
<blockquote>
<p>
可靠性Reliability = exp(- t/MTBF)
</p>
</blockquote>
<p>
公式里的t是系统运行事件，MTBF时平均无故障运行时间（单位小时）。系统发生故障的概率等于1-可靠性。比如当t=MTBF时，
可靠性是36.8%，系统故障的概率是63.2%。可用性（availability）是服务随时可访问的概率。可用性定义为：
</p>
<blockquote>
<p>
可用性Availability = MTBF/(MTBF+MTTR)
</p>
</blockquote>
<p>
其中MTTR是平均修复时间。在分布式系统中，高可用的关键是允许随时重启任何一个进程，通弄过容错策略让系统整体保持可用。
所以在协议设计上要避免对单个进程提出过高的可用性要求。比如在IPC选择上，不要使用生命周期大于进程或无法重建的IPC。
</p>


<p>
使用TCP进行进程间通信时，应用层心跳包是必不可少的。判断连接故障的唯一可靠方法是检查心跳超时。因为如果服务器重启或网络故障，
无法保证FIN包的发送和接收。在设计心跳包时，要容忍网络消息延迟和定时器波动。为了避免误报，超时时间通常选择为心跳时间的2倍。
如果sender和receiver中间存在业务级别的proxy，心跳包中应该加入发送方时间，避免消息堆积而导致假心跳。
proxy也应该丢弃失效的心跳包，避免消息堆积。为了防止伪心跳，心跳和业务消息在一个连接中发送，
不要单独启动心跳线程和心跳连接。否则可能出现工作线程故障，而心跳包可以正常发送的情况。
</p>


<p>
现在考虑如何在分布式系统中，唯一标识一个进程实例。最简单的方法是采用&lt;ip,port&gt;。如果进程是无状态的，可以把重启前后的实例看成是同一个，
这么做是可以的。如果进程是有状态的，&lt;ip,port&gt;无法处理重启的情况，所以还要加上本地进程编号pid。考虑到pid可能复用，
更稳妥的方法是加入进程启动时间，采用&lt;ip,port,pid,start<sub>time</sub>&gt;作为实例的唯一编号。
在分布式系统中，为了观察长期运行实例的状态，每个实例都会提供一个管理接口，以TCP服务器的方式向外暴露。
如果一个进程作为客户端运行，不会侦听某个端口，可以使用管理接口的端口作为编号的port部分。
</p>


<p>
现在说一下管理接口。为了了解实例的状态，最好在管理接口中报告：
</p>
<ul class="org-ul">
<li>累计接收TCP连接数。</li>
<li>当前活动连接数。</li>
<li>当前活动连接的用途。</li>
<li>累计响应请求数。</li>
<li>请求及应答平均数据长度。</li>
<li>请求平均响应时间。</li>
<li>并发请求数均值。</li>
<li>并发请求数峰值。</li>
<li>各连接平均活动请求数。</li>
<li>XXXRequest对象实体数量。</li>
<li>数据库连接数及连接平均存活时间。</li>
<li>当前活动请求信息。</li>
<li>当前长期存活请求信息。</li>
</ul>


<p>
在分布式系统中，单元测试存在以下的不足：
</p>
<ul class="org-ul">
<li>阻碍大型重构。</li>
<li>破坏代码整体性。</li>
<li>往往需要mock。</li>
<li>failure场景难以测试，如网络中断、数据库超时、资源不足。</li>
<li>多线程难以测试。</li>
</ul>

<p>
所以在分布式系统中，class/function级别的测试用处不大。更好的工具是test harness，即为被测试程序模拟一个环境，隔断其于其他程序的联系，冒充这些程序。
分布式系统测试主要测试进程之间的交互，多个线程是如何协作的。
</p>


<p>
对于分布式系统的管理，需要将机群管理和名字服务结合。机群规模增加到一定程度后，发生故障的频率增加，此时必须支持自动化快速故障转移（failover）。
而故障转移需要名字服务的支持。采用名字服务而非DNS的原因主要有两点，首先DNS是轮询式的，更新缓慢。第二，DNS无法解析端口号。
名字服务将服务名解析成&lt;ip,port&gt;列表，并在服务实例启动或失败后，将系统变化推送给使用者。
</p>
</div>
</div>

<div id="outline-container-orgf467cbb" class="outline-2">
<h2 id="orgf467cbb">C++编译连接模型精要</h2>
<div class="outline-text-2" id="text-orgf467cbb">
<p>
使用g++时建议的编译参数 -Wall -Wextra -Werror -Wconversion -Wshadow。
</p>


<p>
在C++中，前向声明类时要注意，对于类Foo，声明后定义Foo*和Foo&amp;，包括函数参数、函数返回值、局部变量、类成员时，由于C++内存模型是平坦（flat）的，
Foo的定义不会改变Foo指针和Foo引用的含义，因此不需要看见Foo的完整定义。而直接以Foo为参数或返回值时，必须知道Foo的定义，因为编译器需要使用Foo的
拷贝构造函数和析构函数。编译器必须保证这两个函数不是private的。此外，如果重载了operator&amp;，类也不能前向声明。
</p>


<p>
和C相比C++的链接模型增加了一下两项：
</p>
<ul class="org-ul">
<li>函数重载，即name mangling。</li>
<li>vague linkage，即同一个符号由多分互不冲突的定义。</li>
</ul>

<p>
name mangling可以为重载函数生成独一无二的名字。这个名字包含了参数信息，但不包含返回值，返回值不参与函数重载。
ODR：One Definition Rule。一个对象只能有一个定义（可以定义多次，但这些定义必须等同）。
一些模板类的短方法在-O2时会内联，因此不一定会造成代码膨胀。模板的定义未必需要放在头文件里。只要在cpp中显示具现化：
</p>


<p>
下面是一个检查头文件包含的办法。如果不确定某个头文件（如&lt;string&gt;）是何时引入的，可以在main()函数中建立该头文件中的对象，
然后在当前目录建立一个同名文件，里面输入
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #483d8b;">#error</span> error
</pre>
</div>
<p>
这时编译程序，就可以观察到是哪个文件引入的。
</p>
</div>
</div>

<div id="outline-container-org8209ff3" class="outline-2">
<h2 id="org8209ff3">反思C++面向对象与虚函数</h2>
<div class="outline-text-2" id="text-org8209ff3">
<p>
如果以共享库的方式提供函数库，头文件和库文件不能轻易修改，
否则容易破坏已有的二进制可执行文件，以及其他依赖于这个库的函数库。
</p>

<p>
C++编译器ABI主要包括：
</p>
<ul class="org-ul">
<li>参数传递方式。即调用约定。</li>
<li>虚函数的调用方式。通常是vptr/vtbl，通过vtbl[offset]访问。</li>
<li>struct/class内存布局。</li>
<li>name mangling。</li>
<li>RTTI和异常。</li>
</ul>

<p>
如果使用C++虚函数为接口，很难保证二进制兼容。
这样的接口是僵硬的，一旦发布无法修改。非虚函数比虚函数更健壮的原因在于，
虚函数是按照偏移量寻址的，非虚函数按照名字寻址。只要函数名和参数列表不变，
名字是不变的，而如果增加了数据成员，偏移量可能发生改变。
Java把C/C++中的链接步骤推迟到类装载（class loading）阶段进行，
因此不存在不能修复虚函数和数据成员的问题。对于大部分虚函数，使用std::function
和std::bind可以替代。考虑一个经典的讨论：不会飞的企鹅（Penguin）
是否应该派生自鸟（Bird）？合理的方案是把具体的行为提取出来做成接口，比如
Flyable、Runnable。然后让企鹅实现Runnable，让麻雀实现Flyable和Runnable。
这个讨论表明，接口（interface）的粒度应该足够小，或许只包含一个方法就够了。
这是接口实际上退化为类型标签。这时完全可以使用std::function来代替：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Penguin</span> {
<span style="color: #a020f0;">public</span>:
    <span style="color: #228b22;">void</span> <span style="color: #0000ff;">run</span>();
    <span style="color: #228b22;">void</span> <span style="color: #0000ff;">swim</span>();
};

<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Sparrow</span> {
<span style="color: #a020f0;">public</span>:
    <span style="color: #228b22;">void</span> <span style="color: #0000ff;">fly</span>();
    <span style="color: #228b22;">void</span> <span style="color: #0000ff;">run</span>();
};

<span style="color: #a020f0;">typedef</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">function</span>&lt;<span style="color: #228b22;">void</span>()&gt; <span style="color: #228b22;">FlyCallback</span>;
<span style="color: #a020f0;">typedef</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">function</span>&lt;<span style="color: #228b22;">void</span>()&gt; <span style="color: #228b22;">RunCallback</span>;
<span style="color: #a020f0;">typedef</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">function</span>&lt;<span style="color: #228b22;">void</span>()&gt; <span style="color: #228b22;">SwimCallback</span>;

<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Foo</span> {
<span style="color: #a020f0;">public</span>:
    <span style="color: #0000ff;">Foo</span>(<span style="color: #228b22;">FlyCallback</span> <span style="color: #a0522d;">fly</span>, <span style="color: #228b22;">RunCallback</span> <span style="color: #a0522d;">run</span>)
        :fly(fly), run(run) {}
<span style="color: #a020f0;">private</span>:
    <span style="color: #228b22;">FlyCallback</span> <span style="color: #a0522d;">fly</span>;
    <span style="color: #228b22;">RunCallback</span> <span style="color: #a0522d;">run</span>;
};

<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Bar</span> {
<span style="color: #a020f0;">public</span>:
    <span style="color: #0000ff;">Bar</span>(<span style="color: #228b22;">SwimCallback</span> <span style="color: #a0522d;">swim</span>, <span style="color: #228b22;">RunCallback</span> <span style="color: #a0522d;">run</span>)
        :swim(swim), run(run) {}
<span style="color: #a020f0;">private</span>:
    <span style="color: #228b22;">SwimCallback</span> <span style="color: #a0522d;">swim</span>;
    <span style="color: #228b22;">RunCallback</span> <span style="color: #a0522d;">run</span>;
};

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">Sparrow</span> <span style="color: #a0522d;">s</span>;
    <span style="color: #228b22;">Penguin</span> <span style="color: #a0522d;">p</span>;

    <span style="color: #228b22;">Foo</span> <span style="color: #a0522d;">foo</span>(bind(&amp;<span style="color: #008b8b;">Sparrow</span>::fly, &amp;s), bind(&amp;<span style="color: #008b8b;">Sparrow</span>::run, &amp;s));
    <span style="color: #228b22;">Bar</span> <span style="color: #a0522d;">bar</span>(bind(&amp;<span style="color: #008b8b;">Penguin</span>::swim, &amp;p), bind(&amp;<span style="color: #008b8b;">Penguin</span>::run, &amp;p));
}
</pre>
</div>

<p>
Linux系统保证兼容的的方法是为每个调用分配固定的数字代号。
</p>


<p>
iostream的缺点在于格式化输出较为复杂，输出格式也缺乏外部可配置性。
iostream还有一个问题是没有保证线程安全。POSIX要求stdio函数是线程安全的，
而iostream没有这种限制。即使是线程安全的，cout &lt;&lt; a &lt;&lt; b;是两次函数调用，
之间可能被其他线程打断。
</p>


<p>
值语言（value semantics）指的是对象的拷贝与原对象无关。内置类型，如int、bool，
以及标准库中的complex&lt;&gt;、pair&lt;&gt;、vector&lt;&gt;、map&lt;&gt;、string等都是值语义。
与值语义对应的是对象语义（object semantics），也叫做引用语义（reference semantics）
。在引用语义下，对象包含了某个资源的指针，不能拷贝对象。
因此引用语义需要将拷贝构造函数和拷贝赋值函数声明为delete。
值语义的优点是生命周期管理简单。引用语义就必须关注底层资源的生命周期，必须保证在使用时，
资源是可用和完整的，并保证当不再需要时及时释放资源。使用智能指针将裸指针转换为值语义，
可以大大简化这个操作。能放到标准容器的对象必须是值语义，因此对于引用语义类，需要使用智能指针。
</p>
</div>
</div>
<div id="outline-container-orgb57543d" class="outline-2">
<h2 id="orgb57543d">C++经验谈</h2>
<div class="outline-text-2" id="text-orgb57543d">
<p>
在C/C++中，一个语句中，一个对象的值只应该改变一次。否则行为是未定义的。
</p>


<p>
不要重载全局new/delete。如果地区要这么做，可以修改LD<sub>PRELOAD</sub>，加载一个so，替代（drop-in replacement）malloc/free。
对于类的new/delete，也不建议重载，避免歧义。
</p>


<p>
在开发分布式程序时，有时需要针对下列失败场景进行测试，如：
</p>
<ul class="org-ul">
<li>read/write返回EIO错误（磁盘满了或坏道）。</li>
<li>write返回EPIPE（对方以外断开连接）。</li>
<li>模拟自连接。程序应该用getsockname和getpeername判断自连接，然后断开。</li>
<li>模拟本地端口耗尽，connect返回EAGAIN。</li>
<li>让gethostbyname返回预定义值，避免测试导致DNS服务器压力过大。</li>
</ul>

<p>
这些情况需要使用单元测试进行验证。常见的方法有：注入系统函数和链接期垫片。
注入系统函数的方式有两种，一是使用虚函数封装系统函数，将直接调用open改为调用
System::instance().open()。二是使用名字空间，如：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">namespace</span> <span style="color: #008b8b;">sockets</span> {
    <span style="color: #228b22;">int</span> <span style="color: #0000ff;">connect</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">sockfd</span>, <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">sockaddr_in</span>&amp; <span style="color: #a0522d;">addr</span>);
}

<span style="color: #b22222;">// </span><span style="color: #b22222;">mock</span>
<span style="color: #228b22;">int</span> <span style="color: #008b8b;">sockets</span>::<span style="color: #0000ff;">connect</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">sockfd</span>, <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">sockaddr_in</span>&amp; <span style="color: #a0522d;">addr</span>) {
    errno = EAGIAN;
    <span style="color: #a020f0;">return</span> -1;
}

<span style="color: #b22222;">// </span><span style="color: #b22222;">real</span>
<span style="color: #228b22;">int</span> <span style="color: #008b8b;">sockets</span>::<span style="color: #0000ff;">connect</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">sockfd</span>, <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">sockaddr_in</span>&amp; <span style="color: #a0522d;">addr</span>) {
    <span style="color: #a020f0;">return</span> ::connect(sockfd, sockaddr_cast(&amp;addr), <span style="color: #a020f0;">sizeof</span>(addr));
}
</pre>
</div>

<p>
采用系统垫片的方式和上述第二种方式类似。在动态链接时，让我们编写的同名函数遮盖系统函数：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">int</span> (*<span style="color: #228b22;">connect_func_t</span>)(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">sockfd</span>,
                              <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">sockaddr</span> *<span style="color: #a0522d;">addr</span>,
                              <span style="color: #228b22;">socklen_t</span> <span style="color: #a0522d;">addrlen</span>);

<span style="color: #228b22;">connect_func_t</span> <span style="color: #a0522d;">connect_func</span> = dlsym(RTDL_NEXT, <span style="color: #8b2252;">"connect"</span>);

<span style="color: #228b22;">bool</span> <span style="color: #a0522d;">mock_connect</span>;
<span style="color: #228b22;">int</span> <span style="color: #a0522d;">mock_connect_errno</span>;

<span style="color: #a020f0;">extern</span> <span style="color: #8b2252;">"C"</span> <span style="color: #228b22;">int</span> <span style="color: #0000ff;">connect</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">sockfd</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">sockaddr</span> *<span style="color: #a0522d;">addr</span>,
                       <span style="color: #228b22;">socklen_t</span> <span style="color: #a0522d;">addrlen</span>) {

    <span style="color: #a020f0;">if</span> (mock_connect) {
        errno = mock_connect_errno;
        <span style="color: #a020f0;">return</span> errno == 0 ? 0 : -1;
    }

    <span style="color: #a020f0;">return</span> connect_func(sockfd, addr, addrlen);
}
</pre>
</div>

<p>
static的用途
</p>
<ul class="org-ul">
<li>函数内的静态变量</li>
<li>让函数或对象在文件内可见</li>
<li>类的静态成员</li>
<li>类的静态方法</li>
</ul>

<p>
名字空间的作用是取代static的第二个用途。但是不要使用匿名名字空间。
编译器可能为匿名名字空间生成随机的名字，导致两次编译生成的文件不同。
</p>


<p>
为了便于使用diff查看，多行注释最好用//。如果函数参数大于3个，每个参数一行。初始化列表也是每个一行。
</p>


<p>
通常std::string有3种实现方式：
</p>
<ul class="org-ul">
<li>无特殊处理（eager copy）。</li>
<li>Copy-on-Write。</li>
<li>短字符串优化（SSO）。</li>
</ul>

<p>
eeager copy和std::vector非常相似，使用一个指针指向字符串起始位置，另一个指针指向结束位置。也有一些方案采用字符串长度来标记结束位置。
写时拷贝的string对象中只有一个指针，下面是代码示例：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">cow_string</span> {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Rep</span> {
        <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">size</span>;
        <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">capacity</span>;
        <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">refcount</span>;
        <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">data</span>[1];
    };
    <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">start</span>;
};
</pre>
</div>

<p>
写时拷贝不是多线程友好的。短字符串优化方案在string对象中保留一个本地缓冲区，将短字符串保存在缓冲区里。对于长字符串，采用eager copy方式保存：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">sso_string</span> {
    <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">start</span>;
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">size</span>;
    <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">kLocalSize</span> = 15;
    <span style="color: #a020f0;">union</span> {
        <span style="color: #228b22;">char</span> <span style="color: #a0522d;">buffer</span>[kLocalSize + 1];
        <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">capacity</span>;
    } <span style="color: #a0522d;">data</span>;
};
</pre>
</div>


<p>
使用STL可以完成很多常见的问题，比如生成排列组合。将元素从小到大排序后，反复调用next<sub>permutation</sub>()就可以得到结果：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b22222;">// </span><span style="color: #b22222;">&#25490;&#24207;</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">elements</span>[] = { 1, 2, 3, 4 };
    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">N</span> =<span style="color: #a020f0;">sizeof</span>(elements) / <span style="color: #a020f0;">sizeof</span>(elements(0));
    <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">int</span>&gt; <span style="color: #a0522d;">vec</span>(elements, elements + N);
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">count</span> = 0;
    <span style="color: #a020f0;">do</span> {
        <span style="color: #008b8b;">std</span>::cout &lt;&lt; ++count &lt;&lt; <span style="color: #8b2252;">": "</span>;
        <span style="color: #008b8b;">std</span>::copy(vec.begin(), vec.end(), <span style="color: #008b8b;">std</span>::ostream_iterator&lt;<span style="color: #228b22;">int</span>&gt;(<span style="color: #008b8b;">std</span>::cout, <span style="color: #8b2252;">", "</span>));
        <span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #008b8b;">std</span>::endl;
    } <span style="color: #a020f0;">while</span> (next_permutation(vec.begin(), vec.end());
}
</pre>
</div>

<p>
如果要从N个元素中选择M个元素的所有组合，可以针对序列{1,1,1,0,0,0,..}做全排列，将排列中1对应元素保留即可：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">values</span>[] = { 1, 2, 3, 4, 5, 6, 7 };
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">elements</span>[] = { 1, 1, 1, 0, 0, 0, 0 };
    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">N</span> = <span style="color: #a020f0;">sizeof</span>(elements) / <span style="color: #a020f0;">sizeof</span>(elements[0]);

    <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">int</span>&gt; <span style="color: #a0522d;">selectors</span>(elements, elements + N);

    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">count</span> = 0;
    <span style="color: #a020f0;">do</span> {
        <span style="color: #008b8b;">std</span>::cout &lt;&lt; ++count &lt;&lt; <span style="color: #8b2252;">"; "</span>;
        <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> =0; i &lt; selectors.size(); ++i) {
            <span style="color: #a020f0;">if</span> (selectors[i]) {
                <span style="color: #008b8b;">std</span>::cout &lt;&lt; values[i] &lt;&lt; <span style="color: #8b2252;">", "</span>;
            }
        }
        <span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #008b8b;">std</span>::endl;
    } <span style="color: #a020f0;">while</span> (perv_permutation(selectors.begin(), selectors.end()));
}
</pre>
</div>

<p>
假设需要将字符串中的连续空格原地替换为一个空格，可以使用unique()函数。unique()可以去除序列中的连续重复元素：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">AreBothSpaces</span> {
    <span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">()</span> (<span style="color: #228b22;">char</span> <span style="color: #a0522d;">x</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">y</span>) <span style="color: #a020f0;">const</span> {
        <span style="color: #a020f0;">return</span> x == <span style="color: #8b2252;">' '</span> &amp;&amp; y == <span style="color: #8b2252;">' '</span>;
    }
};

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">removeContinuousSpaces</span>(<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span>&amp; <span style="color: #a0522d;">str</span>) {
    <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">string</span>::<span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">last</span> = <span style="color: #008b8b;">std</span>::unique(str.begin(), str.end(), AreBothSpaces());
    str.erase(last, str.end());
}
</pre>
</div>


<p>
假设服务器有4GB内存，现在需要对一个100GB大小的文件排序，要怎么做？
思路是分块排序，然后进行多路归并。使用heap可以很容易的实现归并。假设将文件分为32个小文件，可以构造拥有32个元素的最小堆，每个元素
是std::pair&lt;Record,FILE*&gt;。当堆非空时，将顶部元素的记录写入输出文件。如果这个记录对应的文件可读，从其中建立一个新的
std::pair&lt;Record,FILE*&gt;。这样，当堆中的元素全部输出后，归并就完成了。下面是示例代码：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">File</span> <span style="color: #0000ff;">mergeN</span>(<span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">File</span>&gt;&amp; <span style="color: #a0522d;">files</span>) {
    <span style="color: #228b22;">File</span> <span style="color: #a0522d;">output</span>;
    <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;Input&gt; <span style="color: #a0522d;">inputs</span>;

    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i &lt; files.size(); ++i) {
        Input <span style="color: #228b22;">input</span>(&amp;<span style="color: #a0522d;">files</span>[i]);
        <span style="color: #a020f0;">if</span> (input.next()) {
            inputs.push_back(input);
        }
    }

    <span style="color: #008b8b;">std</span>::make_heap(inputs.begin(), inputs.end());
    <span style="color: #a020f0;">while</span> (!inputs.empty()) {
        <span style="color: #008b8b;">std</span>::pop_head(inputs.begin(), inputs.end());
        output.push_back(inputs.back().value);

        <span style="color: #a020f0;">if</span> (inputs.back().next()) {
            <span style="color: #008b8b;">std</span>::push_heap(inputs.begin(), inputs.end());
        } <span style="color: #a020f0;">else</span> {
            inputs.pop_back();
        }
    }

    <span style="color: #a020f0;">return</span> output;
}

<span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">int</span> <span style="color: #228b22;">Record</span>;
<span style="color: #a020f0;">typedef</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">Record</span>&gt; <span style="color: #228b22;">File</span>;

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Input</span> {
    <span style="color: #228b22;">Record</span> <span style="color: #a0522d;">value</span>;
    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">File</span>* <span style="color: #a0522d;">file</span>;

    <span style="color: #a020f0;">explicit</span> <span style="color: #0000ff;">Input</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">File</span>*<span style="color: #a0522d;">f</span>);
    <span style="color: #228b22;">bool</span> <span style="color: #0000ff;">next</span>();

    <span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">Input</span>&amp; <span style="color: #a0522d;">rhs</span>) <span style="color: #a020f0;">const</span> {
        <span style="color: #a020f0;">return</span> value &gt; rhs.value;
    }
};
</pre>
</div>


<p>
假设有一个数值，现在要求把奇数排列在偶数之前。用partition()可以实现这个需求：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">bool</span> <span style="color: #0000ff;">is_odd</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span>) {
    <span style="color: #a020f0;">return</span> (x % 2) != 0;
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">move_odds_before_evens</span>() {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">numbers</span>[] = {1, 2, 3, 4, 5, 6};
    <span style="color: #008b8b;">std</span>::partition(numbers, numbers + 6, &amp;is_odd);
    <span style="color: #008b8b;">std</span>::copy(numbers, numbers + 6, <span style="color: #008b8b;">std</span>::ostream_iterator&lt;<span style="color: #228b22;">int</span>&gt;(<span style="color: #008b8b;">std</span>::cout, <span style="color: #8b2252;">", "</span>));
    <span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #008b8b;">std</span>::endl;
}
</pre>
</div>


<p>
假设已知N个IP地址区间和它们对应的城市名，这些IP区间相互不重叠。要求写一个程序，根据IP地址寻找所在程序。这时可以将IP地址区间进行排序，
然后使用lower<sub>bound进行查找</sub>：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">IPRange</span> {
    <span style="color: #228b22;">uint32_t</span> <span style="color: #a0522d;">start_ip</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">inclusive</span>
    <span style="color: #228b22;">uint32_t</span> <span style="color: #a0522d;">end_ip</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">inclusive</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">value</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&gt;= 0</span>

    <span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">IPRange</span>&amp; <span style="color: #a0522d;">rhs</span>) <span style="color: #a020f0;">const</span> {
        <span style="color: #a020f0;">return</span> start_ip &lt; rhs.start_ip;
    }
};


<span style="color: #228b22;">int</span> <span style="color: #0000ff;">find_ip_value</span>(<span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">IPRange</span>&gt;&amp; <span style="color: #a0522d;">ranges</span>, <span style="color: #228b22;">uint32_t</span> <span style="color: #a0522d;">ip</span>) {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">result</span> = -1;
    <span style="color: #a020f0;">if</span> (range.empty()) {
        <span style="color: #a020f0;">return</span> result;
    }

    <span style="color: #228b22;">IPRange</span> <span style="color: #a0522d;">needle</span> = { ip, 0, 0 };
    <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">vector</span>&lt;<span style="color: #228b22;">IPRange</span>&gt;::<span style="color: #228b22;">const_iterator</span> <span style="color: #a0522d;">it</span> = <span style="color: #008b8b;">std</span>::lower_bound(ranges.begin(),
                                                               ranges.end(),
                                                               needle);
    <span style="color: #a020f0;">if</span> (it == ranges.end()) {
        --it;
    } <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (it != ranges.begin() &amp;&amp; it-&gt;start_ip &gt; ip) {
        --it;
    }

    <span style="color: #a020f0;">if</span> (it-&gt;start_ip &lt;= ip &amp;&amp; it-&gt;end_ip &gt;= ip) {
        result = it-&gt;value;
    }

    <span style="color: #a020f0;">return</span> result;
}
</pre>
</div>
<p>
如果允许IP区间出现重叠，通常使用线段树或专门的longest prefix match算法。
</p>
</div>
</div>


<div id="outline-container-org4c4773c" class="outline-2">
<h2 id="org4c4773c">附录</h2>
<div class="outline-text-2" id="text-org4c4773c">
<p>
分布式系统不应当要求程序做到7x24，而是通过整体设计，让系统达到一定的可用性。既然程序不要求7x24，对内存碎片也无需过度关注。
</p>


<p>
学习TCP网络编程有3个重要的例子：Echo、Chat和Proxy。Echo可以熟悉服务端被动接受新连接、收发数据、被动处理连接断开。
Chat可以熟悉如何管理多个连接？如何防止串话？如何处理文件描述符复用？Proxy对连接的管理更加复杂，既要被动接受连接，也要主动发起连接。
还要考虑两边速度不匹配的情况。
</p>


<p>
IP和TCP头的校验和是非常简单的校验，对于一些错误，这种校验是无效的。因此必须增加应用层校验。这种策略符合end-to-end原则。
</p>


<p>
下面考虑一下一台服务器能够支持多少并发TCP连接呢？如果使用socket/accept，每个TCP连接需要消耗1个文件描述符。
因此可用文件描述符可以限制TCP连接数。但是从另一个角度来看，TCP是虚拟连接，只要能够互相发送IP报文，TCP连接就是存在的。
完成握手之后，TCP连接就建立起来了，并且不会再消耗资源。因此，在讨论网络程序的性能时，更重要的指标是：每秒收发多少条消息、每秒收发多少字节或
支持多少活动的并发客户等。
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2019-09-23 周一 21:12</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>

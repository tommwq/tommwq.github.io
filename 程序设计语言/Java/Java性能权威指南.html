<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-09-23 周一 21:12 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Java性能权威指南</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Java性能权威指南</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org0c9e4b6">性能测试方法</a>
<ul>
<li><a href="#orgf1388e5">原则1：测试真实应用。</a>
<ul>
<li><a href="#org6d0bdfa">微基准测试</a></li>
<li><a href="#org328b094">宏基准测试</a></li>
</ul>
</li>
<li><a href="#org8c3d71b">原则2：理解批处理流逝时间、吞吐量和响应时间</a>
<ul>
<li><a href="#org8c5a9e1">吞吐量测试</a></li>
<li><a href="#org34aacee">响应时间测试</a></li>
</ul>
</li>
<li><a href="#org5e975b0">原则3：用统计方法应对性能的变化</a></li>
<li><a href="#org2372266">原则4：尽早频繁测试</a></li>
</ul>
</li>
<li><a href="#org66622ec">Java性能调优工具箱</a>
<ul>
<li><a href="#orgb638ad6">CPU使用率</a></li>
<li><a href="#org40da2bc">磁盘使用率</a></li>
<li><a href="#orgb224062">网络使用率</a></li>
<li><a href="#orgdbddae8">Java监控工具</a></li>
<li><a href="#org3252d5e">采样分析器和探查分析器</a></li>
<li><a href="#org44d2dbb">JMC和JFR</a></li>
</ul>
</li>
<li><a href="#org592f3b3">JIT编译器</a></li>
<li><a href="#org5015b33">垃圾收集入门</a>
<ul>
<li><a href="#org33b0924">Serial垃圾收集器（-XX:+UseSerialGC）</a></li>
<li><a href="#orge2308d6">Throughput垃圾收集器（-XX:+UseParallelGC -XX:+UseParallelOldGC）</a></li>
<li><a href="#orgdef427d">CMS（-XX:+UseParNewGC -XX:+UseConcMarkSweepGC）</a></li>
<li><a href="#org7c27c16">G1（+XX:+UseG1GC）</a></li>
<li><a href="#org1aa139d">垃圾收集器的选择</a></li>
<li><a href="#org1ecc2bb">GC调优</a></li>
<li><a href="#org81ca9ec">永久代和元空间</a></li>
<li><a href="#org4d9c2a6">并发控制</a></li>
<li><a href="#orgad455d2">自适应堆调整</a></li>
<li><a href="#orgf3dfc83">垃圾回收工具</a></li>
</ul>
</li>
<li><a href="#orga3c24e5">垃圾收集算法</a>
<ul>
<li><a href="#org42296d8">Throughput垃圾收集算法</a></li>
<li><a href="#org635d436">CMS垃圾收集器</a></li>
<li><a href="#org3190086">G1垃圾收集器</a></li>
<li><a href="#org09bf0b3">晋升和Survivor</a></li>
<li><a href="#org4c9a633">大对象</a></li>
<li><a href="#orgaf9347b">G1分区大小</a></li>
</ul>
</li>
<li><a href="#orgcefd1c2">堆内存最佳实践</a>
<ul>
<li><a href="#orga808713">查看堆</a></li>
<li><a href="#orgc4d656b">内存溢出</a></li>
<li><a href="#org92653d8">减少内存使用</a></li>
</ul>
</li>
<li><a href="#org86ceb33">原生内存最佳实践</a>
<ul>
<li><a href="#org3138318">原生内存</a></li>
<li><a href="#orga041c05">大页</a></li>
<li><a href="#orgc1cea9e">OOP压缩</a></li>
</ul>
</li>
<li><a href="#org546296f">线程与同步的性能</a>
<ul>
<li><a href="#orgafe1622">线程池</a></li>
<li><a href="#orgc72f55a">线程同步</a></li>
<li><a href="#orgfabec41">伪共享</a></li>
<li><a href="#org84674b0">JVM线程调优</a></li>
<li><a href="#org3a872eb">监控线程</a></li>
</ul>
</li>
<li><a href="#org4bb040f">数据库性能的最佳实践</a></li>
<li><a href="#orgf82c848">Java SE API技巧</a>
<ul>
<li><a href="#orge68d5c6">缓冲式I/O</a></li>
<li><a href="#org53a47d5">随机数</a></li>
<li><a href="#org6c9e80a">字符串</a></li>
<li><a href="#org97dc3ed">日志</a></li>
<li><a href="#org1cfa42c">容器</a></li>
<li><a href="#org2d9e84e">Lambda表达式</a></li>
<li><a href="#org8fd5919">stream和过滤器</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org0c9e4b6" class="outline-2">
<h2 id="org0c9e4b6">性能测试方法</h2>
<div class="outline-text-2" id="text-org0c9e4b6">
</div>
<div id="outline-container-orgf1388e5" class="outline-3">
<h3 id="orgf1388e5">原则1：测试真实应用。</h3>
<div class="outline-text-3" id="text-orgf1388e5">
</div>
<div id="outline-container-org6d0bdfa" class="outline-4">
<h4 id="org6d0bdfa">微基准测试</h4>
<div class="outline-text-4" id="text-org6d0bdfa">
<p>
考虑下面的微基准测试：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #a020f0;">public</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">doTest</span>() {
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">l</span>;
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">then</span> = System.currentTimeMillis();
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; <span style="color: #228b22;">nLoops</span>; i++) {
        l = fibImpl1(50);
    }
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">now</span> = System.currentTimeMillis();
    System.out.println(<span style="color: #8b2252;">"Elapsed time: "</span> + (now - then));
}

<span style="color: #a020f0;">private</span> <span style="color: #228b22;">double</span> <span style="color: #0000ff;">fibImpl1</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">n</span>) {
    <span style="color: #a020f0;">if</span> (n &lt; 0) <span style="color: #a020f0;">throw</span> <span style="color: #a020f0;">new</span> <span style="color: #228b22;">IllegalArgumentException</span>(<span style="color: #8b2252;">"Must be &gt; 0"</span>);
    <span style="color: #a020f0;">if</span> (n == 0) <span style="color: #a020f0;">return</span> 0d;
    <span style="color: #a020f0;">if</span> (n == 1) <span style="color: #a020f0;">return</span> 1d;
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">d</span> = fibImpl1(n - 2) + fibImpl1(n - 1);
    <span style="color: #a020f0;">if</span> (Double.isInfinite(d)) <span style="color: #a020f0;">throw</span> <span style="color: #a020f0;">new</span> <span style="color: #228b22;">ArithmeticException</span>(<span style="color: #8b2252;">"Overflow"</span>);
    <span style="color: #a020f0;">return</span> d;
}
</pre>
</div>

<p>
这段测试代码存在一些问题。首先，doTest()方法中的循环部分，其计算结果没有被使用过。编译器在优化时可能会去掉这部分代码，实际运行的代码变成：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #228b22;">long</span> <span style="color: #a0522d;">then</span> = System.currentTimeMillis();
<span style="color: #228b22;">long</span> <span style="color: #a0522d;">now</span> = System.currentTimeMillis();
System.out.println(<span style="color: #8b2252;">"Elapsed time: "</span> + (now - then));
</pre>
</div>

<p>
对于这个问题，可以把l声明为volatile，避免编译器优化时将整个循环体移除。
</p>


<p>
只是这样还不够。一些编译器会发现，整个循环的实际效果是计算fibImpl1(50)，因此可能会只执行一次循环。对于这个情况，可以将参数随机化，比如：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #228b22;">long</span> <span style="color: #a0522d;">then</span> = System.currentTimeMillis();
<span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; <span style="color: #228b22;">nLoops</span>; i++) {
    l = fibImpl1(random.nextInteger());
}
<span style="color: #228b22;">long</span> <span style="color: #a0522d;">now</span> = System.currentTimeMillis();
</pre>
</div>
<p>
但是这样一来，计时结果中包含了生成随机数的时间，没有测量反映我们要测试的函数。因此，需要提前生成输入测试的数据：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #228b22;">int</span>[] <span style="color: #a0522d;">input</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">int</span>[nLoops];
<span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; <span style="color: #228b22;">nLoops</span>; i++) {
    input[i] = random.nextInteger();
}

<span style="color: #228b22;">long</span> <span style="color: #a0522d;">then</span> = System.currentTimeMillis();
<span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; <span style="color: #228b22;">nLoops</span>; i++) {
    <span style="color: #a020f0;">try</span> {
        l = fibImpl1(input[i]);
    } <span style="color: #a020f0;">catch</span> (<span style="color: #228b22;">IllegalArgumentException</span> <span style="color: #a0522d;">iae</span>) {
    }
}
<span style="color: #228b22;">long</span> <span style="color: #a0522d;">now</span> = System.currentTimeMillis();
</pre>
</div>
<p>
这里我们使用了随机数进行测试，如果输入的测试数据符合实际适用的情况，测试效果会更好。
</p>


<p>
除了上面2种情况外，这个微基准测试没有进行热身。JVM在运行时会根据执行热点自动优化代码，实际运行的代码往往和编译生成的字节码有差异。因此需要首先对JVM进行热身，让测试的执行情况更贴近实际：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #a020f0;">public</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">doTest</span>(<span style="color: #228b22;">boolean</span> <span style="color: #a0522d;">isWarmup</span>) {
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">l</span>;
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">then</span> = System.currentTimeMillis();
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; <span style="color: #228b22;">nLoops</span>; i++) {
        l = fibImpl1(input[i]);
    }
    <span style="color: #a020f0;">if</span> (isWarmup) {
        <span style="color: #a020f0;">return</span>;
    }

    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">now</span> = System.currentTimeMillis();
    System.out.println(<span style="color: #8b2252;">"Elapsed time: "</span> + (now - then));
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org328b094" class="outline-4">
<h4 id="org328b094">宏基准测试</h4>
<div class="outline-text-4" id="text-org328b094">
<p>
和微基准测试相对应，宏基准测试是指对系统或某个业务功能进行完成的性能测试。
</p>
</div>
</div>
</div>

<div id="outline-container-org8c3d71b" class="outline-3">
<h3 id="org8c3d71b">原则2：理解批处理流逝时间、吞吐量和响应时间</h3>
<div class="outline-text-3" id="text-org8c3d71b">
</div>
<div id="outline-container-org8c5a9e1" class="outline-4">
<h4 id="org8c5a9e1">吞吐量测试</h4>
<div class="outline-text-4" id="text-org8c5a9e1">
<p>
吞吐量是一段时间内所完成的工作量。
在进行吞吐量测试时，客户端收到响应后立即发送新的请求。进行客户端-服务器的吞吐量测试时，必须考虑客户端发送请求的能力没有受到限制。
</p>
</div>
</div>

<div id="outline-container-org34aacee" class="outline-4">
<h4 id="org34aacee">响应时间测试</h4>
<div class="outline-text-4" id="text-org34aacee">
<p>
响应时间是客户端发送请求到收到响应之间流逝的时间。在测试响应时间时，客户端在收到应答后会短暂停止一段时间（这段时间叫做思考时间），这样做是为了模拟用户真实行为。引入思考时间后，系统的吞吐量也固定了。
</p>
</div>
</div>
</div>

<div id="outline-container-org5e975b0" class="outline-3">
<h3 id="org5e975b0">原则3：用统计方法应对性能的变化</h3>
<div class="outline-text-3" id="text-org5e975b0">
<p>
测试结果会随着时间发生变化。即使测试使用的数据集不变，两次测试也无法产生相同的结果。因为影响测试的因素很多，比如后台进程的运行情况等等。因此，必须使用统计学工具来处理测试结果。在检验试样（specimen，新代码）相对基线（baseline，原始代码）是否存在性能提升时，通常会使用学生-t检验。
</p>
</div>
</div>

<div id="outline-container-org2372266" class="outline-3">
<h3 id="org2372266">原则4：尽早频繁测试</h3>
<div class="outline-text-3" id="text-org2372266">
<ul class="org-ul">
<li>自动化一切。所有的性能测试都应该脚本化，并能多次运行，根据测试结果进行学生-t检验，生成统计报告。</li>
<li>测试一切。自动化收集所有的数据，包括：CPU使用率、磁盘使用率、网络使用率、内存使用率、应用日志、垃圾回收日志等。理想情况下，还可以包括JFR记录、性能检测（profiling）信息等。</li>
<li>在真实系统上运行。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org66622ec" class="outline-2">
<h2 id="org66622ec">Java性能调优工具箱</h2>
<div class="outline-text-2" id="text-org66622ec">
<p>
Linux系统上常用的监控工具有sar、vmstat、iostat、prstat等。Windows系统上有typeperf等。
</p>
</div>

<div id="outline-container-orgb638ad6" class="outline-3">
<h3 id="orgb638ad6">CPU使用率</h3>
<div class="outline-text-3" id="text-orgb638ad6">
<p>
CPU使用时间可以分为用户态时间和系统态时间（Windows上叫做privileged time）。用户态时间是CPU用来执行应用代码的时间，系统态时间是CPU执行内核代码消耗的时间。任何使用底层资源的操作（如磁盘IO、网络IO）都会增加系统时间。对CPU进行性能优调的目的是，让CPU使用率和用户态使用率尽可能提高。
</p>


<p>
导致CPU空闲的原因有3种：
</p>

<ul class="org-ul">
<li>应用被同步原语阻塞，直至锁释放才能继续执行。</li>
<li>应用在等待某些东西，例如数据库调用所返回的响应。</li>
<li>应用的确没有事情要做。</li>
</ul>

<p>
前两种情况可以通过降低竞争或优化数据库来判断。而第3种情况，往往是由于系统负载的随机性导致的。比如一个HTTP服务器平均每秒钟收到1个请求，处理这个请求需要450毫秒，CPU的使用量就是45%。如果通过优化，处理这个请求需要400毫秒，系统的CPU使用率会下降，系统能够承载的最大负载增加。
</p>


<p>
Linux可以监控可运行（没有被IO阻塞、休眠）的线程，叫做运行队列（run queue）。Windows中对应的概念叫做处理器队列（processor queue）。使用typeperf可以查看处理器队列长度：
</p>
<div class="org-src-container">
<pre class="src src-dos">typeperf -si 1 "\System\Processor Queue Length"
</pre>
</div>

<p>
和Linux系统下的工具不同，typeperf输出的结果不包含正在运行的线程数。从性能的角度看，Windows的处理器队列长度最好是0，Linux的运行队列长度最好小于CPU核心数。
</p>


<p>
在检查应用性能时，首先应该检查CPU时间，弄清楚为何CPU使用率低。
</p>
</div>
</div>


<div id="outline-container-org40da2bc" class="outline-3">
<h3 id="org40da2bc">磁盘使用率</h3>
<div class="outline-text-3" id="text-org40da2bc">
<p>
磁盘系统成为瓶颈的主要原因是写入效率不高（随机IO，吞吐量低）或写入数据过多。在iostat的输出中，%util较低不能说明IO系统没有瓶颈。也要考察%system和%iowait。如果它们的和较大，系统很可能存在IO问题。对于大量随机写的情况，通常就是%util和%iowait较低，而%system较高。这时要检查w/s和wMB/s两个值。如果二者之比较低，说明系统在进行大量的随机IO。如果没有随机IO，当IO请求超过磁盘处理能力时，系统也会出现问题。这时，%util和%iowait较高，%system相对较低，wMB/s也较高。
</p>

<p>
由于操作系统通过磁盘来支持虚拟内存，对于不直接产生IO的应用，也要监控磁盘。虚拟内存不足导致的磁盘IO可以通过vmstat命令的si和so两列观察。
</p>
</div>
</div>


<div id="outline-container-orgb224062" class="outline-3">
<h3 id="orgb224062">网络使用率</h3>
<div class="outline-text-3" id="text-orgb224062">
<p>
监控网络使用率的工具有netstat（Linux、Windows）、nicestat（Linux）、typeperf（Windows）等。在使用时要注意，网卡流量统计数值的单位通常是字节（B/s），而网络带宽的单位是位（b/s）。一个千兆网卡每秒可以读写的数据是125兆字节。网卡通常难以支持100%的使用率，超过40%就要小心了。
</p>


<p>
和磁盘类似，网络出现瓶颈可能是写入效率低（吞吐量低）或写入数据量大（吞吐量大）两个原因。
</p>
</div>
</div>

<div id="outline-container-orgdbddae8" class="outline-3">
<h3 id="orgdbddae8">Java监控工具</h3>
<div class="outline-text-3" id="text-orgdbddae8">
<p>
JDK提供了以下的监控工具：
</p>

<ul class="org-ul">
<li>jcmd 打印Java程序的类、线程和VM信息。</li>
<li>jconsole 提供关于JVM活动的图形化视图。</li>
<li>jhat 读取转储文件。</li>
<li>jmap 建立转储文件。</li>
<li>jinfo 查看JVM系统属性。</li>
<li>jstack 转储进程栈。</li>
<li>jstat 查看GC和类加载活动。</li>
<li>jvisualvm 监控JVM。</li>
</ul>

<p>
下面以实例的方式介绍这些工具的用法。
</p>

<p>
查看JVM运行时间：
</p>
<div class="org-src-container">
<pre class="src src-shell">jcmd &lt;PID&gt; VM.uptime
</pre>
</div>

<p>
查看JVM版本：
</p>
<div class="org-src-container">
<pre class="src src-shell">jcmd &lt;PID&gt; VM.version
</pre>
</div>

<p>
查看JVM命令行：
</p>
<div class="org-src-container">
<pre class="src src-shell">jcmd &lt;PID&gt; VM.command_line
</pre>
</div>

<p>
查看System.getProperties()属性：
</p>
<div class="org-src-container">
<pre class="src src-shell">jcmd &lt;PID&gt; VM.system_properties
jinfo -sysprops &lt;PID&gt;
</pre>
</div>

<p>
查看JVM调优标志：
</p>
<div class="org-src-container">
<pre class="src src-shell">jcmd &lt;PID&gt; VM.flags [-all]
</pre>
</div>

<p>
查看各标志默认值：
</p>
<div class="org-src-container">
<pre class="src src-shell">java -XX:+PrintFlagsFinal -version
</pre>
</div>

<p>
查看Java程序标志：
</p>
<div class="org-src-container">
<pre class="src src-shell">jinfo -flags &lt;PID&gt;
jinfo -flag PrintGCDetails &lt;PID&gt;
</pre>
</div>

<p>
设置Java程序标志：
</p>
<div class="org-src-container">
<pre class="src src-shell">jinfo -flag -PrintGCDetails &lt;PID&gt;
jinfo -flag +PrintGCDetails &lt;PID&gt;
</pre>
</div>

<p>
查看线程信息：
</p>
<div class="org-src-container">
<pre class="src src-shell">jstack &lt;PID&gt;
jcmd &lt;PID&gt; Thread.print
</pre>
</div>
</div>
</div>

<div id="outline-container-org3252d5e" class="outline-3">
<h3 id="org3252d5e">采样分析器和探查分析器</h3>
<div class="outline-text-3" id="text-org3252d5e">
<p>
性能侦测有两种方式：数据采样和数据探查。采样是最常用的方式，性能开销最小，但可能出现采样不精确的情况。增加采样时间可以提高精确性。采样分析器还有一个缺陷，就是只能在线程位于安全点时（基本上都是在JVM分配内存时）采样。
</p>


<p>
探查分析器在类加载时更改字节码，它的侵入性更强，对程序性能的影响较大，而且会影响编译器内联。
</p>
</div>
</div>

<div id="outline-container-org44d2dbb" class="outline-3">
<h3 id="org44d2dbb">JMC和JFR</h3>
<div class="outline-text-3" id="text-org44d2dbb">
<p>
JMC（Java Mission Control）可以观察JVMe的运行情况。JMC通过向MBean发起JMX（Java Management Extensions）调用进行监控。JFR（Java Flight Recorder）记录了JVM事件，这些记录可以用来分析JVM的运行情况。默认情况下，JFR是关闭。在启动Java程序时添加标志-XX:+UnlockCommercialFeatures -XX:+FlightRecorder可以开启JFR特性。开启这个特性不会立即产生事件记录，而是在收到特定指令后才开始记录。使用jcmd可以发送这样的指令：
</p>
<div class="org-src-container">
<pre class="src src-shell">jcmd &lt;PID&gt; JFR.start [options_list]
</pre>
</div>
<p>
参数options<sub>list时一组以逗号分隔的键值对</sub>，可以是
</p>

<ul class="org-ul">
<li>name=name 为记录指定名字 。</li>
<li>defaultrecording=&lt;true|false&gt; 是否在初始时记录。</li>
<li>settings=path JFR配置文件路径。</li>
<li>delay=time 记录开始前的延迟时间。</li>
<li>duration=time 记录持续时间。</li>
<li>filename=path 记录文件名。</li>
<li>compress=&lt;true|false&gt; 是否压缩。</li>
<li>maxage=time 缓冲区中保留记录的最长时间。</li>
<li>maxsize=size 缓冲区大小。</li>
</ul>

<p>
这些参数可以在启动时通过标志-XX:+FlightRecorderOptions=string设置。
</p>


<p>
一个进程可以开启多个JFR记录，通过下面的命令可以查看开启的JFR：
</p>
<div class="org-src-container">
<pre class="src src-shell">jcmd &lt;PID&gt; JFR.check [verbose]
</pre>
</div>


<p>
下面的命令会停止JFR记录：
</p>
<div class="org-src-container">
<pre class="src src-shell">jcmd &lt;PID&gt; JFR.stop [options_list]
</pre>
</div>
<p>
其中参数有：
</p>
<ul class="org-ul">
<li>name=name JFR名字。</li>
<li>recording=n JFR编号（通过JFR.check得到）。</li>
<li>discard=boolean 丢弃结果。</li>
<li>filename=path 将数据写入文件。</li>
</ul>


<p>
JFR是可扩展的，可以捕获自定义事件。JFR捕获的事件定义在模板中。JFR自带了两个模板：默认模板和性能分析模板，性能开销分别是1%和2%。JFR模板由JMC管理，保存在$HOME/.jmc/&lt;release&gt;和$JAVA<sub>HOME</sub>/jre/lib/jfr目录下。
</p>
</div>
</div>
</div>

<div id="outline-container-org592f3b3" class="outline-2">
<h2 id="org592f3b3">JIT编译器</h2>
<div class="outline-text-2" id="text-org592f3b3">
<p>
JVM提供了两种JIT编译器，client编译器（-client）和server编译器（-server或-d64）。client编译器更早开启编译，程序启动得快。server编译器生成的代码更快，程序运行得快。从Java 7开始，Java尝试将两种技术融合，在启动时使用client编译器，运行一段时间后再使用server编译器。这种技术叫做分层编译（-XX:+TieredCompilation）。在Java 8中，分层编译默认开启。
</p>


<p>
JVM编译代码时，将得到的汇编指令保存在代码缓存中。如果代码缓存填满，就不再编译代码了。代码缓存空间是预留的内存空间，如果过大，会消耗过多虚拟内存。和代码缓存相关的标志有
</p>

<ul class="org-ul">
<li>-XX:ReservedCodeCacheSize=N 代码缓存大小</li>
<li>-XX:InitialCodeCacheSize=N 初始代码缓存大小</li>
</ul>

<p>
在64位JVM上，Java 8分层编译默认的代码缓存是240MB。
</p>


<p>
Java提供了标志-XX:+PrintCompilation来控制编译事件的输出。在Java 7中输出的格式为
</p>
<blockquote>
<p>
timestamp compilation<sub>id</sub> attributes (tiered<sub>level</sub>) method<sub>name</sub> size deopt
</p>
</blockquote>

<p>
这里的attributes是由5个字符组成的字符串，各字符含义如下
</p>
<ul class="org-ul">
<li>% 编译为OSR（On-Stack Replacement 栈上替换）</li>
<li>s 方法是同步的</li>
<li>! 方法是异步的</li>
<li>b 阻塞模式时编译</li>
<li>n 封装本地方法</li>
</ul>

<p>
使用jstat可以观察编译情况
</p>
<div class="org-src-container">
<pre class="src src-shell">jstat -compiler &lt;PID&gt;
jstat -printcompilation &lt;PID&gt; &lt;PeriodInMillisecond&gt;
</pre>
</div>


<p>
内联是编译器进行的一个重要的优化手段，内联可以避免函数调用的开销。在JVM中，内联是默认开启的。使用-XX:-Inline可以关闭内联。对于一个频繁调用的方法，如果它的字节码小于-XX:MaxFreqInlineSize=N（默认325）时，编译器会将其内联。而其他方法只有足够小（字节码小于-XX:MaxInlineSize=N，默认35）时才会被内联。
</p>


<p>
JIT编译器支持逃逸分析（-XX:+DoEscapeAnalysis，默认true），并根据结果进一步优化代码。
</p>


<p>
在一些情况下JIT会丢弃编译的结果，这个过程叫逆优化。分层编译可能会导致逆优化。分层编译时，代码首先由client编译器编译，然后运行一段时间后，server编译器开始编译。为了替换client编译器的结果，JVM将这些代码标记为废弃。这种情况下，逆优化会提高程序性能。
</p>

<p>
另一种情况的逆优化会对性能产生负面效果。考虑下面的例子：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #228b22;">StockPriceHistory</span> <span style="color: #a0522d;">sph</span>;
<span style="color: #228b22;">String</span> <span style="color: #a0522d;">log</span> = request.getParameter(<span style="color: #8b2252;">"log"</span>);
<span style="color: #a020f0;">if</span> (log != <span style="color: #008b8b;">null</span> &amp;&amp; log.equals(<span style="color: #8b2252;">"true"</span>)) {
    sph = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">StockPriceHistoryLogger</span>(...);
} <span style="color: #a020f0;">else</span> {
    sph = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">StockPriceHistoryImpl</span>(...);
}
sph.getHighPrice();
sph.getStdDev();
</pre>
</div>

<p>
如果所有的请求中没有log参数，编译器发现sph的实际类型是StockPriceHistoryImpl，会将代码内联，并执行优化。这时如果一个请求带有log参数，JVM会发现之前的优化失效了，它必须废弃编译结果。这种情况叫做逆优化陷阱（deoptimization trap）。
</p>


<p>
client编译器和server编译器又叫做C1编译器和C2编译器。在JVM中，两种编译器一共有5中编译基本，它们是：
</p>

<ul class="org-ul">
<li>0 解释代码。</li>
<li>1 简单的C1编译代码</li>
<li>2 受限的C1编译代码</li>
<li>3 完全C1编译代码</li>
<li>4 C2编译代码</li>
</ul>


<p>
对于现代JVM来说，final关键字的影响很小。因此选择final时应该只考虑业务或逻辑层面的因素。
</p>
</div>
</div>

<div id="outline-container-org5015b33" class="outline-2">
<h2 id="org5015b33">垃圾收集入门</h2>
<div class="outline-text-2" id="text-org5015b33">
<p>
简单来说，垃圾收集器的工作分为3步：查找不再使用的对象，释放这些对象管理的内存，调整堆栈内存布局（压缩，避免内存碎片）。从性能角度看，关注垃圾回收的原因在于，垃圾回收可能导致应用程序的停顿。在JVM中有4个主流的垃圾收集器：Serial收集器（常用于但CPU）、Throughput（Parallel）收集器、Concurrent收集器（CMS）和G1收集器。这些垃圾收集器都遵循分代垃圾收集的原则。
</p>


<p>
代垃圾收集将对象划分为新生代（young generation）和老年代（old generation或tenured generation）。新生代有分为Eden和Survivor。新生代用来保存新建立的对象，这些对象的特点是生存周期较短。在对新生代进行垃圾收集时（叫做Minor GC），所有收集器都会产生STW（stop-the-world）现象，即全部应用线程停止工作。
</p>


<p>
不同的垃圾收集器对老年代对象的处理具有很大的不同。简单的垃圾收集器停止所有应用线程进行回收，叫做Full GC。CMS和G1不需要这么做，它们也叫做并发（Concurrent）垃圾收集器。
</p>
</div>

<div id="outline-container-org33b0924" class="outline-3">
<h3 id="org33b0924">Serial垃圾收集器（-XX:+UseSerialGC）</h3>
<div class="outline-text-3" id="text-org33b0924">
<p>
Serial收集器在Minor GC和Full GC都会发生STW。
</p>
</div>
</div>

<div id="outline-container-orge2308d6" class="outline-3">
<h3 id="orge2308d6">Throughput垃圾收集器（-XX:+UseParallelGC -XX:+UseParallelOldGC）</h3>
<div class="outline-text-3" id="text-orge2308d6">
<p>
Throughput垃圾收集器采用多线程处理方式，Full GC时STW的时间较短。
</p>
</div>
</div>

<div id="outline-container-orgdef427d" class="outline-3">
<h3 id="orgdef427d">CMS（-XX:+UseParNewGC -XX:+UseConcMarkSweepGC）</h3>
<div class="outline-text-3" id="text-orgdef427d">
<p>
CMS也使用多线程，并且在Full GC时不会发生STW。CMS在后台定期扫描老年代。只有在Minor GC和扫描老年代时，应用程序才会停顿。CMS不会压缩老年代，并且需要更多的CPU资源。如果CPU资源不够，或者内存碎片太多，CMS会退化成Serial（Concurrent Mode Failure），暂停所有应用线程，使用单线程回收垃圾，然后再恢复到并发运行的状态。
</p>
</div>
</div>

<div id="outline-container-org7c27c16" class="outline-3">
<h3 id="org7c27c16">G1（+XX:+UseG1GC）</h3>
<div class="outline-text-3" id="text-org7c27c16">
<p>
G1也是并发垃圾收集器。G1将堆分为若干个区域（Region），每个区域属于新生代或老年代。
</p>
</div>
</div>


<div id="outline-container-org1aa139d" class="outline-3">
<h3 id="org1aa139d">垃圾收集器的选择</h3>
<div class="outline-text-3" id="text-org1aa139d">
<p>
如果程序使用的内存少于100MB，建议选择Serial垃圾收集器。这种情况下，Throughput、CMS或G1都无法发挥作用。
对于批处理的情况，应用线程消耗的CPU较多，而用户对响应时间要求又不高，比较适合Throughput垃圾收集器。
</p>

<p>
命令jcmd可以让JVM执行Full GC：
</p>
<div class="org-src-container">
<pre class="src src-shell">jcmd &lt;PID&gt; GC.run
</pre>
</div>
</div>
</div>


<div id="outline-container-org1ecc2bb" class="outline-3">
<h3 id="org1ecc2bb">GC调优</h3>
<div class="outline-text-3" id="text-org1ecc2bb">
<p>
GC调优首先要选择合适的堆大小。过大可能导致虚拟内存不足，引发磁盘IO和性能问题。一个经验法则是，一次Full GC应该释放70%的空间。设置堆大小的参数有
</p>
<ul class="org-ul">
<li>-Xms1024m</li>
<li>-Xmx4096m</li>
</ul>


<p>
决定了堆大小之后，接着要决定有多少空间分配给新生代，多少分配给老生代。如果新生代空间过大，垃圾收集的频率较低，新生代进入老生代的对象也更少。但是老生代相对较小，容易被填满而引发Full GC。相关的标志有：
</p>

<ul class="org-ul">
<li>-XX:NewRatio=N 新生代比例</li>
<li>-XX:NewSize=N 新生代大小</li>
<li>-XX:MaxNewSize=N 新生代最大大小</li>
<li>-XmnN 同时设置NewSize和MaxNewSize</li>
</ul>

<p>
新生代的大小根据公式
</p>
<blockquote>
<p>
堆大小/(1+NewRatio)
</p>
</blockquote>
<p>
决定。NewRatio的默认值是2。
</p>
</div>
</div>

<div id="outline-container-org81ca9ec" class="outline-3">
<h3 id="org81ca9ec">永久代和元空间</h3>
<div class="outline-text-3" id="text-org81ca9ec">
<p>
JVM载入类的时候需要记录这些类的相关信息，保存在永久代（Permgen或Permanent Generation，Java 7）或元空间（Metaspace，Java 8）中。在64位JVM上，默认永久代大小最大值为82MB。元空间大小没有限制。
</p>

<ul class="org-ul">
<li>-XX:PermSize=N</li>
<li>-XX:MaxPermSize=N</li>
<li>-XX:MetaspaceSize=N</li>
<li>-XX:MaxMetaspaceSize=N</li>
<li>jmap -permstat（Java 7）</li>
<li>jmap -clstats（Java 8）</li>
</ul>
</div>
</div>

<div id="outline-container-org4d9c2a6" class="outline-3">
<h3 id="org4d9c2a6">并发控制</h3>
<div class="outline-text-3" id="text-org4d9c2a6">
<p>
除了Serial之外，垃圾收集器都是多线程的。如果CPU数量小于8，每个CPU上会运行一个垃圾回收线程。如果数量大于8，线程数量是8 + ((N-8)*5/8)，这里N是CPU数量。考虑一个16核CPU的服务器同时运行4个JVM实例。每个JVM默认启动13个垃圾收集线程。如果同时执行垃圾收集工作，机器上会启动52个CPU密集型的线程，大量竞争CPU资源。因此对于一个服务器运行多个JVM的情况，需要通过-XX:ParallelGCThreads=N适当调整GC线程数量。
</p>
</div>
</div>

<div id="outline-container-orgad455d2" class="outline-3">
<h3 id="orgad455d2">自适应堆调整</h3>
<div class="outline-text-3" id="text-orgad455d2">
<p>
JVM提供了自适应堆调整的功能，根据运行情况自动调整堆、代和Survivor大小。
</p>

<ul class="org-ul">
<li>-XX:+PrintAdaptiveSizePolicy 观察自适应调整行为</li>
<li>-XX:-UseAdaptiveSizePolicy 关闭自适应调整</li>
</ul>
</div>
</div>

<div id="outline-container-orgf3dfc83" class="outline-3">
<h3 id="orgf3dfc83">垃圾回收工具</h3>
<div class="outline-text-3" id="text-orgf3dfc83">
<p>
Java提供了一些标志用例记录GC情况
</p>

<ul class="org-ul">
<li>-verbose:gc</li>
<li>-XX:+PrintGC</li>
<li>-XX:+PrintGCDetails</li>
<li>-XX:+PrintGCTimeStamps</li>
<li>-XX:+PrintGCDateStamps</li>
<li>-Xloggc:filename</li>
<li>-XX:+UseGCLogfileRotation</li>
<li>-XX:NumberOfGCLogfiles=N</li>
<li>-XX:GCLogfileSize=N</li>
</ul>

<p>
使用jstat也可以查看GC信息：
</p>
<div class="org-src-container">
<pre class="src src-shell">jstat -gcutil &lt;PID&gt; &lt;PeriodInMillisecond&gt;
</pre>
</div>

<p>
命令输出的各列为：
</p>
<ul class="org-ul">
<li>S0、S1 Survivor区</li>
<li>E Eden</li>
<li>O 老生代</li>
<li>P 永久代</li>
<li>YGC 新生代</li>
<li>YGCY 新生代收集时间</li>
<li>FGC Full GC</li>
<li>FGCT Full GC时间</li>
<li>GCT GC时间</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orga3c24e5" class="outline-2">
<h2 id="orga3c24e5">垃圾收集算法</h2>
<div class="outline-text-2" id="text-orga3c24e5">
</div>
<div id="outline-container-org42296d8" class="outline-3">
<h3 id="org42296d8">Throughput垃圾收集算法</h3>
<div class="outline-text-3" id="text-org42296d8">
<p>
当Eden空间快耗尽时，Throughput开始Minor GC，将对象从Eden空间移走，一部分移动到老年代，一部分移动到一个Survivor空间中。在Minor GC之后，Eden空间和一个Survivor空间清空。在进行Full GC时，Throughput将Eden和2个Survivor中的对象移动到老生代，并对老生代中的对象进行压缩。Full GC之后，Eden和2个Survivor清空。大部分情况下，老生代的对象不会回收。如果老生代填满，JVM会发起Full GC回收老生代中的对象。
</p>


<p>
对Throughput的优化主要是针对GC停顿时间。加大堆可以降低Full GC频率，但是增加了Full GC的时间。指标-XX:MaxGCPauseMillis=N设定了最大可停顿时间。如果这个值非常小，JVM会频发发生Full GC，老年代中的对象也非常少。标志-XX:GCTimeRatio=N可以设定垃圾收集时间占比，二者的关系是
</p>
<blockquote>
<p>
来及收集时间占比 = 1/(1+GCTimeRatio)
</p>
</blockquote>
<p>
GCTimeRatio的默认值是99，即1%的时间消耗在垃圾收集上。
</p>
</div>
</div>

<div id="outline-container-org635d436" class="outline-3">
<h3 id="org635d436">CMS垃圾收集器</h3>
<div class="outline-text-3" id="text-org635d436">
<p>
当堆的使用达到一定程度后（默认情况下，老生代空闲消耗70%时），CMS启动后台扫描线程回收不再使用的对象。并发回收由以下几个阶段组成：
</p>

<ul class="org-ul">
<li>初始阶段（CMS-initial-mark）。暂停应用线程，找到垃圾回收根节点对象。</li>
<li>标记阶段（CMS-concurrent-mark）。标记堆的使用情况，不会暂停应用。</li>
<li>预清理阶段（CMS-concurrent-preclean）。</li>
<li>重新标记阶段（CMS-concurrent-abortable-preclean）。</li>
<li>清除阶段（CMS-concurrent-sweep）。</li>
<li>并发重置阶段（CMS-concurrent-reset）。回收老年代中的对象。</li>
</ul>

<p>
新生代和老生代的清理可以并发执行。和其他算法不同的是，除非发生Full GC，CMS不会调整新生代大小。
</p>


<p>
CMS垃圾收集可能存在以下问题。首先是并发模式失效（concurrent mode failure）。如果新生代垃圾收集时，老生代没有足够的空间容纳晋升对象，CMS会退化为Full GC，所用应用线程中断，执行单线程垃圾收集。第二个问题是晋升失效（promotion failed）。这个问题是由于老生代碎片过多导致对象晋升失败，开始Full GC。因为要对老生代进行压缩，晋升失效引起的停顿时间更长。第三个问题是永久代空间耗尽，CMS也会退化为Full GC。
</p>


<p>
因此CMS调优的主要任务是避免并发模式失效和晋升失效。并发模式失效主要是由于老年代回收速度过慢，当新生代需要进行垃圾收集时，老年代没有足够的空间。因此解决的方法有
</p>

<ul class="org-ul">
<li>增大老年代空间。增加堆空间或只移动部分对象到老年代。</li>
<li>提高后台回收线程频率，提高老年代回收速度。</li>
<li>使用更多的后台回收线程，提高老年代回收速度。</li>
</ul>

<p>
控制回收时机的标志有-XX:+UseCMSInitiatingOccupancyOnly和-XX:UseCMSInitiatingOccupancyFraction=N（默认值70）。如果前者为true，当老年点使用率超过后者时，CMS会立即启动回收。如果GC日志中出现了并发模式失效，可以找到之前最近的一条初始阶段日志，计算当时老年代的比例，并调整GC参数。
</p>


<p>
控制回收线程数的标志是-XX:ConcGCThreads=N。默认情况下，这个值根据标志ParallelGCThreads计算得出：
</p>
<blockquote>
<p>
默认ConcGCThreads值=(3 + ParallelGCThreads) / 4
</p>
</blockquote>


<p>
在Java 8中，CMS会默认收集不再载入的类（默认-XX:+CMSClassUnloadingEnabled）。
</p>
</div>
</div>

<div id="outline-container-org3190086" class="outline-3">
<h3 id="org3190086">G1垃圾收集器</h3>
<div class="outline-text-3" id="text-org3190086">
<p>
G1垃圾收集器最大的不同在于将代划分为很多区（Region），属于同一个代的区不一定是连续的。这么做是观察到垃圾对象不是均匀分布的，存在一定的聚集性。G1会关注于垃圾最多的分区。G1同样把新生代划分为若干区，目的是快速晋升对象和调整代的大小。
</p>


<p>
G1的并发周期包括
</p>
<ul class="org-ul">
<li>初始标记阶段（initail-mark）。暂停所有应用线程，执行新生代垃圾收集，标记老生代对象。</li>
<li>扫描根分区（concurrent-root-region-scan）。并发执行。</li>
<li>并发标记（concurrent-mark）。</li>
<li>重新标记（remark）。中断应用线程。</li>
<li>清理（cleanup）。中断应用线程。</li>
<li>并发清理（concurrent-cleanup）。</li>
<li>混合式GC（mixed gc）。</li>
</ul>

<p>
G1可能遇到的问题有
</p>
<ul class="org-ul">
<li>并发模式失效。</li>
<li>晋升失效。</li>
<li>疏散失效。</li>
<li>巨型对象分配失败。</li>
</ul>

<p>
调优G1使用的标志主要是-XX:MaxGCPauseMillis=N。在G1中的默认值是200。G1会根据这值自动调整堆大小、新生代和老生代比例、后台处理时机和晋升阈值等。此外还可以调整-XX:ParallelGCThreads=N和-XX:ConcGCThreads=N。在G1中，-XX:ConcGCThreads=N的默认值是
</p>
<blockquote>
<p>
ConcCGThreads = (ParallelGCThreads + 2) / 4
</p>
</blockquote>

<p>
为了让G1更早的开始垃圾收集，可以设置-XX:+InitiatingHeapOccupancyPercent=N。当堆的占用超过这个比例时，G1开始垃圾收集。这个值默认是45。
</p>


<p>
为了避免晋升失败，可以增加-XX:G1MixedGCCountTarget=N的值（默认8），代价是同时增大了混合GC的停顿时间。
</p>
</div>
</div>

<div id="outline-container-org09bf0b3" class="outline-3">
<h3 id="org09bf0b3">晋升和Survivor</h3>
<div class="outline-text-3" id="text-org09bf0b3">
<p>
如果恰好一个临时对象刚刚创建后JVM开始了GC，这个新对象还不能被回收，但它的生命周期又很短，不适合移动到老生代。因此JVM提供了Suvivor保存这样的对象。使用Eden和Suvivor的划分，使得对象更可能的被回收，而不是填满老生代。为了进一步避免新生代对象直接进入老生代，Survivor又分成2部分。每次Minor GC时，将Eden和一个Survivor清空，将任然活跃的对象移动到另一个Survivor中。如果目标Survivor填满，Eden活跃对象直接进入老年代。如果一个对象经历了多个GC周期后仍然在Survivor中存活，这个对象被移动到老年代。这里的GC周期数叫做晋升阈值（tenuring threshold）。垃圾收集器会从1到-XX:MaxTenuringThreshold=N选择一个合适的值作为晋升阈值。初始的晋升阈值是-XX:InitialTenuringThreshold=N。不同垃圾收集器中，这些标志的值不同
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">垃圾收集器</td>
<td class="org-right">InitialTenuringThreshold</td>
<td class="org-right">MaxTenuringThreshold</td>
</tr>

<tr>
<td class="org-left">Throughput</td>
<td class="org-right">7</td>
<td class="org-right">15</td>
</tr>

<tr>
<td class="org-left">CMS</td>
<td class="org-right">6</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-left">G1</td>
<td class="org-right">7</td>
<td class="org-right">15</td>
</tr>
</tbody>
</table>

<p>
JVM还提供了一个标志-XX:+AlwaysTenure（默认false），等效于将MaxTenuringThreshold设置为0。与之相对应的是-XX:+NeverTenure，相当于将晋升阈值设置为无限大，只要Survivor有空间，就不会发生对象晋升。
</p>


<p>
作为新生代的一部分，Survivor空间的大小可以由JVM动态决定。影响Survivor初始的大小的标志是-XX:InitialSurvivorRation=N，默认是8，表示一个Survivor空间占新生代的10%（1/(initial<sub>survivor</sub><sub>ratio</sub>+2)）。
Survivor的最大空间由-XX:MinSurvivorRatio=N决定（没错，就是Min）。Survivor大小和这个值的关系是
</p>
<blockquote>
<p>
Survivor最大空间=新生代空间/(MinSurvivorRatio+2)
</p>
</blockquote>

<p>
JVM调整Survivor大小的依据是回收后Survivor的使用情况。默认情况下，Survivor在回收后应当有50%是空闲的。这个值可以由-XX:TargetSurvivorRatio=N控制。
</p>


<p>
对于对象晋升的情况，可以使用-XX:+PrintTenuringDistribution标志来观察。在观察GC日志时，最重要的是观察Minor GC中是否发生Survivor空间过小，对象直接晋升到老年代的情况。这样会让大量短期对象进入老年代，导致频繁Full GC。
</p>
</div>
</div>


<div id="outline-container-org4c9a633" class="outline-3">
<h3 id="org4c9a633">大对象</h3>
<div class="outline-text-3" id="text-org4c9a633">
<p>
Eden分配速度快的原因在于TLAB（Thread Local Allocation Buffer，线程本地分配缓冲区）。TLAB可以避免内存分配时的竞争，它由JVM管理。TLAB是Eden中的一部分，对象首先在这里分配。如果TLAB耗尽，对象直接在堆上分配。有3个因素可能影响TLAB的大小：
</p>

<ul class="org-ul">
<li>应用线程数</li>
<li>Eden大小</li>
<li>线程分配率</li>
</ul>

<p>
使用-XX:+PrintTLAB可以查看TLAB的分配情况。其中的slow就是TLAB外对象分配的统计。使用-XX:+TLABSize=N可以指定TLAB的初始大小（默认0，自动调整）。-XX:-ResizeTLAB可以避免每次GC时调整TLAB大小。TLAB的最小值由-XX:MinTLABSize=N决定，默认是2KB。使用-XX:-UseTLAB可以关闭TLAB。
</p>


<p>
如果一个对象太大，以至于无法在Eden中分配，JVM会直接在老生代中分配这个对象。这样的对象叫做巨型对象（Humongous Object）。巨型对象会降低程序性能。
</p>
</div>
</div>

<div id="outline-container-orgaf9347b" class="outline-3">
<h3 id="orgaf9347b">G1分区大小</h3>
<div class="outline-text-3" id="text-orgaf9347b">
<p>
G1分区最小是1MB，最大32MB。如果堆大于2GB，分区大小由下面的公式决定
</p>
<blockquote>
<p>
分区大小 = 1 &lt;&lt; log(初始堆大小/2048)
</p>
</blockquote>

<p>
也可以用-XX:G1HeapRegionSize=N设定。这个值要设置成2的方幂。在选择分区大小时，应当尽量让分区数接近2048，以便G1发挥最佳性能。
</p>


<p>
对于巨型对象，G1需要连续的分区来分配空间。如果找不到这样的分区，必须进行Full GC。G1回收巨型对象比其他垃圾收集器更快，可以将整个区一次性回收。对G1来说，超过分区一半容量的对象就是巨型对象。
</p>
</div>
</div>
</div>

<div id="outline-container-orgcefd1c2" class="outline-2">
<h2 id="orgcefd1c2">堆内存最佳实践</h2>
<div class="outline-text-2" id="text-orgcefd1c2">
</div>
<div id="outline-container-orga808713" class="outline-3">
<h3 id="orga808713">查看堆</h3>
<div class="outline-text-3" id="text-orga808713">
<p>
分析堆最简单的方法是查看堆直方图：
</p>
<div class="org-src-container">
<pre class="src src-shell">jcmd &lt;PID&gt; GC.class_histogram
jmap -histo &lt;PID&gt;
jmap -histo:live &lt;PID&gt;
</pre>
</div>

<p>
另一个方法是转储堆：
</p>
<div class="org-src-container">
<pre class="src src-shell">jcmd &lt;PID&gt; GC.heap_dump /path/to/dump.hprof [-all]
jmap -dump:live,<span style="color: #a0522d;">file</span>=/path/to/dump.hprof &lt;PID&gt;
</pre>
</div>
</div>
</div>


<div id="outline-container-orgc4d656b" class="outline-3">
<h3 id="orgc4d656b">内存溢出</h3>
<div class="outline-text-3" id="text-orgc4d656b">
<p>
以下4中情况下，JVM会抛出内存溢出（OutOfMemory）：
</p>

<ul class="org-ul">
<li>JVM没有原生内存可用。32位JVM可用的最大内存是4GB（在部分Windows上是3GB，在部分Linux上是3.5GB）。</li>
<li>永久代或元空间内存不足。类数量过多，或类加载器泄漏。</li>
<li>Java堆内存不足。</li>
<li>GC耗时太多。</li>
</ul>

<p>
下面的标志可以让JVM生成转储文件
</p>
<ul class="org-ul">
<li>-XX:+HeapDumpOnOutOfMemoryError</li>
<li>-XX:HeapDumpPath=path</li>
<li>-XX:+HeapDumpAfterFullGC</li>
<li>-XX:+HeapDumpBeforeFullGC</li>
</ul>
</div>
</div>

<div id="outline-container-org92653d8" class="outline-3">
<h3 id="org92653d8">减少内存使用</h3>
<div class="outline-text-3" id="text-org92653d8">
<ul class="org-ul">
<li>减少对象大小</li>
<li>延迟初始化</li>
<li>尽早清理（将不再使用的数组成员设置为null）</li>
<li>避免为不可变对象建立副本</li>
<li>对于大量重复字符串，使用intern()并设置-XX:StringTableSize=N（默认60013）</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org86ceb33" class="outline-2">
<h2 id="org86ceb33">原生内存最佳实践</h2>
<div class="outline-text-2" id="text-org86ceb33">
<p>
为了将JVM内存最小号，应当限制下列内存的使用：
</p>

<ul class="org-ul">
<li>堆。最大的一块内存。</li>
<li>线程栈。</li>
<li>代码缓存。</li>
<li>直接字节缓冲区。</li>
</ul>
</div>

<div id="outline-container-org3138318" class="outline-3">
<h3 id="org3138318">原生内存</h3>
<div class="outline-text-3" id="text-org3138318">
<p>
使用JNI和NIO的allocateDirect()都可以分配原生内存。原生内存可以避免JVM和C库之间的内存复制，常用于文件系统或套接字（socket）的缓冲区。allocateDirect()方法非常昂贵，理想方案是每个线程拥有一个直接分配内存作为线程本地对象。Java提供了标志-XX:MaxDirectoryMemorySize=N来限制直接字节缓冲区大小，默认值是0，表示没有限制。
</p>


<p>
从Java 8开始，使用-XX:NativeMemoryTracking=off|summary|detail可以观察原生内存的分配。这项技术叫做原生内存跟踪（Native Memory Tracking）。开启后，可以通过jcmd观察原生内存信息：
</p>
<div class="org-src-container">
<pre class="src src-shell">jcmd &lt;PID&gt; VM.native_memory summary
</pre>
</div>

<p>
如果使用了-XX:+PrintNMTStatistics，在Java程序退出时会打印内存分配信息。NMT提供了两类关键信息：总提交大小（实际消耗的物理内存）和每部分的提交大小。NMT的一个功能是支持跟踪变化：
</p>
<div class="org-src-container">
<pre class="src src-shell">jcmd &lt;PID&gt; VM.native_memory baseline
jcmd &lt;PID&gt; VM.native_memory summary.diff
</pre>
</div>
</div>
</div>


<div id="outline-container-orga041c05" class="outline-3">
<h3 id="orga041c05">大页</h3>
<div class="outline-text-3" id="text-orga041c05">
<p>
页（page）是内存管理的单位。要分配1个字节，首先会分配一个页，然后在页中分配字节。后续的内存分配继续在这个页中执行，知道页分配完毕，系统重新分配一个新页。为了支持多任务，系统会将暂时不使用的页缓存到磁盘上，这种机制叫做分页机制。因此，虚拟内存提供的页的数量多于物理内存实际提供的数量。系统使用全局页表来维护内存页和物理页的映射关系，其中常用的页保存在TLB（Translation Lookaside Buffers）中。通过TLB访问页的速度比页表更快。由于TLB的容量有限，操作系统使用LRU（Least Recently Used）策略更新TLB。一个TLB表项是一个页，如果增加页的大小，可以提高TLB覆盖的内存范围，提高命中率。Java提供了-XX:+UseLargePages来尝试使用大页。这个标志要和操作系统配置配合使用。对于Windows和Linux，大页通常占2MB。
</p>

<ul class="org-ul">
<li>Linux大页。
<ul class="org-ul">
<li>确认大页大小。</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-shell">grep Hugepagesize /proc/meminfo
</pre>
</div>
<ul class="org-ul">
<li>计算大页数量。如果JVM分配4GB的堆，系统支持2MB的大页，则堆需要2048个大页。考虑到非堆内存也可能使用大页，保留10%的裕度，可以知道系统需要约2200个大页。</li>
<li>配置操作系统。</li>
</ul>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #483d8b;">echo</span> 2200 &gt; /proc/sys/vm/nr_hugepages
</pre>
</div>
<p>
修改/etc/sysctl.conf，添加
</p>
<div class="org-src-container">
<pre class="src src-text">sys.nr_hugepages=2200
</pre>
</div>
<ul class="org-ul">
<li>修改用户限制。修改/etc/security/limits.conf，为JVM用户添加</li>
</ul>
<div class="org-src-container">
<pre class="src src-text">jvmuser soft memlock 4613734400
jvmuser hard memlock 4613734400
</pre>
</div>
<p>
然后重新登录用户，让变更生效。
</p>
<ul class="org-ul">
<li>验证。</li>
</ul>
<div class="org-src-container">
<pre class="src src-shell">java -Xms4G -Xmx4G -XX:+UseLaargePages -version
</pre>
</div>
<p>
如果命令没有报告错误，说明大页配置正确。
</p>
<ul class="org-ul">
<li>Linux透明大页。</li>
</ul>
<p>
从2.6.32开始，Linux支持透明大页。开启透明大页：
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #483d8b;">echo</span> always &gt; /sys/kernel/mm/transparent_hugepage/enabled
</pre>
</div>
<p>
开启透明大页时，JVM不需要指定UseLargePages标志。如果配置了这个标志，Java不会使用传统大页或标准页，不会使用透明大页。
</p>
<ul class="org-ul">
<li>Windows</li>
</ul>
<p>
Windows中启用大页需要允许用户锁定内存页（lock pages into memory）。方法是
</p>
<ul class="org-ul">
<li>启动管理控制台（Microsoft Management Center）。</li>
</ul>
<div class="org-src-container">
<pre class="src src-shell">mmc
</pre>
</div>
<ul class="org-ul">
<li>点击“文件”菜单，选择“添加/删除管理单元”，添加“组策略对象编辑器”。</li>
<li>在左侧面板中，依次展开本地计算机策略、计算机配置、Windows配置、安全配置、本地策略，选择“用户权限分配”文件夹。</li>
<li>在右侧面板中，双击“锁定内存页”，添加用户或组，点击确定，退出Microsoft管理控制台。</li>
<li>重新启动。</li>
<li>验证。（同Linux）</li>
</ul>
</div>
</div>

<div id="outline-container-orgc1cea9e" class="outline-3">
<h3 id="orgc1cea9e">OOP压缩</h3>
<div class="outline-text-3" id="text-orgc1cea9e">
<p>
对于同一任务，32位JVM的性能比64位JVM好5%-20%，这是因为前者对象引用占4字节，后者是8字节，使得堆中留给其他数据的空间更少，因此需要更多的GC周期。针对这一天Java提供了-XX:+UseCompressedOops标志（在Java 7+上默认开启）。开启这个标志后，当堆内存在32GB（2<sup>35</sup>）以下时，JVM采用32位表示一个引用。对象的实际地址是引用值左移3位（乘以8）。
</p>
</div>
</div>
</div>

<div id="outline-container-org546296f" class="outline-2">
<h2 id="org546296f">线程与同步的性能</h2>
<div class="outline-text-2" id="text-org546296f">
</div>
<div id="outline-container-orgafe1622" class="outline-3">
<h3 id="orgafe1622">线程池</h3>
<div class="outline-text-3" id="text-orgafe1622">
<p>
线程池的大小对程序性能有很大的影响。假设系统有4个CPU，最大线程数最少设设置为4。虽然JVM有一些其他线程进行工作，这些线程几乎从来不会占用一个CPU。此外还要考虑任务队列的大小。假设任务队列长度是30000，有4个CPU可用，每个任务需要50毫秒，那么清空任务队列需要6分钟。对于一个Web服务器，用户很少会等待6分钟知道请求返回。因此应当减少任务队列长度。
</p>
</div>
</div>


<div id="outline-container-orgc72f55a" class="outline-3">
<h3 id="orgc72f55a">线程同步</h3>
<div class="outline-text-3" id="text-orgc72f55a">
<p>
线程同步有以下4中方式：
</p>

<ul class="org-ul">
<li>synchronized</li>
<li>java.util.concurrent.lock.Lock</li>
<li>java.util.concurrent</li>
<li>java.util.concurrent.atomic</li>
</ul>


<p>
当任务以并行方式运行时，可以获得的加速比最大为（Amdahl定律）
</p>
<blockquote>
<p>
加速比=1/(1-P+P/N)
</p>
</blockquote>

<p>
其中P是程序并行部分需要的时间，N是线程数。
</p>


<p>
对于非竞争性的synchronized锁叫做非膨胀锁（uninflated），开销在几百纳秒。非竞争的CAS开销更小。在竞争条件下，synchronized变成膨胀锁（inflated）。CAS原语基于一种乐观的策略：设置某个值，执行一些代码，然后通过检查初始值是否被改动来判断是否发生竞争。如果发生了竞争，CAS必须重新执行代码。此外，根据Java内存模型，volatile对象的读写前后会插入内存屏障。
</p>
</div>
</div>


<div id="outline-container-orgfabec41" class="outline-3">
<h3 id="orgfabec41">伪共享</h3>
<div class="outline-text-3" id="text-orgfabec41">
<p>
前面提到内存管理的单位是页。这里采用了一种叫做局部性原理的思路。从存储器加载数据时，为了提高性能，将其附近的数据一起加载。这个是局部性原理在空间上的应用。在时间上的应用就是LRU策略。CPU在管理高速缓存时也采用了局部性原理，表现在数据按缓存行（cacheline）加载。如果两个CPU在使用不同的两个对象。如果这两个对象位于同一个缓存行中，两个CPU会同时缓存这两个对象。当一个CPU修改对象时，另一个CPU虽然没有使用该对象，但是由于缓存失效，必须重新从内存读取数据。这种情况叫做伪共享。伪共享会引起CPU通信和内存读取，对性能造成影响。解决伪共享的方法是对变量前后的内存空间进行填充。可以手动填充，或者使用Java 8提供的@sum.misc.Contented注解，以及-XX:-RestrictContented标志。
</p>
</div>
</div>


<div id="outline-container-org84674b0" class="outline-3">
<h3 id="org84674b0">JVM线程调优</h3>
<div class="outline-text-3" id="text-org84674b0">
<ul class="org-ul">
<li>栈大小。64位JVM默认的栈大小是1MB，在Linux和Windows上，32位JVM默认的栈大小是320KB。对于内存较小的机器，调整栈大小可以为堆预留更多空间。调整栈大小的标志是-Xss=N。</li>
<li>偏向锁。JVM默认的锁分配方式是按照访问的频繁程序优先分配，这种方式叫做偏向锁。使用-XX:-UseBiasedLocking可以关闭偏向锁，改为轮转方式。如果系统中各应用线程是对等的，关闭偏向锁可以节省一些性能。</li>
<li>优先级。</li>
</ul>
</div>
</div>


<div id="outline-container-org3a872eb" class="outline-3">
<h3 id="org3a872eb">监控线程</h3>
<div class="outline-text-3" id="text-org3a872eb">
<p>
在监控线程时有两个指标值得关注：线程数量和线程等待锁或其他资源的时间。
</p>
</div>
</div>
</div>

<div id="outline-container-org4bb040f" class="outline-2">
<h2 id="org4bb040f">数据库性能的最佳实践</h2>
<div class="outline-text-2" id="text-org4bb040f">
<p>
使用JDBC时推荐使用PreparedStatement，节省数据库预处理时间。
</p>


<p>
事务隔离模式：
</p>
<ul class="org-ul">
<li>序列化。</li>
<li>可重复读。可能出现幻读（phantom read）。</li>
<li>已提交读。</li>
<li>未提交读。可能出现脏读（dirty read）。</li>
</ul>
</div>
</div>

<div id="outline-container-orgf82c848" class="outline-2">
<h2 id="orgf82c848">Java SE API技巧</h2>
<div class="outline-text-2" id="text-orgf82c848">
</div>
<div id="outline-container-orge68d5c6" class="outline-3">
<h3 id="orge68d5c6">缓冲式I/O</h3>
<div class="outline-text-3" id="text-orge68d5c6">
<p>
InputStream/OutputStream每次读写一个字符。对于FileInputStream/FileOutputStream，每次都会触发磁盘读写操作。因此，要使用BufferedInputStream/BufferedOutputStream封装。
</p>
</div>
</div>


<div id="outline-container-org53a47d5" class="outline-3">
<h3 id="org53a47d5">随机数</h3>
<div class="outline-text-3" id="text-org53a47d5">
<p>
Java提供了3个随机数生成器：
</p>

<ul class="org-ul">
<li>java.util.Random</li>
<li>java.util.concurrent.ThreadLocalRandom</li>
<li>java.security.SecureRandom</li>
</ul>

<p>
Random的nextGaussian()方法是同步的，任何生成随机数的方法都要调用这个方法，因此会发生竞争。ThreadLocalRandom因为引入的线程本地特性，不会引发竞争。SecureRandom是根据系统事件提供的安全随机数，但是nextRandom()消耗的时间是不确定的。
</p>
</div>
</div>

<div id="outline-container-org6c9e80a" class="outline-3">
<h3 id="org6c9e80a">字符串</h3>
<div class="outline-text-3" id="text-org6c9e80a">
<p>
下面的语句实际上非常高效：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #228b22;">String</span> <span style="color: #a0522d;">answer</span> = integerPart + <span style="color: #8b2252;">"."</span> + mantissa;
</pre>
</div>

<p>
Java会将其编译为
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #228b22;">String</span> <span style="color: #a0522d;">answer</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">StringBuilder</span>(integerPart).append(<span style="color: #8b2252;">"."</span>).append(mantissa).toString();
</pre>
</div>

<p>
而下面的语句就不同了：
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #228b22;">String</span> <span style="color: #a0522d;">answer</span> = integerPart;
answer += <span style="color: #8b2252;">"."</span>;
answer += mantissa;
</pre>
</div>
</div>
</div>

<div id="outline-container-org97dc3ed" class="outline-3">
<h3 id="org97dc3ed">日志</h3>
<div class="outline-text-3" id="text-org97dc3ed">
<p>
-XX:+PrintGCDetails的开销非常低，应该一直打开。
</p>
</div>
</div>

<div id="outline-container-org1cfa42c" class="outline-3">
<h3 id="org1cfa42c">容器</h3>
<div class="outline-text-3" id="text-org1cfa42c">
<p>
ArrayList包含一个真正的数组。ArrayList类调整数组大小的方法是增加当前容量的一半。
</p>
</div>
</div>

<div id="outline-container-org2d9e84e" class="outline-3">
<h3 id="org2d9e84e">Lambda表达式</h3>
<div class="outline-text-3" id="text-org2d9e84e">
<p>
在Java 8中，lambda表达式会构造成一个静态方法，通过一个特殊的辅助类调用。而匿名类会生成一个真正的Java类，有单独的class文件，通过类加载器加载。
</p>
</div>
</div>


<div id="outline-container-org8fd5919" class="outline-3">
<h3 id="org8fd5919">stream和过滤器</h3>
<div class="outline-text-3" id="text-org8fd5919">
<p>
通常过滤器比迭代方式更快。
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2019-09-23 周一 21:12</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>

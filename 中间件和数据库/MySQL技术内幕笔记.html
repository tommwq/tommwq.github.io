<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-09-23 周一 18:45 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MySQL技术内幕</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">MySQL技术内幕</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org14ec279">第一章 MySQL体系结构和存储引擎</a></li>
<li><a href="#org407b71c">第二章 InnoDB存储引擎</a></li>
<li><a href="#orgb9a8dd4">第三章 文件</a></li>
<li><a href="#org3c09c76">第四章 表</a></li>
<li><a href="#orgeffd590">第五章 索引与算法</a></li>
<li><a href="#org97a6ccb">第六章 锁</a></li>
<li><a href="#org571384a">第七章 事务</a></li>
<li><a href="#org374fda0">第八章 备份与恢复</a></li>
<li><a href="#org97d9f43">第九章 性能优调</a></li>
<li><a href="#org6b736f3">第十章 InnoDB存储引擎源代码的编译和调试</a></li>
</ul>
</div>
</div>

<div id="outline-container-org14ec279" class="outline-2">
<h2 id="org14ec279">第一章 MySQL体系结构和存储引擎</h2>
<div class="outline-text-2" id="text-org14ec279">
<p>
MySQL配置文件加载顺序如下：
</p>
<blockquote>
<p>
/etc/my.cnf
/etc/mysql/my.cnf
<i>usr/local/mysql/etc/my.cnf
~</i>.my.cnf
</p>
</blockquote>

<p>
当配置冲突时，以最后读取的值为准。在连接到MySQL服务器后，可以通过查询变量的方式得到配置信息，比如
</p>
<div class="org-src-container">
<pre class="src src-sql">show variables <span style="color: #a020f0;">like</span> <span style="color: #8b2252;">'datadir'</span>\G;
</pre>
</div>

<p>
MySQL由以下几个部分组成：
</p>

<ul class="org-ul">
<li>连接池</li>
<li>管理服务和工具</li>
<li>SQL接口</li>
<li>查询分析器</li>
<li>优化器</li>
<li>缓存组件</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ul>

<p>
InnoDB将表的存储按照主键顺序存放。如果用户没有定义主键，InnoDB会为每行生成一个6字节的ROWID作为主键。MySQL使用Memory引擎存储临时表。如果临时表体积过大，MySQL会使用MyISAM引擎将临时表保存到硬盘。Archive引擎使用zlib对行进行压缩，压缩比一般可以达到1:10。但是Archive只支持INSERT和SELECT操作，适合于保存归档数据。
</p>

<p>
查看存储引擎：
</p>
<div class="org-src-container">
<pre class="src src-sql">show engines\G;
</pre>
</div>
</div>
</div>

<div id="outline-container-org407b71c" class="outline-2">
<h2 id="org407b71c">第二章 InnoDB存储引擎</h2>
<div class="outline-text-2" id="text-org407b71c">
<p>
InnoDB拥有多个后台线程：1个Master线程，1个锁监控线程，1个错误监控线程和多个文件I/O线程。文件I/O线程中包括1个insert buffer线程，1个log线程和若干个read线程、write线程。read/write线程的数量可以通过参数配置：
</p>
<blockquote>
<p>
innodb<sub>read</sub><sub>io</sub><sub>threads</sub>
innodb<sub>write</sub><sub>io</sub><sub>threads</sub>
</p>
</blockquote>
<p>
默认情况下，read/write各有4个线程。
</p>

<p>
在MySQL 5.7.12中，有6个和线程数有关的配置
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">变量</td>
<td class="org-right">默认值</td>
</tr>

<tr>
<td class="org-left">innodb<sub>purge</sub><sub>threads</sub></td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">innodb<sub>read</sub><sub>io</sub><sub>threads</sub></td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">innodb<sub>write</sub><sub>io</sub><sub>threads</sub></td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">max<sub>delayed</sub><sub>threads</sub></td>
<td class="org-right">20</td>
</tr>

<tr>
<td class="org-left">max<sub>insert</sub><sub>delayed</sub><sub>threads</sub></td>
<td class="org-right">20</td>
</tr>

<tr>
<td class="org-left">myisam<sub>repair</sub><sub>threads</sub></td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
查看InnoDB状态：
</p>
<div class="org-src-container">
<pre class="src src-sql">show engine innodb status\G;
</pre>
</div>

<p>
输出如下：
</p>
<blockquote>
<p>
<code>===================================</code>
2019-03-12 09:35:11 0x7f84f4371700 INNODB MONITOR OUTPUT
<code>===================================</code>
Per second averages calculated from the last 34 seconds
</p>
<hr />
<p>
BACKGROUND THREAD
</p>
<hr />
<p>
srv<sub>master</sub><sub>thread</sub> loops: 681064 srv<sub>active</sub>, 0 srv<sub>shutdown</sub>, 5791300 srv<sub>idle</sub>
srv<sub>master</sub><sub>thread</sub> log flush and writes: 6472364
</p>
<hr />
<p>
SEMAPHORES
</p>
<hr />
<p>
OS WAIT ARRAY INFO: reservation count 42155056
OS WAIT ARRAY INFO: signal count 32089372
RW-shared spins 0, rounds 7196662, OS waits 3303974
RW-excl spins 0, rounds 34760929, OS waits 1023237
RW-sx spins 447372, rounds 11416120, OS waits 274441
Spin rounds per wait: 7196662.00 RW-shared, 34760929.00 RW-excl, 25.52 RW-sx
</p>
<hr />
<p>
TRANSACTIONS
</p>
<hr />
<p>
Trx id counter 93333812
Purge done for trx's n:o &lt; 93333812 undo n:o &lt; 0 state: running but idle
History list length 1570
LIST OF TRANSACTIONS FOR EACH SESSION:
&#x2014;TRANSACTION 421689502771488, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
&#x2014;TRANSACTION 421689502778784, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
&#x2014;TRANSACTION 421689502772400, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
&#x2014;TRANSACTION 421689502782432, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
&#x2014;TRANSACTION 421689502780608, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
&#x2014;TRANSACTION 421689502775136, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
&#x2014;TRANSACTION 421689502779696, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
&#x2014;TRANSACTION 421689502770576, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
&#x2014;TRANSACTION 421689502767840, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
&#x2014;TRANSACTION 421689502773312, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
&#x2014;TRANSACTION 421689502769664, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
&#x2014;TRANSACTION 421689502777872, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
&#x2014;TRANSACTION 421689502776960, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
&#x2014;TRANSACTION 421689502766928, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
&#x2014;TRANSACTION 421689502768752, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
</p>
<hr />
<p>
FILE I/O
</p>
<hr />
<p>
I/O thread 0 state: waiting for completed aio requests (insert buffer thread)
I/O thread 1 state: waiting for completed aio requests (log thread)
I/O thread 2 state: waiting for completed aio requests (read thread)
I/O thread 3 state: waiting for completed aio requests (read thread)
I/O thread 4 state: waiting for completed aio requests (read thread)
I/O thread 5 state: waiting for completed aio requests (read thread)
I/O thread 6 state: waiting for completed aio requests (write thread)
I/O thread 7 state: waiting for completed aio requests (write thread)
I/O thread 8 state: waiting for completed aio requests (write thread)
I/O thread 9 state: waiting for completed aio requests (write thread)
Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,
 ibuf aio reads:, log i/o's:, sync i/o's:
Pending flushes (fsync) log: 0; buffer pool: 0
124571129 OS file reads, 26524052 OS file writes, 5427449 OS fsyncs
0.00 reads/s, 0 avg bytes/read, 0.00 writes/s, 0.00 fsyncs/s
</p>
<hr />
<p>
INSERT BUFFER AND ADAPTIVE HASH INDEX
</p>
<hr />
<p>
Ibuf: size 1, free list len 6267, seg size 6269, 2094527 merges
merged operations:
 insert 1879363, delete mark 7937542, delete 1188002
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 1106407, node heap has 58 buffer(s)
Hash table size 1106407, node heap has 112 buffer(s)
Hash table size 1106407, node heap has 158 buffer(s)
Hash table size 1106407, node heap has 24 buffer(s)
Hash table size 1106407, node heap has 158 buffer(s)
Hash table size 1106407, node heap has 331 buffer(s)
Hash table size 1106407, node heap has 231 buffer(s)
Hash table size 1106407, node heap has 193 buffer(s)
44.68 hash searches/s, 68.82 non-hash searches/s
&#x2014;
LOG
&#x2014;
Log sequence number 112231797656
Log flushed up to   112231797656
Pages flushed up to 112231797656
Last checkpoint at  112231797647
0 pending log flushes, 0 pending chkp writes
12990458 log i/o's done, 0.00 log i/o's/second
</p>
<hr />
<p>
BUFFER POOL AND MEMORY
</p>
<hr />
<p>
Total large memory allocated 4397727744
Dictionary memory allocated 7980257
Buffer pool size   262144
Free buffers       8248
Database pages     252631
Old database pages 93091
Modified db pages  0
Pending reads      0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 422888493, not young 2525083138
0.00 youngs/s, 0.00 non-youngs/s
Pages read 124571039, created 846528, written 11800149
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 252631, unzip<sub>LRU</sub> len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
</p>
<hr />
<p>
INDIVIDUAL BUFFER POOL INFO
</p>
<hr />
<p>
&#x2014;BUFFER POOL 0
Buffer pool size   32768
Free buffers       1040
Database pages     31580
Old database pages 11637
Modified db pages  0
Pending reads      0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 52462948, not young 185829279
0.00 youngs/s, 0.00 non-youngs/s
Pages read 8892411, created 101468, written 1754099
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 31580, unzip<sub>LRU</sub> len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
&#x2014;BUFFER POOL 1
Buffer pool size   32768
Free buffers       1032
Database pages     31578
Old database pages 11636
Modified db pages  0
Pending reads      0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 52294129, not young 308271269
0.00 youngs/s, 0.00 non-youngs/s
Pages read 13290820, created 111468, written 1595236
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 31578, unzip<sub>LRU</sub> len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
&#x2014;BUFFER POOL 2
Buffer pool size   32768
Free buffers       1024
Database pages     31576
Old database pages 11635
Modified db pages  0
Pending reads      0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 52462642, not young 350034300
0.00 youngs/s, 0.00 non-youngs/s
Pages read 16047947, created 105476, written 1201892
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 31576, unzip<sub>LRU</sub> len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
&#x2014;BUFFER POOL 3
Buffer pool size   32768
Free buffers       1032
Database pages     31584
Old database pages 11638
Modified db pages  0
Pending reads      0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 52879897, not young 275047105
0.00 youngs/s, 0.00 non-youngs/s
Pages read 15047985, created 100932, written 1459512
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 31584, unzip<sub>LRU</sub> len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
&#x2014;BUFFER POOL 4
Buffer pool size   32768
Free buffers       1032
Database pages     31589
Old database pages 11640
Modified db pages  0
Pending reads      0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 53505172, not young 403243581
0.00 youngs/s, 0.00 non-youngs/s
Pages read 19339922, created 110118, written 1328343
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 31589, unzip<sub>LRU</sub> len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
&#x2014;BUFFER POOL 5
Buffer pool size   32768
Free buffers       1024
Database pages     31590
Old database pages 11641
Modified db pages  0
Pending reads      0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 53241394, not young 418984538
0.00 youngs/s, 0.00 non-youngs/s
Pages read 19658655, created 102432, written 1424145
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 31590, unzip<sub>LRU</sub> len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
&#x2014;BUFFER POOL 6
Buffer pool size   32768
Free buffers       1032
Database pages     31572
Old database pages 11634
Modified db pages  0
Pending reads      0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 53305540, not young 243370458
0.00 youngs/s, 0.00 non-youngs/s
Pages read 15695796, created 107520, written 1598917
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 31572, unzip<sub>LRU</sub> len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
&#x2014;BUFFER POOL 7
Buffer pool size   32768
Free buffers       1032
Database pages     31562
Old database pages 11630
Modified db pages  0
Pending reads      0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 52736771, not young 340302608
0.00 youngs/s, 0.00 non-youngs/s
Pages read 16597503, created 107114, written 1438005
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 31562, unzip<sub>LRU</sub> len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
</p>
<hr />
<p>
ROW OPERATIONS
</p>
<hr />
<p>
0 queries inside InnoDB, 0 queries in queue
0 read views open inside InnoDB
Process ID=6117, Main thread ID=140209283843840, state: sleeping
Number of rows inserted 22836410, updated 5456413, deleted 6946866, read 234157949609
0.00 inserts/s, 0.00 updates/s, 0.00 deletes/s, 5401.69 reads/s
</p>
<hr />
<p>
END OF INNODB MONITOR OUTPUT
<code>==========================</code>
</p>
</blockquote>

<p>
其中“BUFFER POOL AND MEMORY”部分显示了缓冲池大小，单位是“buffer frame”，通常是16KB大小。
</p>

<p>
InnoDB存储引擎的内存由以下几部分组成：
</p>

<ul class="org-ul">
<li>缓冲池（buffer pool）。innodb<sub>buffer</sub><sub>pool</sub><sub>size</sub>。</li>
<li>重做日志缓冲池（redo log buffer）。innodb<sub>log</sub><sub>buffer</sub><sub>size</sub>。</li>
<li>额外内存池（additional memory pool）。</li>
</ul>

<p>
InnoDB将数据文件按页（16K）为单位写入缓冲区。缓冲区中的数据页按类型分，有索引页、数据页、undo页、插入缓冲（insert buffer）、自适应散列索引（adaptive hash index）、InnoDB存储的锁信息（lock info）、数据字典信息（data dictionary）等。日志缓冲区（log<sub>buffer</sub>）用于保存重做（redo）日志。重做日志首先写入日志缓冲区，然后以一定频率写入重做日志文件。
</p>

<p>
InnoDB引擎中，和缓冲区大小相关的配置有：
</p>
<div class="org-src-container">
<pre class="src src-mysql">show variables like 'innodb%buffer%size'
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">innodb<sub>buffer</sub><sub>pool</sub><sub>chunk</sub><sub>size</sub></td>
<td class="org-right">134217728</td>
</tr>

<tr>
<td class="org-left">innodb<sub>buffer</sub><sub>pool</sub><sub>size</sub></td>
<td class="org-right">4294967296</td>
</tr>

<tr>
<td class="org-left">innodb<sub>change</sub><sub>buffer</sub><sub>max</sub><sub>size</sub></td>
<td class="org-right">25</td>
</tr>

<tr>
<td class="org-left">innodb<sub>log</sub><sub>buffer</sub><sub>size</sub></td>
<td class="org-right">16777216</td>
</tr>

<tr>
<td class="org-left">innodb<sub>sort</sub><sub>buffer</sub><sub>size</sub></td>
<td class="org-right">1048576</td>
</tr>
</tbody>
</table>

<p>
主线程（master thread）的优先级最高。主线程分为主循环（loop）、后台循环（background loop）、刷新循环（flush loop）、暂停循环（pause loop）。主线程根据情况在上面几个循环之间切换。在主循环中每隔1秒钟InnoDB会执行：
</p>

<p>
刷写日志到磁盘。
合并插入缓冲区（insert buffer，ibuf）。
最多刷写100个缓冲池脏页面。
如果没有用户活动，切换到background loop。
</p>

<p>
参数innodb<sub>max</sub><sub>dirty</sub><sub>pages</sub><sub>pct定义了脏页面比例阈值</sub>。在MysQL-8.0.13版本中，主线程源代码是storage/innobase/srv/srv0srv.cc中的srv<sub>master</sub><sub>thread函数</sub>。
</p>

<p>
InnoDB的关键技术特性有插入缓冲区、两次写和自适应散列索引（adaptive hash index）。考虑下面的表：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #a020f0;">CREATE</span> <span style="color: #a020f0;">TABLE</span> <span style="color: #483d8b;">user</span> (id <span style="color: #228b22;">INT</span> AUTO_INCREMENT, <span style="color: #a020f0;">name</span> <span style="color: #228b22;">VARCHAR</span>(32), <span style="color: #a020f0;">PRIMARY</span> <span style="color: #a020f0;">KEY</span>(id), <span style="color: #a020f0;">KEY</span>(<span style="color: #a020f0;">name</span>));
</pre>
</div>

<p>
name作为非聚集的辅助索引，在插入或更新时会产生随机访问，导致性能下降。为此InnoDB引入了插入缓冲区，将辅助索引写入内存，以一定频率刷新到磁盘。通过这种方式提高性能。插入缓冲区提高了性能，而两次写提高了可靠性。为了提高内存使用效率，InnoDB采用16KB作为页的大小。而很多操作系统的页设置为8KB或4KB，可能出现部分写（partial page write）的情况。doublewrite就是为了解决部分写引入的。doublewrite分为两部分，一部分是内存中的doublewrite buffer，占2MB。另一部分是磁盘上的共享表空间，也占2MB。在刷写脏页时，首先将原始数据写到doublewrite buffer，然后将doublewrite buffer数据写入共享表空间，并调用fsync让数据写入磁盘。接下来才执行实际的写操作，将doublewrite buffer中的各个页写入对应的表空间。在系统恢复时，对于发生部分写的页，InnoDB使用共享表空间中原始副本覆盖并应用重做日志。和doublewrite相关的统计数据有Innodb<sub>dblwr</sub><sub>pages</sub><sub>written和Innodb</sub><sub>dblwr</sub><sub>writes</sub>。如果二者的比值小于64，说明系统写入压力不大。自适应散列索引是InnoDB的一个查找优化特性。InnoDB监控对索引的查找，根据观察结果自动判断是否建立散列索引。自适应散列索引通过缓冲池的B+树构造，建立速度快，但不一定会覆盖全表。自适应散列索引只能查找等值查询。参数innodb<sub>adaptive</sub><sub>hash</sub><sub>index可以控制开启或关闭此特性</sub>。
</p>

<p>
两次写相关的状态有
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Innodb<sub>dblwr</sub><sub>pages</sub><sub>written</sub></td>
</tr>

<tr>
<td class="org-left">Innodb<sub>dblwr</sub><sub>writes</sub></td>
</tr>
</tbody>
</table>

<p>
自适应索引相关的变量有
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">innodb<sub>adaptive</sub><sub>flushing</sub></td>
<td class="org-right">ON</td>
</tr>

<tr>
<td class="org-left">innodb<sub>adaptive</sub><sub>flushing</sub><sub>lwm</sub></td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-left">innodb<sub>adaptive</sub><sub>hash</sub><sub>index</sub></td>
<td class="org-right">ON</td>
</tr>

<tr>
<td class="org-left">innodb<sub>adaptive</sub><sub>hash</sub><sub>index</sub><sub>parts</sub></td>
<td class="org-right">8</td>
</tr>

<tr>
<td class="org-left">innodb<sub>adaptive</sub><sub>max</sub><sub>sleep</sub><sub>delay</sub></td>
<td class="org-right">150000</td>
</tr>
</tbody>
</table>

<p>
参数innodb<sub>fast</sub><sub>shutdown控制了InnoDB关闭时的行为</sub>。它的取值可以是0、1或2。0表示InnoDB需要完成full purge和merge insert buffer操作，这些操作消耗大量时间。1是默认值，表示将缓冲池中的脏页面刷写到磁盘。2表示只将日志写入日志文件。但是下次启动时MySQL需要进行恢复。在恢复时InnoDB也提供了控制变量，叫做innodb<sub>force</sub><sub>recovery</sub>。它可以由7个值：
</p>

<ul class="org-ul">
<li>0。默认值。执行完整恢复操作。如果无法有效恢复，MySQL可能宕机。</li>
<li>1。忽略corrupt页。</li>
<li>2。阻止主线程运行。</li>
<li>3。不执行事务回滚。</li>
<li>4。不执行插入缓冲区合并。</li>
<li>5。不查看撤销日志，将未提交的事务当做已提交。</li>
<li>6。不执行前滚操作。</li>
</ul>
</div>
</div>

<div id="outline-container-orgb9a8dd4" class="outline-2">
<h2 id="orgb9a8dd4">第三章 文件</h2>
<div class="outline-text-2" id="text-orgb9a8dd4">
<p>
MySQL参数分为动态参数和静态参数。动态参数可以在运行时修改：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #a020f0;">SET</span> [<span style="color: #a020f0;">global</span>|<span style="color: #a020f0;">session</span>] system_var_name=expr
<span style="color: #a020f0;">SET</span> [@@<span style="color: #a020f0;">global</span>.|@@<span style="color: #a020f0;">session</span>.|@@]system_var_name=expr
</pre>
</div>

<p>
变量log<sub>error可以定位错误文件</sub>：
</p>
<div class="org-src-container">
<pre class="src src-sql">SHOW VARIABLES <span style="color: #a020f0;">LIKE</span> <span style="color: #8b2252;">'log_error'</span>
</pre>
</div>

<p>
如果MySQL实例启动失败，首先要检查错误文件。如果开启了log<sub>slow</sub><sub>queries</sub>，MySQL会将耗时超过long<sub>query</sub><sub>time</sub>（单位秒，支持小数）的请求记录到慢日志里。如果开启了log<sub>queries</sub><sub>not</sub><sub>using</sub><sub>indexes</sub>，没有使用索引的语句也会记入慢日志。慢日志记录在slow<sub>query</sub><sub>log</sub><sub>file中</sub>。程序mysqldumpslow可以查看和分析这些慢查询，也可以从mysql.slow<sub>log表中找到这些慢日志</sub>。如果开启了general<sub>log</sub>，所有的查询日志会记录到general<sub>log</sub><sub>file中</sub>。同样的，mysql.general<sub>log也包含这些日志</sub>。MySQL会采用二进制数据记录所有的变更，叫做binlog。记录这些信息是为了恢复和复制（replication）。启动binlog需要设置参数log<sub>bin为ON</sub>。之后日志会写到数据目录下，根据log<sub>bin</sub><sub>basename和log</sub><sub>bin</sub><sub>index命名</sub>。和binlog有关的参数有：
</p>

<ul class="org-ul">
<li>max<sub>binlog</sub><sub>size</sub>。单个binlog文件体积上限。默认1GB。</li>
<li>binlog<sub>cache</sub><sub>size</sub>。未提交日志缓冲区。按会话分配，默认32KB。</li>
<li>sync<sub>binlog</sub>。同步写binlog。</li>
<li>binlog<sub>format</sub>。建议采用row</li>
</ul>

<p>
如果未提交日志过大，InnoDB会使用磁盘保存这些binlog，binlog<sub>cache</sub><sub>disk</sub><sub>use会大于0</sub>，同时binlog<sub>cache</sub><sub>use很高</sub>。这时可以考虑调整binlog<sub>cache</sub><sub>size</sub>。
</p>

<p>
binlog相关的变量有
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">binlog<sub>cache</sub><sub>size</sub></td>
<td class="org-left">32768</td>
</tr>

<tr>
<td class="org-left">binlog<sub>checksum</sub></td>
<td class="org-left">CRC32</td>
</tr>

<tr>
<td class="org-left">binlog<sub>direct</sub><sub>non</sub><sub>transactional</sub><sub>updates</sub></td>
<td class="org-left">OFF</td>
</tr>

<tr>
<td class="org-left">binlog<sub>error</sub><sub>action</sub></td>
<td class="org-left">ABORT<sub>SERVER</sub></td>
</tr>

<tr>
<td class="org-left">binlog<sub>format</sub></td>
<td class="org-left">ROW</td>
</tr>

<tr>
<td class="org-left">binlog<sub>group</sub><sub>commit</sub><sub>sync</sub><sub>delay</sub></td>
<td class="org-left">0</td>
</tr>

<tr>
<td class="org-left">binlog<sub>group</sub><sub>commit</sub><sub>sync</sub><sub>no</sub><sub>delay</sub><sub>count</sub></td>
<td class="org-left">0</td>
</tr>

<tr>
<td class="org-left">binlog<sub>gtid</sub><sub>simple</sub><sub>recovery</sub></td>
<td class="org-left">ON</td>
</tr>

<tr>
<td class="org-left">binlog<sub>max</sub><sub>flush</sub><sub>queue</sub><sub>time</sub></td>
<td class="org-left">0</td>
</tr>

<tr>
<td class="org-left">binlog<sub>order</sub><sub>commits</sub></td>
<td class="org-left">ON</td>
</tr>

<tr>
<td class="org-left">binlog<sub>row</sub><sub>image</sub></td>
<td class="org-left">FULL</td>
</tr>

<tr>
<td class="org-left">binlog<sub>rows</sub><sub>query</sub><sub>log</sub><sub>events</sub></td>
<td class="org-left">ON</td>
</tr>

<tr>
<td class="org-left">binlog<sub>stmt</sub><sub>cache</sub><sub>size</sub></td>
<td class="org-left">32768</td>
</tr>
</tbody>
</table>

<p>
binlog相关的状态有
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Binlog<sub>cache</sub><sub>disk</sub><sub>use</sub></td>
<td class="org-right">22300</td>
</tr>

<tr>
<td class="org-left">Binlog<sub>cache</sub><sub>use</sub></td>
<td class="org-right">11685994</td>
</tr>

<tr>
<td class="org-left">Binlog<sub>stmt</sub><sub>cache</sub><sub>disk</sub><sub>use</sub></td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Binlog<sub>stmt</sub><sub>cache</sub><sub>use</sub></td>
<td class="org-right">145</td>
</tr>
</tbody>
</table>

<p>
每个表都有一个frm文件定义了表结构，视图也有frm文件。InnoDB将数据按表空间存放。初始时会有个10MB大小的ibdata1文件，这是默认的表空间文件（tablespace file）。参数innodb<sub>data</sub><sub>file</sub><sub>path可以指定表空间</sub>：
</p>
<div class="org-src-container">
<pre class="src src-ini">[mysqld]
innodb_data_file_path=/db/ibdata1:2000M;/dr2/db/ibdata2:2000M:autoextend
</pre>
</div>

<p>
如果设置了innodb<sub>file</sub><sub>per</sub><sub>table</sub>，可以为每个表建立独立的表空间文件。通常InnoDB还会有ib<sub>logfile0和ib</sub><sub>logfile1</sub>，用来保存重做日志。
</p>
</div>
</div>

<div id="outline-container-org3c09c76" class="outline-2">
<h2 id="org3c09c76">第四章 表</h2>
<div class="outline-text-2" id="text-org3c09c76">
<p>
在InnoDB中，每个表都具有主键。如果用户没有定义，InnoDB会选择一列唯一非空列作为主键。如果这样的列不存在，InnoDB自动生成一个6字节指针作为主键。InnoDB将数据保存在表空间中。表空间分为若干段（segment），段又分为区（extent），区分为页（page），页分为行（row）。一个区有64页，即1MB。要注意的是，doublewrite buffer不属于某个具体的表。如果开启innodb<sub>file</sub><sub>per</sub><sub>table</sub>，只是将表空间分隔开，像doublewrite buffer这样的数据仍然需要共享。InnoDB中的段分为数据段、索引段、回滚段等。数据段是B+数的叶节点，索引段是B+数的非叶节点。区是64个连续的页。对于大数据段，InnoDB一次最多可以申请4个区。在每个段建立时，会预先分配32个碎片页（fragment page），当这些页都用完了，开始按区分配数据块。页是InnoDB最小的数据管理单位，硬编码为16KB。Oracle和SQL Server的页大小默认是8KB。页分为：
</p>

<ul class="org-ul">
<li>数据页。</li>
<li>Undo页。</li>
<li>系统页。</li>
<li>事务数据页。</li>
<li>插入缓冲区位图页（insert buffer bitmap）。</li>
<li>插入缓冲区空闲列表页（insert buffer free list）。</li>
<li>未压缩的二进制大对象页（uncompressed BLOB page）。</li>
<li>压缩的二进制大对象页（compressed BLOB page）。</li>
</ul>

<p>
页中存储了行。InnoDB是面向行的，一个页内可以存储最多16KB / 2 - 200= 7992行。InnoDB支持多种行记录格式，包括Redundant、Compact、Dynamic、Compressed等。Redundant是为了兼容旧版本而保留的。默认的格式是Compact。Compact行的格式为：
</p>
<blockquote>
<p>
变长字段 NULL标志 记录头 列1数据 列2数据 &#x2026;
</p>
</blockquote>

<p>
Compact页的格式为：
</p>
<p>
对于大数据块（如TEXT、BLOB、或过长的VARCHAR）,InnoDB不会把它全部保存在行中，而是保存前面768个字节和一个指针，指向保存剩余数据的BLOB页。Compressed行记录格式会对行情使用zlib压缩。对于多字节字符，InnoDB在存储时会将其视为VARCHAR。
</p>

<p>
InnoDB数据页由以下7部分组成：
</p>

<ul class="org-ul">
<li>文件头</li>
<li>页头</li>
<li>infimum + Supremum记录</li>
<li>用户记录（行记录）</li>
<li>空闲空间</li>
<li>页目录</li>
<li>文件尾部信息</li>
</ul>

<p>
在InnoDB的数据页中有两个特殊记录Infimum和Supremum，它们用来界定行记录的范围。在查找时，B+树索引本身不能找到具体的记录，而是找到所在的页，数据库把页加载到内存，然后通过Page Directory进行二次查找。
</p>

<p>
约束用来保证数据完整性。数据完整性分为：
</p>

<ul class="org-ul">
<li>实体完整性。记录的主属性不为空，即主键不为NULL。</li>
<li>域完整性。域的值满足特定要求。</li>
<li>参照完整性。</li>
</ul>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #a020f0;">SET</span> sql_mode = <span style="color: #8b2252;">'STRICT_TRANS_TABLES'</span>;
</pre>
</div>

<p>
MySQL不支持CHECK约束，可以使用ENUM和SET来替代：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #a020f0;">CREATE</span> <span style="color: #a020f0;">TABLE</span> <span style="color: #0000ff;">a</span> (
    id <span style="color: #228b22;">INT</span>,
    sex ENUM(<span style="color: #8b2252;">'male'</span>, <span style="color: #8b2252;">'female'</span>)
);
</pre>
</div>

<p>
触发器：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #a020f0;">CREATE</span> [<span style="color: #a020f0;">DEFINER</span> = { <span style="color: #483d8b;">user</span> | <span style="color: #483d8b;">CURRENT_USER</span> }]
<span style="color: #a020f0;">TRIGGER</span> <span style="color: #a020f0;">trigger_name</span> <span style="color: #a020f0;">BEFORE</span>|<span style="color: #a020f0;">AFTER</span> <span style="color: #a020f0;">INSERT</span>|<span style="color: #a020f0;">DELETE</span>|<span style="color: #a020f0;">UPDATE</span>
<span style="color: #a020f0;">ON</span> tbl_name <span style="color: #a020f0;">FOR</span> <span style="color: #a020f0;">EACH</span> <span style="color: #228b22;">ROW</span> trigger_stmt
</pre>
</div>

<p>
外键。被引用的表称为父表，引用父表的叫做子表。在引用时，可以设定ON DELETE或ON UPDATE为：
</p>

<p>
CASCADE。随父表更新/删除。
SET NULL。设置为NULL。
NO ACTION。无操作。
RESTRICT。禁止父表更新/删除。
</p>

<p>
InnoDB在建立外键时会自动为这列增加索引。在导入数据时，为了提高速度，可以关闭外键::
</p>

<p>
SET foreign<sub>key</sub><sub>checks</sub>=0;
LOAD DATA&#x2026;
SET foreign<sub>key</sub><sub>checks</sub>=1;
</p>

<p>
视图::
</p>

<p>
CREATE
[OR REPLACE]
[ALGORITHM={UNDEFINED|MERGE|TEMPTABLE}]
[DEFINER={user|CURRENT<sub>USER</sub>}]
[SQL SECURITY {DEFINER|INVOKER}]
VIEW view<sub>name</sub>[(column<sub>list</sub>)]
AS select<sub>statement</sub>
[WITH [CASCADED|LOCAL] CHECK OPTION]
</p>

<p>
命令show tables会把视图当做表显示。在information<sub>schema.TABLES中</sub>，表的TABLE<sub>TYPE是</sub>'BASE TABLE'，视图是'VIEW'或'SYSTEM VIEW'。information<sub>schema.VIEWS定义了视图的元数据</sub>。
</p>

<p>
MySQL支持的分区是水平分区（不同行的数据记录到不同文件），而非垂直分区（不同列的数记录到不同文件）。分区不是在存储引擎层完成的，但是像CSV等存储引擎不支持分区。查看变量has<sub>partitioning可以确定是否支持分区</sub>。MySQL支持4种类型的分区：
</p>

<p>
RANGE。
LIST。
HASH。
KEY。
</p>

<p>
分区必须是主键或唯一索引的一部分::
</p>

<p>
CREATE TABLE t1 (
  col1 INT NULL,
  col2 DATE NULL,
  col3 INT NULL,
  UNIQUE KEY (col1, col2, col3)
) PARTITION BY HASH(col3)
PARTITIONS 4;
</p>

<p>
RANGE分区::
</p>

<p>
CREATE TABLE t(
    id int
) PARTITION BY RANGE (id) (
    PARTITION p0 VALUES LESS THAN (10),
    PARTITION p1 VALUES LESS THAN (20)
);
</p>

<p>
如果插入的值不在分区中，MySQL会抛出异常。可以增加一个MAXVALUE分区::
</p>

<p>
ALTER TABLE t ADD PARTITION (PARTITION p2 VALUES LESS THAN MAXVALUE);
</p>

<p>
对于分区的表，可以使用explain partitions观察分区使用情况::
</p>

<p>
EXPLAIN PARTITIONS SELECT * FROM sales WHERE data&gt;='2008-01-01' AND date&lt;'2009-01-01'\G;
</p>

<p>
如果按年份进行分区，上面的例子会使用到2008和2009两个分区。如果改成&lt;='2008-12-31'，只会使用2008一个分区。要编写分区友好的SQL。对RANGE分区，优化器只能对YEAR、TO<sub>DAYS</sub>、TO<sub>SECONDS</sub>、UNIX<sub>TIMESTAMP等函数进行优化</sub>。因此下列代码不会起到优化的效果::
</p>

<p>
PARTITION BY RANGE (YEAR(date)*100+MONTH(date)) (
    PARTITION p201001 VALUES LESS THAN (201002))
);
</p>

<p>
要改为::
</p>

<p>
PARTITION BY RANGE (TO<sub>DAYS</sub>(date)) (
    PARITITON p201001 VALUES LESS THAN (TO<sub>DAYS</sub>('2010-02-01'))
);
</p>

<p>
LIST分区是RANGE分区的离散形式::
</p>

<p>
CREATE TABLE t(
    a INT,
    b INT,
) PARTITION BY LIST (b) (
    PARTITION p0 VALUES IN (1,3,5),
    PARTITION p1 VALEUS IN (0,2,4)
);
</p>

<p>
HASH分区的数据分布更均匀::
</p>

<p>
CREATE TABLE t (
  a int,
  b datetime
) PARTITION BY HASH(YEAR(b))
PARTITIONS 4;
</p>

<p>
CREATE TABLE t (
  a int,
  b datetime
) PARTITION BY LINEAR HASH(YEAR(b))
PARTITIONS 4;
</p>

<p>
LINEAR HASH在插入、删除和合并速度上比HASH好，但数据分布没有HASH均匀。
</p>

<p>
KEY分区和HASH分区类型，区别是KEY分区采用MySQL定义的函数进行散列::
</p>

<p>
CREATE TABLE t (
  a int,
  b datetime
) PARTITION BY KEY(YEAR(b))
PARTITIONS 4;
</p>

<p>
CREATE TABLE t (
  a int,
  b datetime
) PARTITION BY LINEAR KEY(YEAR(b))
PARTITIONS 4;
</p>

<p>
前面提到的几个分区方式都要钱分区条件是整数。COLUMNS分区没有这种限制::
</p>

<p>
CREATE TABLE t (
    a int,
    b datetime
) PARITTION BY RANGE COLUMNS (b) (
    PARTITION p0 VALUES LESS THAN ('2009-01-01'),
    PARTITION p1 VALUES LESS THAN ('2010-01-01')
);
</p>

<p>
分区列可以是NULL，这样的列被认为是小于任何非NULL值。表information<sub>schema.PARTITIONS记录了分区信息</sub>。
</p>

<p>
数据根据应用类型可以分为OLTP（在线事务处理）和OLAP（在线分析处理）。对于OLAP，分区可以提升性能，因为OLAP通常会频繁扫描大表。如果是OLTP，除非值通过主键进行查询，分区可能导致性能下降。因为OLTP主要的时间用在定位记录上。如果没有分区，可能只是多一层B+数搜索，如果使用分区，MySQL需要搜索每个分区。
</p>
</div>
</div>

<div id="outline-container-orgeffd590" class="outline-2">
<h2 id="orgeffd590">第五章 索引与算法</h2>
<div class="outline-text-2" id="text-orgeffd590">
<p>
InnoDB支持两种索引：B+树和散列。在InnoDB中，B+索引无法定位记录，而是定位页。B+树索引可以分为聚集索引（clustered index）和辅助聚集索引（secondary index）。使用聚集索引可以在索引的叶节点上直接找到记录。由于数据页只能按照一颗B+树排列，一个表只能有一个聚集索引。辅助聚集索引的叶节点包含的是主键指针。通过非聚集索引查询时，首先要找到主键，再根据主键寻找页。
</p>

<p>
建立索引::
</p>

<p>
ALTER TABLE tbl<sub>name</sub>
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">ADD {INDEX</td>
<td class="org-left">KEY} [index<sub>name</sub>]</td>
</tr>
</tbody>
</table>
<p>
[index<sub>type</sub>] (index<sub>col</sub><sub>name</sub>,&#x2026;) [index<sub>option</sub>]&#x2026;
</p>

<p>
CREATE [UNIQUE] INDEX index<sub>name</sub>
[index<sub>type</sub>] ON tbl<sub>name</sub> (index<sub>col</sub><sub>name</sub>,&#x2026;)
</p>

<p>
如果要修改主键，InnoDB会重建表。如果新建辅助索引，InnoDB会加S锁。
</p>

<p>
索引的Cardinality应该接近于行数。如果Cardinality非常小，要考虑是否需要索引。
</p>
</div>
</div>


<div id="outline-container-org97a6ccb" class="outline-2">
<h2 id="org97a6ccb">第六章 锁</h2>
<div class="outline-text-2" id="text-org97a6ccb">
<p>
InnoDB实现了下列两种标准的行级锁：共享锁（S Lock）和排他锁（X Lock），同时还支持两种表级别的意向锁：意向共享锁（IS Lock）、意向排他锁（IX Lock）。意向锁不会阻塞除全表扫描以外的任何请求。
</p>

<p>
表information<sub>schema.INNODB</sub><sub>TRX记录了事务信息</sub>，包括事务使用的锁。其中trx<sub>weight是事务修改和锁住的行数</sub>。发生死锁时，InnoDB会选择trx<sub>weight最小的事务作为牺牲者</sub>。另外一些和锁有关的表是performance<sub>schema中的data</sub><sub>locks和data</sub><sub>lock</sub><sub>waits</sub>。
</p>

<p>
InnoDB支持4中隔离级别：
</p>

<p>
READ<sub>UNCOMMITTED</sub> 浏览访问browse access
READ<sub>COMMITTED</sub> 游标稳定cursor stability
REPEATABLE<sub>READ</sub> 默认 2.9999度隔离
SERIALIZABLE 隔离，3度隔离
</p>

<p>
变量transaction<sub>isolation定义了目前的隔离级别</sub>。
</p>

<p>
InnoDB要求自增列必须是索引的第一个列。在插入自增列时，InnoDB会产生一个锁。innodb<sub>autoinc</sub><sub>lock</sub><sub>mode可以控制所的行为</sub>。
</p>

<p>
考虑下面的执行情况::
</p>

<p>
// Session A
begin;
delete from parent where id = 3;  // parent表加X锁
</p>

<p>
// Session B
begin;
insert into child select * from parent where id in (2,3); // 请求S锁，被阻塞
</p>

<p>
InnoDB中有3中行锁：
</p>

<p>
Record Lock。单个记录上的锁。
Gap Lock。锁定一个范围，但不包含记录本身。
Next-Key Lock。Gap Lock+RecordLock。
</p>

<p>
考虑下面的执行::
</p>

<p>
// session A
begin;
seelct * from t where a &lt; 6 lock in share mode;  // 加(-inf,6) next-key lock
</p>

<p>
// session B
begin;
insert into t select 5; // 阻塞
</p>

<p>
// session C
begin;
insert into t select 9; // OK
</p>


<p>
更新丢失（lost update）是这样的问题：
</p>

<p>
事务T1查询一行数据，显示给用户User1。
事务T2查询同一行数据，显示给用户User2。
User1修改数据，提交数据库。
User2修改数据，提交数据库。
</p>

<p>
这时User1的提交被User2覆盖了，丢失了。为了避免这种情况，必须对记录增加排他锁。
</p>

<p>
脏读是指读到了未提交的数据。READ UNCOMMITTED会导致脏读。不可重复读是事务在多次读取记录时，得到的结果不同。READ COMMITTED有可能产生不可重复读。在READ REPEATABLE级别InnoDB使用next-key lock避免不可重复读。next-key lock锁住扫描到的索引和这些索引覆盖的范围。
</p>

<p>
innodb<sub>lock</sub><sub>wait</sub><sub>timeout用来控制锁的等地时间</sub>，默认是50秒。innodb<sub>rollback</sub><sub>on</sub><sub>timeout</sub>。
</p>

<p>
读取锁定::
</p>

<p>
SELECT &#x2026; LOCK IN SHARE MODE
SELECT &#x2026; FOR UPDATE
</p>


<p>
死锁实例::
</p>

<p>
session a;
begin;
select * from t where a = 1 for update;
</p>

<p>
// session b;
begin;
seelct * from t where a = 2 for update;
</p>

<p>
// session a;
select * from t where a = 2 for update;
</p>

<p>
// session b;
select * from t where a = 1 for update;
</p>
</div>
</div>

<div id="outline-container-org571384a" class="outline-2">
<h2 id="org571384a">第七章 事务</h2>
<div class="outline-text-2" id="text-org571384a">
<p>
事务是满足以下特性的操作：
</p>

<p>
原子性atomic。事务是不可分割的操作。
一致性consistency。事务对数据库状态的改变是一致的，没有破坏完整性约束（实体完整性、域完整性、参照完整性）。
隔离性。事务对数据库的改变在提交之前不会影响其他事务。
持久性。事务对状态的修改是持久的。
</p>

<p>
InnoDB通过重做（redo）日志来支持事务。开始事务时，InnoDB会记录事务的LSN（Log Sequence Number），事务执行过程中会将操作写入事务日志，事务提交时，InnoDB将事务日志刷写到磁盘上（innodb<sub>flush</sub><sub>log</sub><sub>at</sub><sub>trx</sub><sub>commit</sub>=1）。这种方式叫做预写日志（Write-Ahead Logging，WAL）。
</p>

<p>
如果事务发生回滚，InnoDB会通过undo恢复事务对状态的修改。undo保存在内存的undo段中，在共享表空间内。
</p>

<p>
MySQL中默认开启AUTOCOMMIT，这时每个SQL语句自动提交。
</p>

<p>
::
</p>

<p>
SET AUTOCOMMIT=0;
START TRANSACTION | BEGIN;
COMMIT [WORK];
ROLLBACK [WORK];
SAVEPOINT identifier;
RELEASE SAVEPOINT identifier
ROLLBACK TO [SAVEPOINT] identifier
</p>


<p>
隐式提交:
</p>

<p>
DDL
修改架构，如CREATE/DROP USER/GRANT/RENAME/REVOKE/SET PASSWORD
管理语句。ANALYZE TABLE/CHECK INDEX/CHECK TABLE/LOAD INDEX INTO CACHE/OPTIMIZE TABLE/REPAIR TABLE
</p>

<p>
要注意，truncate无法回滚。
</p>

<p>
查看提交次数::
</p>

<p>
SHOW GLOBAL STATUS LIKE 'Com<sub>commit</sub>';
SHOW GLOBAL STATUS LIKE 'Com<sub>rollback</sub>';
SHOW GLOBAL STATUS LIKE 'Handler<sub>commit</sub>';
SHOW GLOBAL STATUS LIKE 'Handler<sub>rollback</sub>';
</p>

<p>
SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED|&#x2026;}
</p>


<p>
对SERIALIABLE级别，select会自动加上LOCK IN SHARE MODE的共享锁。
</p>

<p>
XA分布式事务。
</p>
</div>
</div>

<div id="outline-container-org374fda0" class="outline-2">
<h2 id="org374fda0">第八章 备份与恢复</h2>
<div class="outline-text-2" id="text-org374fda0">
<p>
备份：
</p>

<p>
热备hot backup
温备warm backup
冷备cold backup
</p>

<p>
逻辑备份、裸文件备份
</p>

<p>
完全备份、增量备份、日志备份
</p>


<p>
冷备份：frm、共享表空间、独立表空间idb、配置cnf、重做日志
逻辑备份：mysqldump/SELECT INTO OUTFILE /load data infile/mysql import
二进制文件:
[mysqld]
log-bin
sync<sub>binlog</sub>=1
innodb<sub>support</sub><sub>xa</sub> = 1
</p>

<p>
flush logs
mysqlbinlog
</p>

<p>
热备：ibbacup
XtraBackup
</p>

<p>
LVM 快照
vgdisplay
lvdisplay
lvcreate
</p>

<p>
复制：
</p>

<p>
主服务器把变更写入binlog。
从服务器将主服务器binlog复制到自己的中继日志（relay log）。
从服务器重做中继日志，更新状态。
</p>

<p>
在从服务器中，复制中继日志和重做中继日志由两个不同的线程完成。
复制可以延迟、可以间歇复制、可以只复制分区，可以设置为read-only避免删除。
</p>
</div>
</div>

<div id="outline-container-org97d9f43" class="outline-2">
<h2 id="org97d9f43">第九章 性能优调</h2>
<div class="outline-text-2" id="text-org97d9f43">
<p>
InnoDB比较适合于OLTP系统。这类系统：
</p>

<p>
并发大。
事务时间短。
查询语句简单。
复制查询少。
</p>


<p>
查看缓冲区命中率：
</p>

<p>
show global status like 'innodb%read%'
</p>

<p>
缓冲区命中率 = innodb<sub>buffer</sub><sub>pool</sub><sub>read</sub><sub>requests</sub> / (
read<sub>requests</sub> + read<sub>ahead</sub> + reads
)
</p>


<p>
对于固态硬盘，可以使用innodb<sub>io</sub><sub>capacity提高IOPS</sub>。
</p>


<p>
RAID 0 1 0 10 01 50
</p>

<p>
基准测试工具：
</p>

<p>
sysbench
mysql-tpcc
</p>
</div>
</div>


<div id="outline-container-org6b736f3" class="outline-2">
<h2 id="org6b736f3">第十章 InnoDB存储引擎源代码的编译和调试</h2>
<div class="outline-text-2" id="text-org6b736f3">
<p>
storage\innobase
</p>

<p>
btr B+树
buf 缓冲区
dict 数据字典
dyn 动态数组
fil 文件结构
fsp 页、区、段
ha 散列算
handler 用于实现MySQL插件式存储引起
ibuf 插入缓冲区
include 头文件
lock 锁
log 日志
mem 复制缓冲区
mtr 事务（底层）
os 操作系统封装
page 页
row 行
srv 参数
sync mutex
thr 线程
trx 事务
ut 工作类
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2019-09-23 周一 18:45</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>

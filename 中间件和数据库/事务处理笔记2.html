<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-09-23 周一 18:45 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>事务处理笔记</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">事务处理笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb2322c1">序</a></li>
<li><a href="#org53a702a">前言</a></li>
<li><a href="#orgcd148f9">概述</a>
<ul>
<li><a href="#orgbd5c482">事务系统</a></li>
</ul>
</li>
<li><a href="#orgf9cf9b8">计算机系统</a>
<ul>
<li><a href="#org1102e5b">硬件模型</a>
<ul>
<li><a href="#org9caaa7e">存储器</a></li>
<li><a href="#orgc6bce1a">处理器</a></li>
<li><a href="#org4fa03c7">通信线路</a></li>
<li><a href="#orge20a642">硬件结构</a></li>
</ul>
</li>
<li><a href="#orgbd084ce">软件模型</a>
<ul>
<li><a href="#orgf01adde">地址空间</a></li>
<li><a href="#org3068039">进程</a></li>
<li><a href="#orgfd584b0">线程</a></li>
<li><a href="#orgcd7fa17">消息和会话</a></li>
</ul>
</li>
<li><a href="#org8f88068">一般系统问题</a>
<ul>
<li><a href="#orge137078">进程交互</a></li>
<li><a href="#org52bf1a9">命名</a></li>
<li><a href="#orgc9fccf8">认证</a></li>
<li><a href="#org27b0928">授权</a></li>
<li><a href="#org5be3f13">调度和性能</a></li>
<li><a href="#orge669ef9">文件</a></li>
<li><a href="#org68e99a4">事务处理标准</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd0af7e0">错误处理</a>
<ul>
<li><a href="#org0109e0a">系统可用性</a></li>
<li><a href="#org6f3b1ff">术语</a></li>
<li><a href="#org33af8d0">实践研究</a></li>
<li><a href="#org460611f">硬件容错</a></li>
<li><a href="#org3d3f38d">软件容错</a></li>
<li><a href="#orgf152924">故障模型</a>
<ul>
<li><a href="#org011a2b7">高可用存储模拟</a></li>
<li><a href="#orgcc3eb70">高可用进程模拟</a></li>
<li><a href="#org2862389">高可用消息模拟</a></li>
</ul>
</li>
<li><a href="#orgc4e2ece">一般原理</a></li>
</ul>
</li>
<li><a href="#orga2d6b6d">事务模型</a>
<ul>
<li><a href="#orgca84c17">原子操作</a></li>
<li><a href="#org3aad035">扁平事务</a></li>
<li><a href="#orgbc3ec57">控制区域</a></li>
<li><a href="#org42f1d0b">使用符号表示事务模型</a></li>
<li><a href="#orgcb7b38c">带保存点的扁平事务</a></li>
<li><a href="#org97f7fe7">链事务</a></li>
<li><a href="#org2c0fbe2">嵌套事务</a></li>
<li><a href="#org8e48006">分布事务</a></li>
<li><a href="#org6a43903">多级别事务</a></li>
<li><a href="#org28b9221">长事务</a></li>
</ul>
</li>
<li><a href="#org8218a93">事务处理监控器：概述</a>
<ul>
<li><a href="#orgeb0f664">事务处理服务</a></li>
</ul>
</li>
<li><a href="#org2f343ea">事务处理监控器</a></li>
<li><a href="#org491d083">隔离性的概念</a></li>
<li><a href="#orge2031e2">锁的实现</a>
<ul>
<li><a href="#orgff128f2">锁管理程序</a></li>
</ul>
</li>
<li><a href="#org60afcc5">日志管理程序</a></li>
<li><a href="#org64230ce">事务管理器概念</a>
<ul>
<li><a href="#org493f9f5">DO-UNDO-REDO协议</a></li>
</ul>
</li>
<li><a href="#org0dd3e8d">事务管理器结构</a></li>
<li><a href="#org91029ef">高级事务管理器主题</a></li>
<li><a href="#org44a6f69">文件和缓冲区管理</a></li>
<li><a href="#orgff82906">面向元组的文件系统</a></li>
<li><a href="#org2ad9a48">存取路径</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgb2322c1" class="outline-2">
<h2 id="orgb2322c1">序</h2>
<div class="outline-text-2" id="text-orgb2322c1">
<p>
事务处理技术是有效管理和使用计算机信息资源的关键。事务处理涵盖了对所存储的信息和应用程序加以管理的技术。应用程序负责对信息的解释和操作。
</p>

<p>
计算机中的数据描述了现实世界中的某些现象或活动的状态和演化。为了能够正确反映现实世界，一些数据必须一起被访问或修改，这就是数据一致性。保证事务一致性的关键是要明确数据访问和更新序列，这个序列就叫做事务。事务处理技术就是要确保一个事务要么完整地执行，要么根本不执行，并保证并发执行的事务彼此互不干扰。
</p>
</div>
</div>

<div id="outline-container-org53a702a" class="outline-2">
<h2 id="org53a702a">前言</h2>
</div>

<div id="outline-container-orgcd148f9" class="outline-2">
<h2 id="orgcd148f9">概述</h2>
<div class="outline-text-2" id="text-orgcd148f9">
</div>
<div id="outline-container-orgbd5c482" class="outline-3">
<h3 id="orgbd5c482">事务系统</h3>
<div class="outline-text-3" id="text-orgbd5c482">
<p>
在TP系统中有一个核心服务集叫做TP监控器。TP监控器负责协调通过系统的事务流。
</p>

<p>
事务是改变应用状态的操作的集合。这种状态的改变可能是物理上的，或抽象（数据）上的。要求发起操作的消息叫做事务请求，通知操作结果的消息叫做事务应答。执行这个操作的程序叫做事务程序。在建造事务系统的过程中发展出了很多分布式计算和容错计算的概念。针对可靠性、可用性和性能，引入了分布式数据。针对可用性，引入了容错存储和容错处理。针对分布式计算，引入了客户/服务器模型和远程过程调用。而最为重要的是引入了ACID特性，即：
</p>
<ul class="org-ul">
<li>原子性（atomicity）。事务对状态的改变是不可分割的，事务中的操作，要么全都成功，要么全都不执行，all or nothing。</li>
<li>一致性（consistency）。事务对状态的改变时正确的，没有违反状态的完整性约束。</li>
<li>隔离性（isolation）。不同事务之间互不干扰。</li>
<li>持久性（durability）。如果事务执行成功，事务的状态的改变时永久的，不会受到后续失败的影响。</li>
</ul>

<p>
以银行贷款事务为例，如果它同时完成了支出和账户余额更改，它就是原子的。如果它支出的钱等于账户余额减少的钱，它就是一致的。如果这个事务不会被同时执行的其他事务（其他人正在向账户转账）干扰，它就是隔离的。如果事务完成后，即使系统发生故障，在系统恢复后，账户余额仍然能够正确反映取款后的情况，它就是永久的。事务为一个计算规定了简单失败的语义。应用程序通过begin_work声明一个新事务的开始，后续程序执行的操作将成为事务的组成部分。如果程序调用了其他程序来执行操作，这些操作也是事务的一部分。程序通过commit_work声明事务是完整和正确的状态改变。一旦事务成功提交，状态的改变就是永久的。如果在事务执行过程中出错，应用程序调用rollback_work，撤销事务中已经执行的操作。如果发生了应用程序无法处理的错误，系统自行可以回滚事务。在事务系统中，begin_work/commit_work所包围的操作构成了一个原子操作，all or nothing。事务是构造分布式应用的简单的、模块化的方法。每个模块是一个事务，或者一个子事务。如果执行顺利，事务提交，所有模块更新到一个新的永久状态。如果发生错误，事务中的所有模块回滚到开始状态。因为提交和回滚的逻辑是自动执行的，很容易构造出具有简单故障语义的模块。实现事务的一种方法是两阶段提交协议（two-phase commit protocol）。首先进行投票（voting），如果所有的事务参与者都同意提交，开始执行提交阶段，所有的事务参与者执行提交。在这两个阶段中，需要有一个进程负责对投票和提交进行协调。
</p>


<p>
和事务管理系统相关的人有用户、应用开发者、管理员和事务处理系统开发者。在他们眼中，事务处理系统是不同的。以邮件系统为例，用户看到的是信箱和消息。用户向系统提供身份标识，输入密码以认证自己的身份。认证事务完成后，系统把收到的消息列表显示给用户，用户可以阅读一条消息、回复一条消息，或者删除消息。每个操作都是一个事务。用户也可以撤销自己发出的消息。这个事务试图撤销一个已提交事务的影响，它叫做补偿事务。邮件系统的管理员需要增加和删除用户，为用户提供文档和培训，管理系统的安全性。在他们眼里，邮件系统是一组硬件模块和软件模块构成的物理节点。管理员必须管理这些模块。模块的信息可以保存在一个数据库中，这个数据库叫做中心库（repository）或系统字典。中心库是的模块的维护工作得以简化。现在我们从应用开发者的角度观察邮件系统。客户程序作为一个进程在用户的工作站上执行，给用户提供一个图形界面。这个部分叫做表示服务。客户程序把用户的操作封装成消息发送给远程主机上运行的服务器。消息会传递给TP监控器。TP监控器有一个注册服务列表，每个服务提供一个特定的功能，如登录、阅读消息等等。TP监控器收到消息后，查找消息所请求的服务，检查客户权限，然后建立一个进程执行这个服务，把请求传递给服务器进程，服务器进程执行自己的功能。事务处理系统为应用开发者提供了一个分布式计算环境，当应用执行的时候，客户通过事务性远程调用机制调用服务。过程调用机制是指一个程序调用另一个程序。如果这两个过程不在同一个地址空间内，叫做远程过程调用（RPC）。由于不需要在同一个地址空间，客户和服务器可以位于不同的计算机上。这么做通常是处于性能和权限方面的考虑。事务性远程调用（TRPC）把客户和服务器的工作结合到一个ACID事务中。应用通过begin_work声明事务边界，开始一个新并分配唯一的事务标识符（trid）。客户的所有操作都带有这个事务标识符。当事务提交时，所有参与的服务器也执行事务提交操作。提交过程被每台计算机上的TP监控器实现。它们遵循二阶段提交，由一个可信进程协调。
</p>


<p>
在事务型系统中，服务器也被叫做资源管理器（resource manager），它由数据、代码和对一些共享数据提供存取的进程组成。队列管理器、窗口系统、数据库系统都是典型的资源管理器。资源管理器的互操作性的关键在于要有一种调用应用服务和资源管理器的标准方法，这种方法即允许调用本地服务，也可以调用远程服务。为了回滚尚未提交的事务，事务处理系统使用日志管理器记录事务中的操作。为了提供隔离性，事务管理系统使用封锁管理器封锁事务存取的对象。当事务发出commit_work命令时，事务管理器执行两阶段提交协议。首先查询所有参与事务的资源管理器，是否认为事务中的操作构成了一个正确和完整的状态变化。如果一个资源管理器予以否决，提交失败。只有全部资源管理器都确认，事务管理器在日志中记录事务，通知资源管理器，然后资源管理器释放锁。如果事务在执行过程中发生错误，或者某个资源管理器否决的提交，事务管理器指挥资源管理器回滚事务。事务管理器读取事务日志，对每个操作涉及的资源管理器，通知资源管理器撤销操作。当每个资源管理器都撤销操作后，事务管理器通知各资源管理器事务终止。如果发生场地（ground？）故障，事务监控器重启所有的资源管理器。资源管理器向事务管理器询问尚未确认状态的事务执行的结果，并根据结果重做或撤销操作。如果一个资源管理器出现错误，而事务系统的其他部分仍然正常运行，事务管理器终止该资源管理器涉及的未提交事务。等待该资源管理器恢复正常，事务管理器通知其事务结果。如果一个特定的对象发生错误，但资源管理器还可以工作，那么资源管理器会继续为其他对象提供服务，而失败的对象可以从档案的副本或日志重构。每个场地都有一个单独的事务管理器，使得场地可以独立于其他场地操作，提供本地自治。多个事务管理器也可以支持事务以分布式执行。事务处理系统最明显的特征是围绕中心库构造的应用设计和生成工具。在应用生成器和中心库下面是用来存储永久数据的数据库系统，和一个用来为终端设备提供抽象接口的数据通信系统。中心库保存着系统中对象的描述信息和对象之间的依赖关系。中心库也叫做字典或目录。数据库必须把应用和数据存放地点以及数据精确的表示隔离开。分片数据是将数据保存在不同的场地，将一份数据的副本保存在多个场地叫做复制。
</p>


<p>
SQL包括了数据定义、数据操纵和数据控制。SQL是记录的集合，每个记录是一个值的序列。因为每个操作产生一个集合作为输出，可以将其定义为一个虚表，叫做视图。视图可以提供数据独立性，将表的具体实现和应用程序隔离。SELECT是SQL操作的核心，它由3个通用操作符组成：PROJECT抛弃一些列，SELECT抛弃一些行，JOIN将两个集合连接起来。这些操作是哥德尔完备的，但不是图灵完备的。因此，SQL常和其他编程语言一起使用。这时编程语言被称为主语言。主语言操纵单个记录，SQL操纵记录集合，这使得主语言和SQL之间发生阻抗失配（impedance mismatch）。如果要使用主语言处理记录集合，必须通过SELECT语句定义一个集合，并定义一个游标，通过游标，逐一操作记录。
</p>
</div>
</div>
</div>

<div id="outline-container-orgf9cf9b8" class="outline-2">
<h2 id="orgf9cf9b8">计算机系统</h2>
<div class="outline-text-2" id="text-orgf9cf9b8">
</div>
<div id="outline-container-org1102e5b" class="outline-3">
<h3 id="org1102e5b">硬件模型</h3>
<div class="outline-text-3" id="text-org1102e5b">
<p>
根据Bell和Newell的分类方法，硬件分为处理器、存储器和通信系统。处理器执行指令，读取或写入存储器，通信线路传输数据。
</p>
</div>

<div id="outline-container-org9caaa7e" class="outline-4">
<h4 id="org9caaa7e">存储器</h4>
<div class="outline-text-4" id="text-org9caaa7e">
<p>
存储器按地址存储数据，处理器可以读、写这些数据。存储器的模型为：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Storage</span> {
<span style="color: #a020f0;">public</span>:
  <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #0000ff;">get_size</span>();
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">move_to</span>(<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">position</span>);
  <span style="color: #228b22;">int</span> <span style="color: #0000ff;">read</span>(<span style="color: #228b22;">void</span> *<span style="color: #a0522d;">destination</span>, <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">length</span>);
  <span style="color: #228b22;">int</span> <span style="color: #0000ff;">write</span>(<span style="color: #228b22;">void</span> *<span style="color: #a0522d;">source</span>, <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">length</span>);
};
</pre>
</div>

<p>
大部分存储器中有一个叫做读写头的模块。在读写数据时，存储器首先将读写头移动到数据所在的位置，然后开始传输数据。因此存储器的访问时间（access time）等于移动读写头的时间（也叫寻址时间）加上传输数据的时间（transfer time），后者由传输量（transfer size）和传输速率（transfer rate）决定：
</p>
<blockquote>
<p>
访问时间 = 寻址时间 + 传输量/传输速率
</p>
</blockquote>
<p>
寻址时间有时也叫做延迟（latency）。由于传输速率是固定的，在读写相同大小的数据时，如果这些数据顺序的排序在一起，就可以节省大量的寻址时间。因此在使用存储器时，需要考虑以下两点：
</p>
<ul class="org-ul">
<li>使用大块数据。降低访问时间中寻址时间的比例。</li>
<li>数据聚集。提高大块数据中有效数据的比例。</li>
</ul>
<p>
在很多系统或软件中都体现了这两点设计思路。比如为了提高访问效率，同时简化数据管理操作，通常会将存储器划分为一组固定大小的块（逻辑上page、block或物理上的sector）。处理器在访问存储器时，以块为单位进行读写。
</p>


<p>
衡量存储器性能的指标有两个：访问时间和存储容量。根据这两个指标，可以得到两个衡量存储器性价比的数据：
</p>

<ul class="org-ul">
<li>单位字节成本（cost/byte），即存储单位字节需要的费用。</li>
<li>单位访问时间成本（cost/access），即费用与访问时间之比。</li>
</ul>

<p>
通常速度快的存储器，容量小、价格高，而容量大的存储器速度又慢。要选择合适的存储器，必须对访问时间、存储容量和成本这三个因素进行权衡。目前最常见的做法是，采用多种类型的存储器，使用高速存储器作为低速存储器的缓存，构成一个多层次的存储子系统。PC和x86服务器都采用这样的方式，都有高速缓存、内存和磁盘三层存储结构。
</p>


<p>
对于存在多层次存储器的系统，其整体的存访问速度如何呢？我们考虑下面这种情况：系统有一个高速存储器a和一个低速存储器b。a作为b的缓存。为了衡量整体的访问时间，我们引入命中率（hit ratio）这个概念：
</p>
<blockquote>
<p>
命中率 = 从高速存储器中找到数据的访问请求数量 / 全部访问请求数量
</p>
</blockquote>
<p>
或者
</p>
<blockquote>
<p>
命中率 = 从高速存储器中找到数据的访问请求数量 / (在高速存储器中找到数据的访问请求数量 + 在低速存储器中找到数据的访问请求数量)
</p>
</blockquote>

<p>
假设存储器a的访问时间是C，存储器b的访问时间是S，命中率是H。假设C=0.01*S，那么系统整体的访问时间是 C*H + (1-H)*S，约等于 (1-H)*S。如果命中率是50%，整体访问时间是高速存储器的50倍，低速存储器的一半。如果命中率是10%，整体访问时间是高速存储器的10倍，是低速存储器的1/10。可以看到，提高命中率对降低整体访问时间有很大帮助。要做到这一点有两个方法：
</p>
<ul class="org-ul">
<li>聚集。将相关的数据聚集到一个块中，并聚集数据引用方式和指令引用方式，提高局部性。</li>
<li>巨大的缓存。允许将更多的数据保存在高速存储器中。</li>
</ul>

<p>
这里提到了一个词：“局部性”。一个完美的存储子系统应该可以预测处理器将会使用到的数据，并提前保存到缓存中。对于通用服务器，由于不了解应用逻辑，存储系统只能采用局部性原理（principle of locality）猜测处理器需要哪些数据。局部性原理是指：
</p>
<ul class="org-ul">
<li>空间局部性（spatial locality），即后续使用的数据往往位于当前使用数据的附近。</li>
<li>时间局部性（temporal locality），即当前使用的数据往往会在近期内再次使用。</li>
</ul>
<p>
根据局部性原理，存储子系统通常会缓存当前数据临近位置的数据（参考cacheline），以及近期使用过的数据（参考LRU）。
</p>


<p>
此外，还可以从经济角度考虑，将那些数据保存到高速缓存中更合适。在1987年，工程师提出了一个指导原则：五分钟法则(five-minute rule)。
</p>
<blockquote>
<p>
如果一个数据不到5分钟就会被访问一次，那么应当将这个数据保存到内存中，否则应当将它保存到磁盘中。
</p>
</blockquote>

<p>
假设对系统的响应时间没有特殊要求，仅仅从成本角度进行分析。在1990年，10KB的内存价格是1美元，10KB的磁盘价格是0.1美元，因此将10KB的数据保存在磁盘中可以节省0.9美元。但是如果将数据存储在磁盘上，在处理数据前必须先加载到内存，这个过程也会产生成本。一个磁盘每秒可以处理30次请求，购买一个磁盘和关联的硬件需要3000美元（1990年），因此磁盘的单位访问时间成本是100美元。假设一个10KB的数据平均每秒访问一次，如果保存到磁盘上，总的成本就是100.1美元。如果保存在内存中，成本是1美元。二者的平衡点在100秒左右。如果数据访问频率高于1次/100秒，那就应当保存在内存中。这个频率可以根据下列公式计算：
</p>
<blockquote>
<p>
频率 = (高速存储区每字节成本 - 低速存储器每字节成本) * 对象的字节数 / 每秒访问对象的费用
</p>
</blockquote>

<p>
在首次提出这种计算方法时，根据当时内存和磁盘的价格，计算出的频率是5分钟，因此就叫做5分钟法则。
</p>
</div>
</div>


<div id="outline-container-orgc6bce1a" class="outline-4">
<h4 id="orgc6bce1a">处理器</h4>
<div class="outline-text-4" id="text-orgc6bce1a">
<p>
处理器可以访问存储器中的数据，通过通信线路收发数据。处理器的速度通常用ips衡量，即每秒执行的指令数。处理器的模型为：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Processor</span> {
<span style="color: #a020f0;">public</span>:
    <span style="color: #228b22;">void</span> <span style="color: #0000ff;">load_instrument</span>();
    <span style="color: #228b22;">void</span> <span style="color: #0000ff;">execute</span>();
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org4fa03c7" class="outline-4">
<h4 id="org4fa03c7">通信线路</h4>
<div class="outline-text-4" id="text-org4fa03c7">
<p>
通信线路的模型很简单，信号在一端输入，最终会到达另一端。通信线路的一段是处理器，另外一段是存储器或者另一个处理器。处理器、存储器和通信线路一起构成网络。
</p>

<p>
通过线路传输数据所花费的时间由两个因素决定：
</p>
<ul class="org-ul">
<li>线路的带宽，即每秒线路可以传输多少数据。</li>
<li>线路的长度，决定了第一个字节需要多久可到达，即延迟（latency）。</li>
</ul>

<p>
通信线路的模型为：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Communication_line</span> {
<span style="color: #a020f0;">public</span>:
    <span style="color: #0000ff;">Communication_line</span>(<span style="color: #228b22;">End</span> <span style="color: #a0522d;">end1</span>, <span style="color: #228b22;">End</span> <span style="color: #a0522d;">end2</span>);
    <span style="color: #228b22;">void</span> <span style="color: #0000ff;">send_to_end1</span>(<span style="color: #228b22;">Signal</span> <span style="color: #a0522d;">signal</span>);
    <span style="color: #228b22;">void</span> <span style="color: #0000ff;">send_to_end2</span>(<span style="color: #228b22;">Signal</span> <span style="color: #a0522d;">signal</span>);
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orge20a642" class="outline-4">
<h4 id="orge20a642">硬件结构</h4>
<div class="outline-text-4" id="text-orge20a642">
</div>
<ul class="org-ul">
<li><a id="org29495e0"></a>处理器-存储器结构<br />
<div class="outline-text-5" id="text-org29495e0">
<p>
在系统中要如何组织处理器和存储器呢？通常可以采用下列3中结构：
</p>

<ul class="org-ul">
<li>非共享（shared nothing）。存储器只服务于一个固定的处理器。所有的数据请求必须经过这个处理器。</li>
<li>全局共享（shared global）。每个处理器有自己私有的存储器，同时系统中有一个所有处理器共享的存储器池。L1缓存和内存就是这种结构，基于HDFS的分布式应用也是这种结构。</li>
<li>共享存储器（shared memory）。处理器可以访问每个存储器。如果多个处理器同时访问某个数据，底层硬件负责管理数据的共享访问，为每个处理器提供数据的当前视图。事务系统就是这种结构。</li>
</ul>
</div>
</li>


<li><a id="org3cf0481"></a>处理器-处理器结构<br />
<div class="outline-text-5" id="text-org3cf0481">
<p>
非共享和全局共享处理器可以组合成集群（cluster），集群有两个重要的属性：
</p>
<ul class="org-ul">
<li>通信带宽高。</li>
<li>通信延迟低。</li>
</ul>
<p>
在集群中构建计算时，需要考虑这样一个问题：应该将程序移动到数据（将计算编写成存储过程，保存在中心库），还是将数据移动到程序（将数据传输到应用服务器，在程序中计算）？这取决于数据量大小和计算的复杂程度。
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgbd084ce" class="outline-3">
<h3 id="orgbd084ce">软件模型</h3>
<div class="outline-text-3" id="text-orgbd084ce">
</div>
<div id="outline-container-orgf01adde" class="outline-4">
<h4 id="orgf01adde">地址空间</h4>
<div class="outline-text-4" id="text-orgf01adde">
<p>
地址空间是对存储器的模拟。类似的，进程是对处理器的模拟。处理器从地址空间中加载指令和数据，执行相关操作。地址空间是操作系统管理的虚拟内存的一部分，不是物理内存。出于于安全、和性能（局部性、共享）的考虑，地址空间划分为若干个段（segment）。段是共享、保护和分配的单元。段可以是进程私有的，也是进程间共享的，可以是可修改的，也可以是只读的。操作系统在管理虚拟内存时，通常会将段细分为一组固定大小的虚拟内存页（virtual memory page，简称页page）。这种分段和分页机制，对应用程序是透明的。
</p>
</div>
</div>


<div id="outline-container-org3068039" class="outline-4">
<h4 id="org3068039">进程</h4>
<div class="outline-text-4" id="text-org3068039">
<p>
进程是对处理器的模拟，进程执行程序，收发消息，读写存储空间。引入进程的目的是提供并行执行程序的能力，当某些程序等待时，可以执行另外一些程序。既提高了计算机的使用效率，又避免某个程序的错误导致计算机不可用。进程在运行时可以看做是某个用户的代理人，因此具有该用户的权限和优先级。系统据此批准和分配资源给进程。
</p>


<p>
进程在执行时会想各个子系统发出请求，为了避免进程错误影响到子系统，子系统不会直接暴露自己的数据给进程，而是提供一个封装的环境给进程，这个环境叫做保护域。保护域的构造有两种方法，一是使用进程作为保护域，每个子系统作为独立的进程运行，拥有私有的地址空间，应用程序通过进程切换执行子系统请求。第二个方法是使用地址空间作为保护域，一个进程拥有多个地址空间，其中一个分配给应用程序，其他的分配给各个子系统。应用程序通过地址空间切换执行子系统请求。地址空间的切换比进程切换快得多，因此这种方法具有性能优势。
</p>
</div>
</div>

<div id="outline-container-orgfd584b0" class="outline-4">
<h4 id="orgfd584b0">线程</h4>
<div class="outline-text-4" id="text-orgfd584b0">
<p>
除了一个进程对应多个地址空间的需求外，还有一个地址空间对应多个进程的需求，比如一个进程作为生产者从外部资源读取数据，另一个进程处理数据。这个需求导致了一个新的概念：线程（thread）。线程有时也被叫做任务（task），它的创建和分配成本不高。
</p>
</div>
</div>

<div id="outline-container-orgcd7fa17" class="outline-4">
<h4 id="orgcd7fa17">消息和会话</h4>
<div class="outline-text-4" id="text-orgcd7fa17">
<p>
会话（session）是对通信线路的模拟，消息（message）则是线路中的信号。大部分情况下，进程间通信是双向的，因此，会话的模型为：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Session</span> {
<span style="color: #a020f0;">public</span>:
    <span style="color: #228b22;">void</span> <span style="color: #0000ff;">open</span>();
    <span style="color: #228b22;">void</span> <span style="color: #0000ff;">send</span>(<span style="color: #228b22;">Message</span> <span style="color: #a0522d;">message</span>);
    <span style="color: #228b22;">Message</span> <span style="color: #0000ff;">receive</span>();
    <span style="color: #228b22;">void</span> <span style="color: #0000ff;">close</span>();
};
</pre>
</div>

<p>
会话的建立过程如下：服务器首先监听open_session数据报。客户发送open_session数据报给服务器，服务器检查这个数据报是否合法，并通知客户是否开放会话。当客户收到会话开放的消息后，会话建立。
</p>


<p>
使用会话的目的在于：
</p>
<ul class="org-ul">
<li>共享状态。会话在服务器和客户之间共享了状态，服务器可以根据会话找到客户的状态。</li>
<li>授权加密。客户和服务器需要相互认证，这个过程需要多个消息。</li>
<li>错误发现和更正。会话中的消息是带有序号的，根据序号可以发现消息丢失和消息重复的情况。</li>
<li>性能和资源调度。会话建立后，服务器地址、客户认证信息可以缓存起来，节省这些操作。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org8f88068" class="outline-3">
<h3 id="org8f88068">一般系统问题</h3>
<div class="outline-text-3" id="text-org8f88068">
</div>
<div id="outline-container-orge137078" class="outline-4">
<h4 id="orge137078">进程交互</h4>
<div class="outline-text-4" id="text-orge137078">
<p>
如果系统中需要多个进程相互协作，如何设计各进程之间的关系呢？对于两个进程的情况，有两种组织进程结构：
</p>
<ul class="org-ul">
<li>对等结构。两个进程是独立的、对等的，分别执行自己的计算，并不时交换数据。</li>
<li>客户-服务器结构。两个进程通过请求-应答完成交互。客户向服务器发出请求，服务器执行操作并做出应答。</li>
</ul>

<p>
对等结构是基础的结构，但客户-服务器结构更容易使用。客户-服务器结构可以封装了远程过程调用（RPC），使用起来和本地调用一样。但是对于一个请求产生多个应答、多个请求产生一个应答，以及并行的情况，远程过程调用无法支持。实际上，可以在对等结构中构建消息和会话的底层机制，然后将大部分接口建立在客户-服务器结构上，将二者结合起来。
</p>


<p>
关于客户-服务器的另一个问题是：如何找到服务器？这里有两种模型：推送（push）和拉取（pull）。推送是事务处理系统的典型处理方式，事务监控器负责为客户分配服务器。拉取方式需要一个公共的名字服务器，典型例子如DNS。
</p>
</div>
</div>

<div id="outline-container-org52bf1a9" class="outline-4">
<h4 id="org52bf1a9">命名</h4>
<div class="outline-text-4" id="text-org52bf1a9">
<p>
每个对象（进程、文件或设备）都具有名字、地址和位置。名字是一个抽象的标识，地址是用于访问对象的抽象路径，位置是对象在的物理上的位置。一个对象可以具有多个名字，叫做别名。名字按照名字空间的层次划分，按照国际名字空间标准X.500，每个次级节点是一个目录，通过点（符号”.“）来分隔目录。
</p>


<p>
在发送请求时，客户使用名字服务器将名字解析为地址，按照地址访问网络。网络将请求传递到服务器的位置，将请求交给服务器。客户得到名字服务器的方式有两种，一是事先约定本地名字服务器地址，二是让本地名字服务器定期发送广播。
</p>
</div>
</div>


<div id="outline-container-orgc9fccf8" class="outline-4">
<h4 id="orgc9fccf8">认证</h4>
<div class="outline-text-4" id="text-orgc9fccf8">
<p>
当客户第一次连接服务器时，双方都想证实对方的身份，这个过程叫做认证，即确认对方的授权标识（authid）。常用的方法有：
</p>
<ul class="org-ul">
<li>口令。客户和服务器预先设定一个固定的字符串，客户将字符串发送给服务器以表明身份。</li>
<li>质询-应答。客户和服务器共享一个秘钥，服务器选择一个随机数N，用秘钥对N进行加密，将结果EN发送给客户。客户使用秘钥解密，将结果发送给服务器。如果服务器收到了N，就可以认证客户。</li>
<li>每个授权标识拥有一对秘钥，公钥EK和密钥DK，满足DK(EK(X)) = X，同时只知道EK和EK(X)难以推算出DK。每个授权标识公布自己的EK。在认证时，服务器选择一个随机数X，用客户的公钥EK加密，将结果发送给客户。根据客户能否解密出X，决定认证结果。</li>
</ul>

<p>
这三种方法都涉及到钥匙的分发（key distribution）。能够产生钥匙并安全分发的机构叫做认证服务器（authentication server），它是更高的授权机构。一种简单的构建认证服务器方法如下：将网络划分为认证域，每个认证标识符由认证域和域内标识符两部分组成。认证服务器之间拥有可靠的通信网络。在认证客户时，服务器通过本地认证服务器，从客户的认证服务器得到客户公钥。
</p>
</div>
</div>

<div id="outline-container-org27b0928" class="outline-4">
<h4 id="org27b0928">授权</h4>
<div class="outline-text-4" id="text-org27b0928">
<p>
在确认了客户身份后，还有判断客户是否具有权限执行他请求的操作。这个步骤叫做授权。授权可以用下面的谓词来表示：
</p>
<blockquote>
<p>
boolean result = Authorize(object, authid, operation)
</p>
</blockquote>

<p>
谓词Authorize可以看成是一个三维数组或SQL数据表，叫做存取控制矩阵。存取控制矩阵通常是稀疏的，因此有时也会为每个对象维护一个&lt;authid,操作&gt;列表，叫做存取控制列表。完成授权后，客户就具备了操作对象的能力。服务器会建立一个控制块来封装这种能力，客户通过一个标记来引用这个控制块。这样做可以避免重复认证和授权。有些服务器不保存客户状态，这时可以把控制块加密后发送给客户，客户在需要时，把控制块发送给服务器，服务器进行解密并判断控制块是否有效。
</p>


<p>
当客户要求服务器执行某个操作时，服务器可能需要请求其他的服务器，这时，如果运行服务器使用客户的授权来访问其他服务器，这个机制叫做授权扩大。
</p>
</div>
</div>


<div id="outline-container-org5be3f13" class="outline-4">
<h4 id="org5be3f13">调度和性能</h4>
<div class="outline-text-4" id="text-org5be3f13">
<p>
从客户的角度来看，服务器的性能是通过从发送请求到收到应答的时间来衡量的，这个事件叫做响应时间。响应时间分为两部分：等待时间，即等待服务器的时间和服务器等待资源的时间，以及服务时间，即服务器处理请求的时间。
如果请求服从m/m/l排队模型，服务器的平均响应时间可以表示为下面的公式：
</p>
<blockquote>
<p>
平均响应时间=服务时间 / (1-p)，p是系统的利用率
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orge669ef9" class="outline-4">
<h4 id="orge669ef9">文件</h4>
<div class="outline-text-4" id="text-orge669ef9">
<p>
文件是一种保存数据的方式，这种方式独立于具体的存储设备。文件的模型如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">enum</span> <span style="color: #a020f0;">class</span> <span style="color: #228b22;">File_operation_staus</span> {
    <span style="color: #a0522d;">ok</span>, <span style="color: #a0522d;">failed</span>
};

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">Filename_type</span> = <span style="color: #008b8b;">std</span>::wstring;

<span style="color: #228b22;">File_operation_status</span> <span style="color: #0000ff;">create_file</span>(<span style="color: #228b22;">Filename_type</span> <span style="color: #a0522d;">filename</span>);
<span style="color: #228b22;">File_operation_status</span> <span style="color: #0000ff;">delete_file</span>(<span style="color: #228b22;">Filename_type</span> <span style="color: #a0522d;">filename</span>);
</pre>
</div>

<p>
打开文件之后，有两种操作文件的方法。第一种将文件映射到地址空间，以操作内存的方式读写文件：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">File_operation_status</span> <span style="color: #0000ff;">map_file</span>(filename, address_space, slot);
<span style="color: #228b22;">File_operation_status</span> <span style="color: #0000ff;">unmap_file</span>(address_space, slot);
</pre>
</div>

<p>
第二种方法是显式的在文件和内存之间复制数据：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">File</span> = <span style="color: #a020f0;">struct</span> {};
<span style="color: #228b22;">File_operation_status</span> <span style="color: #0000ff;">open_file</span>(<span style="color: #228b22;">Filename_type</span> <span style="color: #a0522d;">filename</span>, <span style="color: #228b22;">File</span>* <span style="color: #a0522d;">file</span>);
<span style="color: #228b22;">File_operation_status</span> <span style="color: #0000ff;">close_file</span>(<span style="color: #228b22;">File</span>* <span style="color: #a0522d;">file</span>);
<span style="color: #228b22;">File_operation_status</span> <span style="color: #0000ff;">read</span>(<span style="color: #228b22;">File</span>* <span style="color: #a0522d;">file</span>, file_address, memory_address, length);
<span style="color: #228b22;">File_operation_status</span> <span style="color: #0000ff;">write</span>(<span style="color: #228b22;">File</span>* <span style="color: #a0522d;">file</span>, file_address, memory_address, length);
</pre>
</div>

<p>
文件系统的主要用途是存储文件内存并提供读写操作。文件系统为每个文件建立一个描述符，记录文件的名字、创建者的authid、存取控制列表、修改时间等信息。根据文件内容的组织方式，文件可以分为结构化的和非结构化的。结构化文件可以看成一组具有相同结构的记录的集合。结构化文件又可以再分为直接存取文件和关联存取文件，区别在于关联存取文件可以通过记录码来检索记录。对于直接存取文件，如果记录按照生成的顺序排列，这个文件叫做顺序文件。如果记录按照某种逻辑顺序排列，叫做相关文件。对于关联存取文件，根据记录存放策略，可以分为散列（hashed）文件和码顺序（key-sequence）文件。记录码由记录的若干个子域组成，用来检索和访问记录。在散列文件中，和散列表类似，文件被划分为一组桶。通过散列算法得到桶的序号，然后在桶中查找记录。码顺序文件则是按照记录码的顺序排列记录。
</p>


<p>
当需要从不同的维度来检索记录时，往往需要多个记录码。通常多出来的记录码会保存在另外的文件中，这个文件叫做辅助索引文件。辅助索引指向主索引，按照辅助索引查找时，首先找到对应的主索引，然后再查找记录。
</p>


<p>
在分布式系统中，文件可能出现分割（文件的各部分保存在不同的节点）或复制（多个节点都保存了文件或文件的同一部分）的情况。分割通常是按照记录码的区间进行的。
</p>
</div>
</div>

<div id="outline-container-org68e99a4" class="outline-4">
<h4 id="org68e99a4">事务处理标准</h4>
<div class="outline-text-4" id="text-org68e99a4">
<p>
定义事务处理标准的目标有两个：
</p>
<ul class="org-ul">
<li>可移植性。使用标准语言编写的程序可以在不同的计算机系统上运行，或提供相应的接口。</li>
<li>互操作性。使用标准方法定义和实现数据交换，以便不同厂商生产的系统可以交换信息。</li>
</ul>

<p>
在讨论标准时，有两个术语要区分清楚，那就是应用程序编程接口（API）以及格式和协议（Formats And Protocols，FAR）。API是语法，FAR是语义。在通信中，FAR包含消息格式和协议两部分。消息格式是FAR中最简单的部分，下面是一个消息格式的示例：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Message</span> {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">address</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">length</span>;
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">buffer</span>[length];
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">checksum</span>;
};
</pre>
</div>

<p>
协议定义了消息应该以什么顺序发送，以及出错时如何处理。协议规则是一个状态机，通常表示为决策表，每个状态转换有一个语义操作。API是驱动这个状态机的子程序。API使得程序具有可移植性，FAR使得系统具有互操作性。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd0af7e0" class="outline-2">
<h2 id="orgd0af7e0">错误处理</h2>
<div class="outline-text-2" id="text-orgd0af7e0">
</div>
<div id="outline-container-org0109e0a" class="outline-3">
<h3 id="org0109e0a">系统可用性</h3>
<div class="outline-text-3" id="text-org0109e0a">
<p>
P(A)表示事件A发生的概率，1-P(A)则是事件A不发生的概率。如果有两个事件，其中一个事件是否发生，不会影响另一个事件发生的概率，这两个事件就叫做独立事件（independent event）。对于两个独立事件A和B，两者同时发生的概率记为P(AB)，P(AB) = P(A)*P(B)。而两者之一发生的概率为
</p>
<blockquote>
<p>
P(A or B) = P(A) + P(B) - P(AB)
</p>
</blockquote>
<p>
当P(A)和P(B)远远小于1时，P(A or B)约等于P(A) + P(B)。
</p>


<p>
电子系统的失败率是无记忆（memoryless）的，即系统失败的概率和系统的运行时间无关。同时失败率通常是很小的数字。对于这样的时间，可以定义时间平均发生时间：
</p>
<blockquote>
<p>
MT(A) = 1/P(A)
</p>
</blockquote>

<p>
假设系统中有3个模块：A、B和C，它们发生故障的事件时独立的。将它们组成一个组G，那么G的发生故障的平均时间是
</p>
<blockquote>
<p>
MT(G) 约等于 1/(P(A) + P(B) + P(C)) 约等于 1/[1/MT(A) + 1/MT(B) + 1/MT(C)]
</p>
</blockquote>

<p>
如果这三个模块的故障平均时间相等，那么MT(G)=MT(A)*1/3。类似的有：
</p>
<blockquote>
<p>
MT(NA) = MT(A) / N
</p>
</blockquote>

<p>
当系统拒绝服务时，我们说服务不可用。这通常是由于模块发生故障导致的。考虑ATM服务的例子。通常，银行会在一个地点设立多个ATM机。假设一个ATM机发生故障，可以使用另一个ATM机完成服务。因此我们不能使用模块的故障平均时间来衡量服务可用的概率，需要引入一个新的概念，叫做系统可用性。系统可用性是按可接受响应时间被处理的负载值，以百分数表示。假设一台ATM平均100天出现一次非预期的中断期，并且平均需要一天时间解决。那么一台ATM机的可用性就是99%，两台ATM机组成的系统，可用性是1-1%*1%=99.99%。如果系统的可用性是A，我们把floor(log10(1/(1-A)))叫做系统的可用性等级。根据可用性等级，系统可以分为：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">系统类型</td>
<td class="org-right">不可用性（分钟/年）</td>
<td class="org-right">可用性</td>
<td class="org-right">级别</td>
</tr>

<tr>
<td class="org-left">无管理</td>
<td class="org-right">52560</td>
<td class="org-right">90%</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">有管理</td>
<td class="org-right">5256</td>
<td class="org-right">99%</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">管理良好</td>
<td class="org-right">526</td>
<td class="org-right">99.9%</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">容错</td>
<td class="org-right">53</td>
<td class="org-right">99.99%</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">高可用</td>
<td class="org-right">5</td>
<td class="org-right">99.999%</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-left">超高可用</td>
<td class="org-right">0.5</td>
<td class="org-right">99.9999%</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-left">极高可用</td>
<td class="org-right">0.05</td>
<td class="org-right">99.99999%</td>
<td class="org-right">7</td>
</tr>
</tbody>
</table>

<p>
一些关键系统对可用性有着极高的要求，比如原子反应堆的监控设备要求达到5级，电话交换机要求达到6级，飞机上的计算机要求达到9级。
</p>
</div>
</div>


<div id="outline-container-org6f3b1ff" class="outline-3">
<h3 id="org6f3b1ff">术语</h3>
<div class="outline-text-3" id="text-org6f3b1ff">
<p>
在建造模块时，我们希望它能够以预想的方式工作，这种逻辑上的理想行为叫做指定行为（specified bahavior）。模块在工作中实际产生的行为叫做观察行为（observed behavior）。如果观察行为违背了指定行为，失败（failure）就会发生。失败发生是因为模块中存在错误（error）或缺陷（defect），导致错误的原因是故障（fault）。从发生错误到发生失败之间的时间叫做错误延迟。在失败发生之前，错误叫做延迟的。在失败发生之后，错误变成有效的。考虑下面的例子：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">int</span> <span style="color: #0000ff;">div</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">y</span>) {
   <span style="color: #a020f0;">return</span> x / y;
}
</pre>
</div>
<p>
这个函数中没有处理除数为0的情况，这是一个错误。如果程序计算div(10,0)就会发生失败，错误变成有效。再比如宇宙射线是一个故障，射线可能破坏一个存储单元，产生存储错误。当处理器读取这个存储单元时，就产生失败，错误变成有效的。
</p>


<p>
一个系统的故障修复流程如下：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">服务可用完成</td>
</tr>

<tr>
<td class="org-left">故障 -&gt; 错误 -&gt;  失败 -&gt;</td>
<td class="org-left">服务中断</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">探测</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">报告</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">更正</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">修复</td>
</tr>
</tbody>
</table>

<p>
模块的行为在服务可完成和服务中断两种状态之间交替。当模块按照指定行为工作时，模块处于服务可完成状态。如果发生失败，模块进入服务中断状态。模块从初始状态到发生下一个失败的平均时间叫做平均无故障时间（MTTF），它是衡量模块可靠性的指标。服务中断的平均时间叫做平均修复时间（MTTR）。MTTF+MTTR就是一个修复周期，在修复周期中，MTTF的占比就是模块的可用性：
</p>
<blockquote>
<p>
模块可用性 = MTTF/(MTTF + MTTR)
</p>
</blockquote>

<p>
提高模块的可靠性需要减少故障，方法是有效确认和纠错。前面提到，错误可以分为延迟的和生效的。因此纠错也分为延迟纠错和生效纠错。延迟纠错在错误生效之前进行，比如预防性维护。生效纠错是在错误变成有效后进行，对错误进行屏蔽或者从错误中恢复。错误屏蔽使用冗余信息（如ECC）建立一个正确的新状态。错误恢复拒绝请求，并将模块设定为一个正确的状态。如果设定为以前的正确状态，这种方式叫做反向错误恢复。如果设定为一个新的正确状态，叫做正向错误恢复。
</p>

<p>
上面的讨论关注于模块行为的正确性。如果模块行为正确，但是消耗的时间远远超过预期，这种情况叫做计时失败。此外，故障可以分为硬故障和软故障。如果发生硬故障，模块将保持较高的故障率，无法正确运行，直到被修复。而软故障是偶发的，模块还可以正常运行。软故障也叫做瞬时故障或间歇故障。
</p>


<p>
前面提到，从错误到失败存在一段时间，叫做失败延迟。如果一个模块在检测到错误后立即停止，我们称这个模块是失败即停（failfast，也叫failstop）的。失败即停是一个重要的特性，它阻止了单一错误演变成级联的，规模更大的错误。失败即停将错误延迟最小化。
</p>
</div>
</div>

<div id="outline-container-org33af8d0" class="outline-3">
<h3 id="org33af8d0">实践研究</h3>
<div class="outline-text-3" id="text-org33af8d0">
<p>
系统不可用也叫做断供（outage）。导致断供的原因主要有：
</p>
<ul class="org-ul">
<li>环境。设施故障，如机房、电源、数据通信线路、天气、地震、火灾等。</li>
<li>操作。正常系统管理、系统配置、系统操作的所有过程和活动。</li>
<li>维护。为了维护和修复硬件和设备所执行的所有过程和活动，不包括软件维护。</li>
<li>硬件。物理设备，不包括环境支持（如空调）。</li>
<li>软件。系统中的所有程序。</li>
<li>过程。由于行政决策而停工（如股票交易所熔断）。</li>
</ul>


<p>
硬件的失败率通常服从浴缸曲线，开始时失败率较高，这个阶段的失败率叫做老化（burn-in）率。接着很长一段时间失败率较低。到了生命周期的末期，失败率再次升高。
</p>
</div>
</div>

<div id="outline-container-org460611f" class="outline-3">
<h3 id="org460611f">硬件容错</h3>
<div class="outline-text-3" id="text-org460611f">
<p>
普通硬件可以很容易的构造成失败即停的模块。把两个失败即停模块的输入输出连接到一个比较器，当输出结果不一致时停止工作。这种方式叫做成对或双工。类似的，可以将n个模块，连接到比较器上。这时的比较器叫做表决器，它选择输出的多数作为结果。如果没有多数结果，模块停止工作。这种表决方案叫做失败表决（failvote），这样的模块叫做n工模块。最常见的情况是n=3，也就是三模冗余（Triple Module Redundancy，TMR）。除了失败表决之外，还有一种表决策略，叫做失败即停表决（failfast voting）。失败即停表决首先判断哪些模块可用，然后根据可用模块的大多数进行表决。
</p>


<p>
假设模块的MTTF是10年。不考虑表决器故障，对于双工模块，MTTF是5年，3工模块的MTTF是8.3年（10/3年发生第一个错误，10/5年发生第二个错误）。看起来n工模块降低了MTTF，但是n工模块提供了失败即停特性，而且如果模块大部分故障是软故障，n工模块可以屏蔽这类故障，大幅提升MTTF。
</p>


<p>
对于一个n工模块，某个特定模块不可用的概率是p<sub>1</sub>=MTTR/(MTTF+MTTR)，近似于MTTR/MTTF。每个模块的故障是独立的，因此其他n-1个模块不可用的概率是p<sub>n-1</sub> &asymp; p<sub>1</sub><sup>n-1</sup>=(MTTR/MTTF)<sup>n-1</sup>。根据MT(A)=1/P(A)，一个模块故障的概率是p<sub>f</sub>=1/MTTF，因此一个模块发生故障后其他模块都不可用的概率是p<sub>f</sub>*p<sub>n-1</sub>=(1/MTTF)(MTTR/MTTF)<sup>n-1</sup>。n工模块发生故障的概率是p<sub>n_plex</sub>=(n/MTTF)(MTTR/MTTF)<sup>n-1</sup>，平均无故障时间是MTTF<sub>n</sub>=(MTTF/n)(MTTF/MTTR)<sup>n-1</sup>。
</p>
</div>
</div>



<div id="outline-container-org3d3f38d" class="outline-3">
<h3 id="org3d3f38d">软件容错</h3>
<div class="outline-text-3" id="text-org3d3f38d">
<p>
下面是两种常用的软件容错技术：
</p>

<ul class="org-ul">
<li>N版本程序设计。编写n个相同功能的程序，仔细检查每个程序，并行的运行每个程序，将结果中的大多数作为最终结果。这种方式类似于n工硬件。</li>
<li>事务。把程序设计成具有一致性检查的ACID状态转换。在事务的最后，如果一致性检查不满足，终止事务并重新开始。</li>
</ul>

<p>
N版本程序设计在开发和维护上的成本很高，而且难以恢复模块的状态，因为每个程序都是独立的，内部状态不能复制到其他程序上。事务可以屏蔽软故障，在失败时将系统恢复的上一个合法的状态。和硬件类似，软件的大部分故障都是软故障，在软件中称作Heisenbug。Heisenbug是一个偶然出现瞬时错误，可能和时间或负载有关。与Heisenbug对应的是Bohrbug，Bohrbug可以稳定复现。事务提供了失败即停特性，它允许系统失败，然后自然的重启。唯一损失的是重启系统的时间。之所以能做到这一点，是因为事务所具有的如下特性：
</p>
<ul class="org-ul">
<li>隔离性。各个程序是隔离的，因此故障也是隔离的。</li>
<li>粒度。通过回滚一个事务来消除事务的影响，提供了一个细粒度的错误处理机制。</li>
<li>一致性。系统的状态是一致的，合法的。</li>
<li>永久性。已经提交的事务不会丢失。</li>
</ul>
<p>
对于分布式系统，通常单一部分无法控制整个系统，因此只能部分重启。因此，分布式系统需要一个类似事务撤销的机制来清除分布式状态。
</p>


<p>
采用失败即停方案编写程序的方法叫做防御式程序设计。在防御式程序设计中，被调用者检查输入的参数，调用者检查函数的返回值。一旦发现错误，立即进行错误处理：要么修复内部状态并屏蔽错误，要么将错误返回给调用者。
</p>


<p>
失败即停产生了立即崩溃并重启的需求，这产生了进程对的概念。当一个进程失败时，另一个进程立即接管工作。
</p>
</div>
</div>

<div id="outline-container-orgf152924" class="outline-3">
<h3 id="orgf152924">故障模型</h3>
<div class="outline-text-3" id="text-orgf152924">
<p>
设计容错程序需要一个模型，这个模型必须定义正确的功能和各种错误。模型包含三种实体：进程、消息和存储。每个实体都具有期望行为集合以及故障行为集合。故障行为又可以分为预期故障（即设计中可以容错的故障）和非预期故障（即设计中不可容错的故障）。下面简单描述一下这个模型：存储模块读写存储地址中的数据，偶尔会读写到错误的地址、无效的页或破坏整个存储器。对于可能出现这些错误的存储模块，可以设计一个故障屏蔽程序，采用失败表决双工，并使用后台程序修复故障。消息可能丢失、复制、延迟、破坏和改变序列。通过实现会话、设定超时和增加序列号，可以把这些错误都转化为消息丢失。加上消息确认、发送超时和消息重传，可以建立高可用的消息系统。这两部分是通过软件屏蔽硬件错误的办法。那么要如何屏蔽软件错误呢？首先建立软件错误模型。有三种情况可以引起进程失败：经被延迟，且延迟时间超过修复时间、进程的全部数据丢失和进程的全部输入输出消息丢失。我们使用这个模型来建立进程对。开始时，一个进程负责工作，这个进程叫做主进程，另外一个是后备进程。主进程周期性的发送“I'm alive“消息给后备进程。如果后备进程在两到三个周期内没有收到消息，它就认为主进程失败，立即接管工作。接管有三种方式：
</p>

<ul class="org-ul">
<li>检查点重启。主进程将自己的状态记录到双工存储模块，在接管时，后备进程通过读双工存储页开始启动。</li>
<li>检查点消息。主进程把自身状态的改变作为消息发送给后备进程。重启时，后备进程从最近的消息得到当前状态。</li>
<li>持久进程。后备进程从空状态开始，让事务机制清除（撤销）最近还没有提交的状态变化。</li>
</ul>

<p>
进程对提供了快速修复特性，它是软件容错的关键。
</p>
</div>

<div id="outline-container-org011a2b7" class="outline-4">
<h4 id="org011a2b7">高可用存储模拟</h4>
<div class="outline-text-4" id="text-org011a2b7">
<p>
下面我们用程序模拟高可用存储的行为。存储模块包含一个页面数组和一个状态标志。如果标志为false，表示模块损坏，模块中所有页的操作都返回false。每个页有地址、值和状态。页的值是最近一次写入该页的数据。如果页的状态是false，页的值是无效的。存储模块中定义了两种行为：写页的值和读页的值。这里假设页的读写操作是原子的。
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">const</span> <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">Many</span> = 100;
<span style="color: #a020f0;">const</span> <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">MaxStoreNumber</span> = Many;
<span style="color: #a020f0;">const</span> <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">MaxPageNumber</span> = Many;
<span style="color: #a020f0;">const</span> <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">PageSize</span> = 8192;
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">PageValue</span> = <span style="color: #228b22;">char</span>*;
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">Address</span> = <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span>;
<span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span> <span style="color: #a0522d;">WriteFailureProbability</span> = 1e-6;

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Page</span> {
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">status</span>;
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">value</span>[PageSize];
};

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Store</span> {
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">status</span>;
    <span style="color: #228b22;">Page</span> <span style="color: #a0522d;">page</span>[MaxPageNumber];
};

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">StoreArray</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">Store</span>&gt;;

<span style="color: #228b22;">StoreArray</span> <span style="color: #a0522d;">stores</span>;

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">store_write</span>(<span style="color: #228b22;">Store</span> <span style="color: #a0522d;">store</span>, <span style="color: #228b22;">Address</span> <span style="color: #a0522d;">address</span>, <span style="color: #228b22;">PageValue</span> <span style="color: #a0522d;">value</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#22320;&#22336;&#38169;&#35823;&#12290;</span>
    <span style="color: #a020f0;">if</span> (address &gt;= MaxStoreNumber) {
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
    }

    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#23384;&#20648;&#25925;&#38556;&#12290;</span>
    <span style="color: #a020f0;">if</span> (!store.status) {
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
    }

    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#27169;&#25311;&#20889;&#22833;&#36133;&#12290;</span>
    <span style="color: #a020f0;">if</span> (WriteFailureProbability &gt; random()) {
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
    }

    store.page[address].status = <span style="color: #008b8b;">true</span>;
    memcpy(store.page[address].value, value, PageSize);
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">store_read</span>(<span style="color: #228b22;">Store</span> <span style="color: #a0522d;">store</span>, <span style="color: #228b22;">Address</span> <span style="color: #a0522d;">address</span>, <span style="color: #228b22;">PageValue</span> <span style="color: #a0522d;">value</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#22320;&#22336;&#38169;&#35823;&#12290;</span>
    <span style="color: #a020f0;">if</span> (address &gt;= MaxStoreNumber) {
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
    }

    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#23384;&#20648;&#25925;&#38556;&#12290;</span>
    <span style="color: #a020f0;">if</span> (!store.status) {
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
    }

    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#39029;&#25925;&#38556;&#12290;</span>
    <span style="color: #a020f0;">if</span> (!store.page[address].status) {
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
    }

    memcpy(value, store.page[address].value, PageSize);
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}
</pre>
</div>

<p>
这个程序模拟了存储设备写失败的情况。下面我们用页衰减来模拟写入地址错误的情况。读写一个不正确的地址将产生false状态标志。判断地址正确与否的方法是将地址作为值的一部分写入页。同时为了保证值的准确性，会在页的值中保存校验码。
</p>
<div class="org-src-container">
<pre class="src src-c++">
<span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span> <span style="color: #a0522d;">PageMTTF</span> = 7e5;   <span style="color: #b22222;">// </span><span style="color: #b22222;">&#39029;&#24179;&#22343;&#38169;&#35823;&#26102;&#38388;</span>
<span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span> <span style="color: #a0522d;">StoreMTTF</span> = 1e8;  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#23384;&#20648;&#24179;&#22343;&#38169;&#35823;&#26102;&#38388;</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">store_decay</span>(<span style="color: #228b22;">Store</span> <span style="color: #a0522d;">store</span>) {
    <span style="color: #228b22;">Address</span> <span style="color: #a0522d;">address</span>;
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">pageFailTime</span> = time() - log(PageMTTF * random());
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">storeFailTime</span> = time() - log(StoreMTTF * random());

    <span style="color: #a020f0;">while</span> (<span style="color: #008b8b;">true</span>) {
        <span style="color: #228b22;">unsigned</span> <span style="color: #a0522d;">wait_time</span> = <span style="color: #008b8b;">std</span>::min(pageFailTime, storeFailTime) - time();
        <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">this_thread</span>::sleep_for(<span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">chrono</span>::seconds(wait_time));

        <span style="color: #a020f0;">if</span> (time() &gt;= pageFailTime) {
            address = random() * MaxPageNumber;
            store.page[address].status = <span style="color: #008b8b;">false</span>;
            pageFailTime = time() - log(PageMTTF * random());
        }

        <span style="color: #a020f0;">if</span> (time() &gt;= storeFailTime) {
            store.status = <span style="color: #008b8b;">false</span>;
            <span style="color: #a020f0;">for</span> (address = 0; address &lt; MaxPageNumber; address++) {
                store.page[address].status = <span style="color: #008b8b;">false</span>;
            }
            storeFailTime = time() - log(StoreMTTF * random());
        }
    }
}
</pre>
</div>

<p>
在不可靠存储上构建可靠存储，思路就是n工存储和修复。我们把存储划分为n个组，每个组作为一个逻辑上的存储模块，这样就得到了一个容量为原来1/n的n工存储。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">NPlex</span> = 2;
<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">reliable_write</span>(<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">group</span>, <span style="color: #228b22;">Address</span> <span style="color: #a0522d;">address</span>, <span style="color: #228b22;">PageValue</span> <span style="color: #a0522d;">value</span>) {
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">i</span>;
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">status</span> = <span style="color: #008b8b;">false</span>;
    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#32452;&#26080;&#25928;&#12290;</span>
    <span style="color: #a020f0;">if</span> (group &gt;= MaxStoreNumber / NPlex) {
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
    }

    <span style="color: #a020f0;">for</span> (i = 0; i &lt; NPlex; i++) {
        status = status || store_write(stores[group * NPlex + i], address, value);
    }
    <span style="color: #a020f0;">return</span> status;
}
</pre>
</div>

<p>
和reliable_write()相比，函数reliable_read()更为复杂，因为它需要处理两个问题。一，如果n个组都读取失败，函数返回失败。这种情况应该极为少见。如果这种情况频繁出现，需要考虑增加n的值。二，如果n个组中一些可以读，但是读取的值不相同，要如何解决歧义呢？一种办法是取大多数值，另一种办法是取最新的值。采用后一种方法时，要为页的每个值增加版本号，作为值的一部分，写入页中。函数reliable_read()同时还承担着错误屏蔽的责任，即修复n工模块中的错误页。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #0000ff;">version</span>(<span style="color: #228b22;">PageValue</span> <span style="color: #a0522d;">value</span>);

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">reliable_read</span>(<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">group</span>, <span style="color: #228b22;">Address</span> <span style="color: #a0522d;">address</span>, <span style="color: #228b22;">PageValue</span> <span style="color: #a0522d;">value</span>) {
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">i</span> = 0;
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">found</span> = <span style="color: #008b8b;">false</span>;
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">need_repair</span> = <span style="color: #008b8b;">false</span>;
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">local_buffer</span>[PageSize];
    <span style="color: #228b22;">PageValue</span> <span style="color: #a0522d;">buffer</span> = <span style="color: #a020f0;">static_cast</span>&lt;<span style="color: #228b22;">PageValue</span>&gt;(local_buffer);
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">status</span>;

    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#32452;&#38169;&#35823;&#12290;</span>
    <span style="color: #a020f0;">if</span> (group &gt;= MaxStoreNumber / NPlex) {
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
    }

    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#22320;&#22336;&#38169;&#35823;&#12290;</span>
    <span style="color: #a020f0;">if</span> (address &gt;= MaxPageNumber) {
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
    }

    <span style="color: #a020f0;">for</span> (i = 0; i &lt; NPlex; i++) {
        status = store_read(stores[group * NPlex + i], address, buffer);
        <span style="color: #b22222;">// </span><span style="color: #b22222;">&#35835;&#21462;&#39029;&#22833;&#36133;</span>
        <span style="color: #a020f0;">if</span> (!status) {
            need_repair = <span style="color: #008b8b;">true</span>;
            <span style="color: #a020f0;">continue</span>;
        }

        <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31532;&#19968;&#27425;&#35835;&#21040;&#21512;&#27861;&#39029;</span>
        <span style="color: #a020f0;">if</span> (!found) {
            memcpy(value, buffer, PageSize);
            found = <span style="color: #008b8b;">true</span>;
            <span style="color: #a020f0;">continue</span>;
        }

        <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21028;&#26029;&#26159;&#21542;&#26368;&#26032;</span>
        <span style="color: #a020f0;">if</span> (version(buffer) != version(value)) {
            memcpy(value, buffer, PageSize);
        }
    }

    <span style="color: #a020f0;">if</span> (!found) {
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
    }

    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20462;&#22797;&#38169;&#35823;&#30340;&#39029;</span>
    <span style="color: #a020f0;">if</span> (need_repair) {
        reliable_write(group, address, value);
    }

    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}
</pre>
</div>

<p>
如果一个n工的页很长时间没有读，它的n个副本都可能发生衰减。为了避免这种情况，需要增加一个修复进程，以一定的频率读取每个页，通过reliable_read()修复错误的页。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">store_repair</span>(<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">group</span>) {
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">address</span>;
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">local_buffer</span>[PageSize];
    <span style="color: #228b22;">PageValue</span> <span style="color: #a0522d;">value</span> = <span style="color: #a020f0;">static_cast</span>&lt;<span style="color: #228b22;">PageValue</span>&gt;(local_buffer);

    <span style="color: #a020f0;">while</span> (<span style="color: #008b8b;">true</span>) {
        <span style="color: #a020f0;">for</span> (address = 0; address &lt; MaxPageNumber; address++) {
            <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20197;&#19968;&#31186;&#30340;&#39057;&#29575;&#12290;</span>
            <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">this_thread</span>::sleep_for(<span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">chrono</span>::seconds(1));
            reliable_read(group, address, value);
        }
    }
}
</pre>
</div>


<p>
如果磁盘发生错误的概率很低，我们可以采用一种乐观读的方法优化读的速度。乐观读尝试读取一个组，只有在失败时，才读取其他的组。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">bool</span> <span style="color: #0000ff;">optimistic_read</span>(<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">group</span>, <span style="color: #228b22;">Address</span> <span style="color: #a0522d;">address</span>, <span style="color: #228b22;">PageValue</span> <span style="color: #a0522d;">value</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#32452;&#38169;&#35823;&#12290;</span>
    <span style="color: #a020f0;">if</span> (group &gt;= MaxStoreNumber / NPlex) {
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
    }

    <span style="color: #a020f0;">if</span> (address &gt;= MaxPageNumber) {
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
    }

    <span style="color: #a020f0;">if</span> (store_read(stores[NPlex * group], address, value)) {
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
    }

    <span style="color: #a020f0;">return</span> reliable_read(group, address, value);
}
</pre>
</div>

<p>
乐观读的速度较快，但也存在可能读到脏数据（非最新版本的数据）的缺点。
</p>
</div>
</div>





<div id="outline-container-orgcc3eb70" class="outline-4">
<h4 id="orgcc3eb70">高可用进程模拟</h4>
<div class="outline-text-4" id="text-orgcc3eb70">
<p>
高可靠和高可用进程通过失败即停和消息来构建。消息是进程向另一个进程发送的值，消息可能丢失、篡改、复制和乱序。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span> <span style="color: #a0522d;">MessageFailureProbability</span> = 1e-5;
<span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span> <span style="color: #a0522d;">MessageDuplicateProbability</span> = 1e-5;

<span style="color: #a020f0;">const</span> <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">ValueSize</span> = 8192;
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">Value</span> = <span style="color: #228b22;">char</span>[ValueSize];

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Message</span> {
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">status</span>;
    <span style="color: #228b22;">Message</span> *<span style="color: #a0522d;">next</span>;
    <span style="color: #228b22;">Value</span> <span style="color: #a0522d;">value</span>;
};

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">message_send</span>(<span style="color: #228b22;">Process_id</span> <span style="color: #a0522d;">target</span>, <span style="color: #228b22;">Value</span> <span style="color: #a0522d;">value</span>);
<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">message_get</span>(<span style="color: #228b22;">Value</span> *<span style="color: #a0522d;">value</span>, <span style="color: #228b22;">bool</span> *<span style="color: #a0522d;">status</span>);
</pre>
</div>

<p>
下面是进程使用消息的示例程序：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">bool</span> <span style="color: #0000ff;">get_message</span>(<span style="color: #228b22;">Value</span> *<span style="color: #a0522d;">value</span>) {
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">message_status</span> = <span style="color: #008b8b;">false</span>;
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">message_exist</span> = <span style="color: #008b8b;">false</span>;

    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#30452;&#21040;&#35835;&#21462;&#19968;&#20010;&#28040;&#24687;&#25110;&#28040;&#24687;&#38431;&#21015;&#20026;&#31354;&#12290;</span>
    <span style="color: #a020f0;">while</span> (!message_status) {
        message_exist = message_get(value, &amp;message_status);
        <span style="color: #b22222;">// </span><span style="color: #b22222;">&#28040;&#24687;&#38431;&#21015;&#20026;&#31354;&#65292;&#36864;&#20986;&#24490;&#29615;&#12290;</span>
        <span style="color: #a020f0;">if</span> (!message_exist) {
            <span style="color: #a020f0;">break</span>;
        }
    }

    <span style="color: #a020f0;">return</span> message_exist;
}
</pre>
</div>

<p>
现在来看进程故障模型。进程执行一个程序，转换进程状态，显示执行的动作。进程的外部行为是由store_read()、store_write()、message_send()和message_get()组成的一个序列。进程的状态是一个包含了程序和数据的字节数组。进程有两个状态：固定不变的初始状态，以及随程序执行而变化的当前状态。进程还有一个输入队列，记录了其他进程发送过来的消息。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">const</span> <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">MaxProcessNumber</span> = 100000;
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">Process_id</span> = <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span>;

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Process_state</span> {
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">program</span>[ValueSize];
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">data</span>[ValueSize];
};

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Process</span> {
    <span style="color: #228b22;">Process_state</span> <span style="color: #a0522d;">initial_state</span>;
    <span style="color: #228b22;">Process_state</span> <span style="color: #a0522d;">current_state</span>;
    <span style="color: #228b22;">Message</span>* <span style="color: #a0522d;">message_list</span>;
};
</pre>
</div>

<p>
进程可能由于停止了一段时间而失败，然后进行修复，重置为初始状态，丢弃全部未处理的消息。如果程序进行了防御式程序设计，当遇到内部错误时，程序也会通过panic()函数主动引发进程失败。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span> <span style="color: #a0522d;">ProcessMTTF</span> = 1e7;
<span style="color: #a020f0;">const</span> <span style="color: #228b22;">double</span> <span style="color: #a0522d;">ProcessMTTR</span> = 1e4;

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">process_execution</span>(<span style="color: #228b22;">Process_id</span> <span style="color: #a0522d;">pid</span>) {
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">processFailureTime</span>;
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">processRepairTime</span>;
    <span style="color: #228b22;">Message</span> *<span style="color: #a0522d;">message</span>, *<span style="color: #a0522d;">next_message</span>;

    <span style="color: #a020f0;">while</span> (<span style="color: #008b8b;">true</span>) {
        processFailureTime = time() - log(random()) * ProcessMTTF;
        processRepairTime = -log(random()) * ProcessMTTR;
        <span style="color: #a020f0;">while</span> (time() &lt; processFailureTime) {
            execute(processs[pid].current_state);
        }

        wait(processRepairTime);
        memcpy(process[pid].current_state, process[pid].initial_state, ValueSize);
        <span style="color: #a020f0;">while</span> (message_get(message, status)) {}
    }
}
</pre>
</div>

<p>
到目前为止，进程是失败即停的，在失败时将状态重置为空。这和失败即停存储类似。因此需要某个机制修复进程状态，即将状态设置为最新的合法状态。为了简化模型，我们假设进程状态可以用一个页保存。服务器对每个客户请求返回一个唯一的序列号，叫做标签。服务器必须记住最近返回的标签。最简单的方法是在可靠存储中记录下当前状态的两个副本，状态变化时，覆盖其中更老的副本。重启时，从较新的副本中重建状态。
</p>
<div class="org-src-container">
<pre class="src src-c++">
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">checkpoint_restart_process</span>() {
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">disk</span> = 0;
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">address</span>[2] = {0, 1};
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">index</span>;
    <span style="color: #a020f0;">struct</span> {
        <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">ticket_number</span>;
        <span style="color: #228b22;">char</span> <span style="color: #a0522d;">filter</span>[ValueSize];
    } <span style="color: #a0522d;">value</span>[2];
    <span style="color: #a020f0;">struct</span> {
        <span style="color: #228b22;">Process_id</span> <span style="color: #a0522d;">pid</span>;
        <span style="color: #228b22;">char</span> <span style="color: #a0522d;">filter</span>[ValueSize];
    } <span style="color: #a0522d;">message</span>;

    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#35835;&#21462;&#20004;&#20010;&#29366;&#24577;&#65292;&#36873;&#25321;&#26032;&#29366;&#24577;</span>
    <span style="color: #a020f0;">for</span> (index = 0; index &lt; 2; index++) {
        <span style="color: #a020f0;">if</span> (!reliable_read(disk, address[index], value[index])) {
            panic();
        }
    }

    index = 1;
    <span style="color: #a020f0;">if</span> (value[0].ticket_number &lt; value[1].ticket_number) {
        index = 0;
        memcpy(value[0], value[1], ValueSize);
    }

    <span style="color: #a020f0;">while</span> (<span style="color: #008b8b;">true</span>) {
        <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31561;&#24453;&#28040;&#24687;&#12290;</span>
        <span style="color: #a020f0;">while</span> (!get_msg(&amp;message)) {};
        value[0].ticket_number = value[0].ticket_number + 1;
        <span style="color: #a020f0;">if</span> (!reliable_write(disk, address[index], value[0])) {
            panic();
        }
        index = (index + 1) % 2;
        message_send(message.pid, value[0]);
    }
}
</pre>
</div>

<p>
检查点重启的方法可以产生高可靠的进程，缺点是修复时间较长。下面来考虑进程对的方案。进程对和n工存储类似。系统里有n个进程，其中一个提供服务，叫做主进程，其他的叫做后备进程。如果主进程失败，一个后备进程接管工作。在n等于2时，这个方案叫做进程对。进程对在接管时有两个问题需要考虑：
</p>
<ul class="org-ul">
<li>探测。如何知道主进程失败？如果持续收不到主进程的“I'm Alive”消息，后备进程认为主进程失败。</li>
<li>连续性。如何知道主进程的最新状态？通常的方法是将主进程的状态同“I'm Alive”消息一起发给后备进程，这个消息叫做检查点消息。</li>
</ul>

<p>
在接管的过程也需要客户参与。考虑这种情况：主进程发送应答和客户端后，在发送“I'm Alive”消息之前失败。后备进程接管后，会重新处理这个消息，因此客户会收到重复的应答。客户必须能够处理这种情况。
</p>


<p>
主进程的处理逻辑如下：
</p>
<ul class="org-ul">
<li>广播：我是主进程。</li>
<li>回复上一个请求。</li>
<li>进入主循环：
<ul class="org-ul">
<li>如果达到心跳定时，发送“I'm Alive”给后备进程。</li>
<li>如果有输入：
<ul class="org-ul">
<li>读取消息。</li>
<li>计算新状态。</li>
<li>发送新状态给后备进程。</li>
<li>应答。</li>
</ul></li>
</ul></li>
</ul>

<p>
后备进程的处理逻辑如下：
</p>
<ul class="org-ul">
<li>如果不是默认主进程，等待1秒。</li>
<li>进入后备循环：
<ul class="org-ul">
<li>如果超时，切换为主进程。</li>
<li>读取消息。</li>
<li>更新状态。</li>
</ul></li>
</ul>


<p>
如果一个程序能够可靠的表明一个操作是否完成，是否达到预期结果，这个操作就是可测的。移动到一个绝对位置是可测的，而相对位置移动，如移动一英寸，则是不可测。如果一个操作可以重复执行，而结果和第一次执行是一样的，这个操作就叫做可重来的或幂等的。在进程对接管时，后备进程无法判断主进程的应答是否发送，因此会重复发送消息，客户对消息的处理必须是幂等的。
</p>


<p>
进程对中一类特殊的例子，叫做持久进程对。持久进程对几乎总是处于初始状态，它完成服务器的功能，恢复客户并返回初始状态。持久进程对以事务的形式保存它的状态。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">persistent_process</span>() {
    wait_to_be_primary();
    <span style="color: #a020f0;">while</span> (<span style="color: #008b8b;">true</span>) {
        begin_work();
        read_request();
        do_it();
        commit_work();
        reply();
    }
}
</pre>
</div>

<p>
下面是一个标签服务器示例：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">persistent_ticket_server</span>() {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">ticket_number</span>;
    <span style="color: #a020f0;">struct</span> {
        <span style="color: #228b22;">Process_id</span> <span style="color: #a0522d;">him</span>;
        <span style="color: #228b22;">char</span> <span style="color: #a0522d;">filter</span>[ValueSize];
    } <span style="color: #a0522d;">message</span>;

    wait_to_be_primary();
    <span style="color: #a020f0;">while</span> (<span style="color: #008b8b;">true</span>) {
        begin_work();
        <span style="color: #a020f0;">while</span> (!get_message(&amp;message)) {}
        exec_sql(<span style="color: #8b2252;">"UPDATE ticket SET ticket_number=ticket_number+1"</span>);
        ticket_number = exec_sql(<span style="color: #8b2252;">"SELECT MAX(ticket_number) FROM ticket"</span>);
        commit_work();
        message_send(message.him, value);
    }
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org2862389" class="outline-4">
<h4 id="org2862389">高可用消息模拟</h4>
<div class="outline-text-4" id="text-org2862389">
<p>
message_send()把消息发送给另外一个进程，将消息从发送者地址空间复制到接收者的消息队列，接收者调用message_get()时，将消息从消息队列复制到自己的地址空间。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">bool</span> <span style="color: #0000ff;">message_send</span>(<span style="color: #228b22;">Process_id</span> <span style="color: #a0522d;">him</span>, <span style="color: #228b22;">Value</span> <span style="color: #a0522d;">value</span>) {
    <span style="color: #228b22;">Message</span> *<span style="color: #a0522d;">message</span>;
    <span style="color: #228b22;">Message</span> *<span style="color: #a0522d;">message_queue</span>;

    <span style="color: #a020f0;">if</span> (him &gt; MaxProcessNumber) {
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
    }

    <span style="color: #a020f0;">while</span> (<span style="color: #008b8b;">true</span>) {
        message = (<span style="color: #228b22;">Message</span>*) malloc(<span style="color: #a020f0;">sizeof</span>(Message));
        message-&gt;status = <span style="color: #008b8b;">true</span>;
        message-&gt;next = <span style="color: #008b8b;">nullptr</span>;
        memcpy(message-&gt;value, value, ValueSize);
        message_queue = process[him].messages;
        <span style="color: #a020f0;">if</span> (message_queue == <span style="color: #008b8b;">nullptr</span>) {
            process[him].messages = message;
        } <span style="color: #a020f0;">else</span> {
            <span style="color: #a020f0;">while</span> (message_queue-&gt;next != <span style="color: #008b8b;">nullptr</span>) {
                message_queue = message_queue-&gt;next;
            }
            message_queue-&gt;next = message;
        }

        <span style="color: #b22222;">// </span><span style="color: #b22222;">&#27169;&#25311;&#28040;&#24687;&#25439;&#22351;</span>
        <span style="color: #a020f0;">if</span> (random() &lt; MessageFailureProbability) {
            message-&gt;status = <span style="color: #008b8b;">false</span>;
        }

        <span style="color: #b22222;">// </span><span style="color: #b22222;">&#27169;&#25311;&#28040;&#24687;&#37325;&#22797;</span>
        <span style="color: #a020f0;">if</span> (random() &lt; MessageDuplicateProbability) {
            <span style="color: #a020f0;">continue</span>;
        }

        <span style="color: #a020f0;">break</span>;
    }

    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">message_get</span>(<span style="color: #228b22;">Value</span> *<span style="color: #a0522d;">value</span>, <span style="color: #228b22;">bool</span> *<span style="color: #a0522d;">status</span>) {
    <span style="color: #228b22;">Process_id</span> <span style="color: #a0522d;">self</span> = current_pid();
    <span style="color: #228b22;">Message</span> *<span style="color: #a0522d;">message</span>;
    message = process[self].messages;
    <span style="color: #a020f0;">if</span> (message == <span style="color: #008b8b;">nullptr</span>) {
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
    }

    process[self].messages = message-&gt;next;
    *status = message-&gt;status;
    memcpy(value, message-&gt;value, ValueSize);
    free(message);
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}
</pre>
</div>

<p>
从上面的代码可以看到，消息不是失败即停的。所以构建可靠消息的第一步是为消息建立失败即停语义。这需要从接收方考虑：消息依次接收，一些消息在接收前丢失。这个模型里消息只有一种失败方式：丢失。通过在消息里保存校验码可以判断消息是否被破坏，忽略破坏的消息，就可以把消息破坏错误转化为消息丢失。忽略重复消息和序列号不匹配的消息，可以将重复和乱序的错误转化成消息丢失。这需要会话机制支持。在会话中，消息按照顺序传递，可以延迟，但不会重复和乱序。要实现这样的会话语义，每个端点需要保存3个序列号：输出序列号、输入序列号和确认序列号。在发送新消息时，输出序列号加1。在收到消息时，如果序列号是输入序列号加1，接收这个消息，并增加输入序列号，然后发送一个无次序的确认消息给对方。对于消息重复和乱序的情况，检查消息的序列号就可以知道。
</p>


<p>
在会话的基础上增加超时重传，就可以得到一个可靠的消息传输机制。发送者设定一个超时期，如果一直收不到对方的确认消息，在超时期过后，发送方重新发送消息。只要发送方和接收方一直运行，消息最终可以传递。发送方和接收方能够一直运行吗？我们可以把他们构造成进程对，这样，会话端点和会话自身都是可靠的。下面是会话的示例代码：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Session</span> {
    <span style="color: #228b22;">Process_id</span> <span style="color: #a0522d;">source</span>;
    <span style="color: #228b22;">Process_id</span> <span style="color: #a0522d;">target</span>;
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">last_in</span>;
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">last_out</span>;
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">last_ack</span>;
};

<span style="color: #a020f0;">enum</span> <span style="color: #a020f0;">class</span> <span style="color: #228b22;">Message_type</span> {<span style="color: #a0522d;">MessageNew</span>, <span style="color: #a0522d;">MessageAck</span>, <span style="color: #a0522d;">MessageTakeOver</span>};

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Session_message</span> {
    <span style="color: #228b22;">Session</span> *<span style="color: #a0522d;">session</span>;
    <span style="color: #228b22;">Message_type</span> <span style="color: #a0522d;">type</span>;
    <span style="color: #228b22;">Value</span> <span style="color: #a0522d;">value</span>;
};

<span style="color: #228b22;">Session</span>* <span style="color: #a0522d;">my_session</span>[MaxProcessNumber]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#23646;&#20110;&#24403;&#21069;&#36827;&#31243;&#30340;&#20250;&#35805;&#12290;</span>
<span style="color: #228b22;">Message</span>* <span style="color: #a0522d;">in_message_queue</span>[MaxProcessNumber]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#24050;&#32463;&#30830;&#35748;&#30340;&#36755;&#20837;&#28040;&#24687;&#12290;</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">initialize_sessions</span>() {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">him</span>;
    <span style="color: #a020f0;">for</span> (him = 0; him &lt; MaxProcessNumber; him++) {
        my_session[him].source = MyPID();
        my_session[him].target = him;
        my_session[him].last_in = 0;
        my_session[him].last_ack = 0;
        my_session[him].last_out = 0;
        in_message_queue[him] = <span style="color: #008b8b;">nullptr</span>;
    }
}

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">session_get</span>(<span style="color: #228b22;">Session</span> *<span style="color: #a0522d;">session</span>, <span style="color: #228b22;">Message_type</span> *<span style="color: #a0522d;">type</span>, <span style="color: #228b22;">Value</span> *<span style="color: #a0522d;">value</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31867;&#20284;message_get</span>
}

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">session_send</span>(<span style="color: #228b22;">Session</span> *<span style="color: #a0522d;">session</span>, <span style="color: #228b22;">Message_type</span> <span style="color: #a0522d;">type</span>, <span style="color: #228b22;">Value</span> <span style="color: #a0522d;">value</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31867;&#20284;message_send</span>
}

<span style="color: #a020f0;">const</span> <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">timeout</span> = 1;
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">reliable_send_message</span>(<span style="color: #228b22;">Process_id</span> <span style="color: #a0522d;">him</span>, <span style="color: #228b22;">Value</span> <span style="color: #a0522d;">value</span>) {
    <span style="color: #228b22;">Session</span> *<span style="color: #a0522d;">session</span> = &amp;my_session[him];
    session-&gt;last_out = session-&gt;last_out + 1;
    checkpoint(*session, value);
    <span style="color: #a020f0;">do</span> {
        session_send(*session, MessageNew, value);
        wait(timeout);
    } <span style="color: #a020f0;">while</span> (session-&gt;last_out != session-&gt;last_ack);
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">listen</span>() {
    <span style="color: #228b22;">Session</span> *<span style="color: #a0522d;">session</span>;
    <span style="color: #228b22;">Process_id</span> <span style="color: #a0522d;">him</span>;
    <span style="color: #228b22;">Message_type</span> <span style="color: #a0522d;">type</span>;
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">sequence_number</span>;
    <span style="color: #228b22;">Value</span> <span style="color: #a0522d;">value</span>;
    <span style="color: #228b22;">Message</span> *<span style="color: #a0522d;">it</span>;
    <span style="color: #228b22;">Message</span> *<span style="color: #a0522d;">queue</span>;

    initialize_sessions();

    <span style="color: #a020f0;">while</span> (<span style="color: #008b8b;">true</span>) {
        <span style="color: #a020f0;">while</span> (session_get(&amp;session, &amp;type, &amp;value)) {
            him = session.source;
            sequence_number = session.last_out;
            <span style="color: #a020f0;">switch</span> (type) {
            <span style="color: #a020f0;">case</span> MessageNew:
                <span style="color: #a020f0;">if</span> (my_session[him].last_in == (sequence_number - 1)) {
                    it = malloc(<span style="color: #a020f0;">sizeof</span>(Message));
                    copy(it-&gt;value, value, ValueSize);
                    it-&gt;next = <span style="color: #008b8b;">nullptr</span>;
                    <span style="color: #a020f0;">if</span> (in_message_queue[him] == <span style="color: #008b8b;">nullptr</span>) {
                        in_message_queue[him] = it;
                    } <span style="color: #a020f0;">else</span> {
                        <span style="color: #a020f0;">for</span> (queue = in_message_queue[him]; queue-&gt;next != <span style="color: #008b8b;">nullptr</span>; queue = queue-&gt;next) {
                            queue-&gt;next = it;
                        }
                    }
                    my_session[him].last_in++;
                    checkpoint(my_session[him], value);
                }

                session_send(session, MessageAck, value);
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">case</span> MessageAck:
                <span style="color: #a020f0;">if</span> (session.last_out == my_session[him].last_out) {
                    my_session[him].last_ack++;
                }
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">case</span> MessageTakeOver:
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">default</span>:
                <span style="color: #a020f0;">break</span>;
            }
        }
        wait(1);
    }
}

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">reliable_get_message</span>(<span style="color: #228b22;">Process_id</span> <span style="color: #a0522d;">him</span>, <span style="color: #228b22;">Value</span> <span style="color: #a0522d;">value</span>) {
    <span style="color: #228b22;">Message</span>* <span style="color: #a0522d;">message</span> = in_message_queue[him];
    <span style="color: #a020f0;">if</span> (message == <span style="color: #008b8b;">nullptr</span>) {
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
    }

    in_message_queue[him] = message-&gt;next;
    copy(value, message-&gt;value, ValueSize);
    free(message);
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}
</pre>
</div>

<p>
注意消息的发送是异步的，因此等待消息发送结果可能导致死锁。
</p>
</div>
</div>
</div>

<div id="outline-container-orgc4e2ece" class="outline-3">
<h3 id="orgc4e2ece">一般原理</h3>
<div class="outline-text-3" id="text-orgc4e2ece">
<p>
在设计系统时有两条准则值得考虑：
</p>
<ul class="org-ul">
<li>KISS：Keep It Simple Stupid</li>
<li>Murphy定律：任何可能发生错误的东西，都会在最糟的情况下发生错误。</li>
</ul>

<p>
根据Murphy定律，任何错误都必须处理，而失败即停简化了错误模型，做到了KISS。从更宏观的角度考虑时，我们可以发现，事务系统是一个更大的，包括了人、过程、训练、组织和物理存储在内的大系统的一部分。这个系统反映了现实世界中的一个逻辑模型。系统和现实世界可能存在差异，这时就发生了错误。如果差异比较小，修复机制可以补偿和屏蔽错误。但是如果差异过大，系统将进入一个不稳定的状态，自身的修复机制将无法保证系统正确运行。
</p>
</div>
</div>
</div>

<div id="outline-container-orga2d6b6d" class="outline-2">
<h2 id="orga2d6b6d">事务模型</h2>
<div class="outline-text-2" id="text-orga2d6b6d">
</div>
<div id="outline-container-orgca84c17" class="outline-3">
<h3 id="orgca84c17">原子操作</h3>
<div class="outline-text-3" id="text-orgca84c17">
<p>
事务具有原子性，这个原子性是从调用者的角度来定义的，并且是逻辑上的。要构造原子操作需要付出额外的努力。要满足原子性，需要对操作的两个方面进行描述：系统中的其他操作何时对操作的结果进行存取，以及操作失败时如何回滚。
</p>


<p>
下面我们通过一个写磁盘操作来说明原子性。从根本上来说，写操作可以分为4类：
</p>
<ul class="org-ul">
<li>简单写。如果发生错误，可能将数据写入错误地址，或写入部分数据。</li>
<li>带读检验写。首先执行简单写，然后读取数据，发现不一致时，重新执行操作。这种方法无法提供原子性，原因有3点：第一，无法恢复到初始状态；第二，如果磁盘块故障，经过最大重试次数后，仍然无法正确写入；第三，如果系统崩溃，磁盘将处于不确定状态。</li>
<li>双重写。为每个块保留一个版本号，每次写操作后加一。写入时将数据保存到两个不同的位置A和B。读取时取二者版本号最大的为有效数据。为了避免磁盘故障，A和B应当位于不同的磁盘上。如果一个位置的磁盘块故障，应当重新分配一个位置。</li>
<li>带日志写。首先读取初始内容，使用简单写保存到另外的位置。然后使用简单写保存数据，接着读取数据检查写入是否成功。写入成功功能，旧值被丢弃。如果系统崩溃，可以使用旧值恢复到初始状态。</li>
</ul>


<p>
系统中的操作可以分为3类：
</p>
<ul class="org-ul">
<li>无保护操作。这类操作不可靠，不具有ACID特性，如简单写操作。</li>
<li>有保护操作。这类操作满足ACID，在操作完成之前，不会向外界提交结果。</li>
<li>实操作。这类操作通常是不可逆转的操作，往往会影响现实世界，比如导弹发射。实操作的特点是不可撤销，因此在执行实操作之前，必须确保所有的关键约束都得到满足。</li>
</ul>


<p>
在系统设计时，对这3类操作也要进行不同的处理。有保护操作可以用来构建分布式系统，无保护操作需要在嵌入高层次的有保护操作，或者由客户控制。对于实操作，必须保证其全部约束条件封装为有保护操作，并在这些有保护操作不需要回滚时才能执行。当系统从崩溃中恢复时，实操作也要特别对待。实操作通常不是幂等的，但一些实操作是可测试的。对于这样的实操作，可以封装到事务环境中。而那些非幂等又不可测试的实操作，目前还没有很好的处理方法。
</p>
</div>
</div>



<div id="outline-container-org3aad035" class="outline-3">
<h3 id="org3aad035">扁平事务</h3>
<div class="outline-text-3" id="text-org3aad035">
<p>
我们回顾一下事务的ACID特性。首先是原子性。原子性要求状态的变化是原子的，外界不会看到中间状态。一致性要求状态的改变是正确的，没有破坏模型的约束。隔离性要求事务的执行不会相互干扰，而持久性保证事务结果是可靠的。满足这些特性的最简单的事务叫做扁平事务。扁平事务的控制结构只有一层，由begin_work()和commit_work()包围的语句位于同一层次。扁平事务有三种结果：成功提交、应用程序主动要求终止，和因为外界原因终止（如超时或资源不足）。
扁平事务可以很好的控制简单的状态转换，而对需要部分回滚，或大量更新的场景则支持不足。不过，基于扁平事务，我们可以构造出支持上述两个场景的事务。
</p>
</div>
</div>

<div id="outline-container-orgbc3ec57" class="outline-3">
<h3 id="orgbc3ec57">控制区域</h3>
<div class="outline-text-3" id="text-orgbc3ec57">
<p>
控制区域（SoC）是为了管理分布式、多用户环境下的计算而发展出来的一个概念。它的主要思想有两点：
</p>
<ul class="org-ul">
<li>获取可撤销操作的结果。</li>
<li>监测操作之间的依赖关系，以便在某处发现错误数据时，可以追踪执行历史记录。</li>
</ul>
<p>
我们以一个现实生活中常见的例子来介绍控制区域。Jim想购买Andy的房子，Andy也愿意出售。由于他们是初次见面，还没有建立信任，Jim想先拿到房屋所有权证书，而Andy想先收到钱。于是他们找打中介，将钱和所有权证书托管到中介。如果交易成功，Andy得到钱，Jim拿到所有权证书。如果交易失败，Jim拿回自己的钱，Andy也不会损失所有权证书。在这里例子里，Andy、Jim和中介都是控制区域。中介的层次比Andy和Jim更高，是一个为了完成交易而建立的动态控制区域。
</p>
</div>
</div>

<div id="outline-container-org42f1d0b" class="outline-3">
<h3 id="org42f1d0b">使用符号表示事务模型</h3>
<div class="outline-text-3" id="text-org42f1d0b">
<p>
扁平事务可以用一个简单的状态机来描述：
</p>
<blockquote>
<p>
状态1. 空。
</p>

<p>
^ begin_work() -&gt; 活动。
</p>

<p>
状态2. 活动。
</p>

<p>
^ commit_work() -&gt; 提交。
</p>

<p>
^ rollback_work() -&gt; 中止。
</p>

<p>
状态3. 提交。
</p>

<p>
^ 终止 -&gt; 空。
</p>

<p>
状态4. 中止。
</p>

<p>
^ 终止 -&gt; 空。
</p>
</blockquote>
<p>
但是对于控制结构较为复杂的事务，状态机会变得非常复杂。下面我们采用控制区域的模型，将扁平事务作为基本的构造块。在控制区域模型中，原子操作之间的依赖有两类：
</p>
<ul class="org-ul">
<li>结构依赖。系统静态的层次结构。</li>
<li>动态依赖。由于使用了共享数据而产生的依赖。这种依赖不反应系统结构。</li>
</ul>

<p>
一个操作是按照某种依赖组织起来的一组原子操作。考察事务模型就需要了解操作结果是如何相互影响的。这里的规则可以分为主动部分和被动部分：
</p>
<ul class="org-ul">
<li>主动部分。有三种事件可以引起原子操作的状态变更，即begin_work()、rollback_work()和commit_work()。事务模型可以定义触发这些事件的条件。</li>
<li>被动部分。一个操作的本地提交，从全局上看，未必是充分的。如果它依赖的某个原子操作回滚，这个操作也需要回滚。</li>
</ul>

<p>
不同的规则集就产生了不同的事务模型。这里特别说明一下系统事务。这时一个“永久”的事务，只要系统启动，它就处于活动状态。系统事务不会提交。如果系统崩溃重启，系统事务中止，并触发其他事务的rollback_work()信号，要求其他事务回滚。
</p>


<p>
下面我们介绍一组描述事务模型的符号。我们用T表示原子操作的标识符。S表示信号，即要激发的规则的名字。S<sub>B</sub>(T)、S<sub>A</sub>(T)和S<sub>C</sub>(T)分别是begin_work()、rollback_work()和commit_work()的规则。A(T)表示原子操作T的中止状态，C(T)表示提交状态。规则的结构如下：
</p>
<div class="org-src-container">
<pre class="src src-text">&lt;rule identifier&gt;:&lt;preconditions&gt; -&gt; &lt;rule modifier list&gt;,&lt;signal list&gt;,&lt;state transition&gt;
</pre>
</div>

<p>
rule identifier是规则的标识符，preconditions是前置条件，rule modifier list是规则产生的行为序列，signal list则是引发的信号序列，state transition是目标状态。rule modifier可以有下面3中形式：
</p>
<ul class="org-ul">
<li>建立动态依赖：</li>
</ul>
<div class="org-src-container">
<pre class="src src-text">&lt;rule modifier&gt; ::= +(&lt;rule identifier&gt; | &lt;signal&gt;)
</pre>
</div>

<ul class="org-ul">
<li>移除动态依赖：</li>
</ul>
<div class="org-src-container">
<pre class="src src-text">&lt;rule modifier&gt; ::= -(&lt;rule identifier&gt; | &lt;signal&gt;)
</pre>
</div>

<ul class="org-ul">
<li>移除X规则和全部引用：</li>
</ul>
<div class="org-src-container">
<pre class="src src-text">&lt;rule modifier&gt; ::= delete(X)
</pre>
</div>

<p>
我们用这组符号来描述事务模型。首先是扁平事务，扁平事务的模型非常简单：
</p>
<blockquote>
<p>
S<sub>B</sub>(T): -&gt; +(S<sub>A</sub>(system) | S<sub>A</sub>(T)), , BEGIN WORK
</p>

<p>
S<sub>A</sub>(T): -&gt; (delete(S<sub>B</sub>(T)), delete(S<sub>C</sub>(T))), , ROLLBACK WORK
</p>

<p>
S<sub>C</sub>(T): -&gt; (delete(S<sub>B</sub>(T)), delete(S<sub>C</sub>(T))), , COMMIT WORK
</p>
</blockquote>
</div>
</div>


<div id="outline-container-orgcb7b38c" class="outline-3">
<h3 id="orgcb7b38c">带保存点的扁平事务</h3>
<div class="outline-text-3" id="text-orgcb7b38c">
<p>
保存点可以支持部分回滚的特性，这在旅行计划一类的业务中非常常见。保存点通过函数save_work()建立，系统记录当前状态，并返回一个句柄给应用程序。通常句柄是一个单调递增的数字。在带保存点的扁平事务中，在执行rollback_work()时，如果传入句柄，可会回滚到保存点。我们首先考察第一个保存点的建立。在这里，我们用S<sub>1</sub>表示事务本身，用R表示要回滚的目标：
</p>

<blockquote>
<p>
S<sub>B</sub>(S<sub>1</sub>): -&gt; +(S<sub>A</sub>(system) | S<sub>A</sub>(S<sub>1</sub>)), , BEGIN WORK
</p>

<p>
S<sub>A</sub>(R): (R &lt; S<sub>1</sub>) -&gt; , , ROLLBACK WORK
</p>

<p>
S<sub>C</sub>(S<sub>1</sub>): -&gt; , , COMMIT WORK
</p>

<p>
S<sub>S</sub>(S<sub>1</sub>): -&gt; +(S<sub>A</sub>(S<sub>1</sub>) | S<sub>A</sub>(S<sub>2</sub>)), S<sub>B</sub>(S<sub>2</sub>), 
</p>
</blockquote>
<p>
这里引入了一个新规则S<sub>S</sub>，它描述了在遇到保存点时要做的工作。有了这个模型，我们就可以采用递推的方式，完成带保存点的扁平事务模型的构造。
</p>
<blockquote>
<p>
S<sub>B</sub>(S<sub>n</sub>): -&gt; , , BEGIN WORK
</p>

<p>
S<sub>A</sub>(R): (R &lt; S<sub>n</sub>) -&gt; , S<sub>A</sub>(S<sub>n-1</sub>), ROLLBACK WORK
</p>

<p>
S<sub>C</sub>(S<sub>n</sub>): -&gt; , S<sub>C</sub>(S<sub>n-1</sub>, COMMIT WORK
</p>

<p>
S<sub>S</sub>(S<sub>n</sub>): -&gt; +(S<sub>A</sub>(S<sub>n</sub>) | S<sub>A</sub>(S<sub>n+1</sub>)), S<sub>B</sub>(S<sub>n+1</sub>), 
</p>
</blockquote>

<p>
这里，S<sub>n</sub>是由S<sub>n+1</sub>生成的保存点。
</p>



<p>
从这个模型可以看到，当系统从崩溃中恢复时，沿着中止信号传递链，所有保存点都被取消。能不能让保存点具有持久特性呢？当系统恢复时，最后一个未完成的保存点回退，其余保存点的状态被重建。这种事务叫做长生事务（phoenix transaction）。它主要障碍在于编程语言：其内部状态（比如局部变量）无法一同恢复到建立保存点的时刻。只有在程序没有内部状态时，长生事务才能够被支持。
</p>
</div>
</div>

<div id="outline-container-org97f7fe7" class="outline-3">
<h3 id="org97f7fe7">链事务</h3>
<div class="outline-text-3" id="text-org97f7fe7">
<p>
链事务是保存点模式的变种，链事务由应用程序负责维护状态和提交工作。不能简单的把链事务当做一组依次执行的扁平事务。在上一个扁平事务提交之后，下一个扁平事务提交之前，可能有其他事务改变了共享状态。链事务可以阻止这种情况发生。链事务提供了一个命令CHAIN WORK，从逻辑上看，它可以理解为COMMIT WORK和BEGIN WORK的组合。
</p>

<blockquote>
<p>
S<sub>B</sub>(C<sub>n</sub>): -&gt; +(S<sub>A</sub>(system) | S<sub>A</sub>(C<sub>n</sub>)), , BEGIN WORK
</p>

<p>
S<sub>A</sub>(C<sub>n</sub>): -&gt; , , ROLLBACK WORK
</p>

<p>
S<sub>C</sub>(S<sub>n</sub>): -&gt; , S<sub>B</sub>(C<sub>n+1</sub>), COMMIT WORK
</p>
</blockquote>


<p>
如果我们把链中的一个事务和保存点进行比较，会发现：
</p>
<ul class="org-ul">
<li>工作流结构。链事务和保存点都允许在长期运行（long-running）的程序中使用子结构。</li>
<li>提交和回滚。链中的每个步骤都是的事务，只能回滚当前事务。保存点的回滚更灵活。</li>
<li>锁。链事务在一个步骤commit之后，可以释放不再需要的锁。</li>
<li>恢复。链事务可以重建最近一次的提交状态，丢失的工作较少。但应用程序必须保证CHAIN WORK没有使用不能重建状态的局部变量。</li>
</ul>
</div>
</div>

<div id="outline-container-org2c0fbe2" class="outline-3">
<h3 id="org2c0fbe2">嵌套事务</h3>
<div class="outline-text-3" id="text-org2c0fbe2">
<p>
嵌套事务是保存点的一般化。嵌套事务是由若干个事务组成的书，叶子节点是扁平事务，非叶子节点可以是扁平事务或嵌套事务。根节点事务叫做顶层事务，其余的事务是它的子事务。按照树中节点的关系，可以在嵌套事务中建立父事务和子事务的概念。子事务可以提交或回滚，但只有父事务提交后，子事务的提交才能生效。考虑到一个子事务的回滚会导致其他已提交子事务的回滚，在嵌套事务中，子事务不具有持久性，而原子性、一致性、隔离性仍然得到满足。
</p>


<p>
嵌套事务的规则有三点：
</p>
<ul class="org-ul">
<li>提交规则。子事务的（本地）提交提交只对父事务开放。只有当顶层事务提交后，子事务才能最终提交。</li>
<li>回滚规则。如果一个子事务回滚，它的全部子事务也必须回滚，无论它们是否进行过本地提交。</li>
<li>可见规则。子事务完成本地提交后，它的结果对父事务和父事务拥有的对象是可见的，对兄弟事务是不可见的。兄弟事务是并行的。</li>
</ul>


<p>
嵌套事务的规则如下：
</p>
<blockquote>
<p>
S<sub>B</sub>(T<sub>kn</sub>): -&gt; +(S<sub>A</sub>(T<sub>k</sub>) | S<sub>A</sub>(T<sub>kn</sub>)), , BEGIN WORK
</p>

<p>
S<sub>A</sub>(T<sub>kn</sub>): -&gt; , , ROLLBACK WORK
</p>

<p>
S<sub>C</sub>(T<sub>kn</sub>): C(T<sub>k</sub>) -&gt; , , COMMIT WORK
</p>
</blockquote>
<p>
在这里，T<sub>kn</sub>是T<sub>k</sub>的一个子事务。
</p>


<p>
在子事务本地提交后，它完成了自己的工作，不再需要封锁对象。由于在最终提交之前，本地提交结果不能对外部开放，为了避免其他事务影响对象，对象仍然需要被封锁。这时，锁会移交给父事务维护。这个过程叫做反向继承（counter-inherite）。如果系统不支持嵌套事务，可以通过保存点的方式来模拟，但是对资源控制的粒度比较粗。
</p>
</div>
</div>


<div id="outline-container-org8e48006" class="outline-3">
<h3 id="org8e48006">分布事务</h3>
<div class="outline-text-3" id="text-org8e48006">
<p>
如果一个事务需要根据数据的位置访问网络中不同节点，这个事务就是分布事务。分布事务通常是扁平事务，它和嵌套事务的不同在于，嵌套事务体现了应用程序的行为结构，而分布事务体现了数据物理位置结构。假设事务T运行在节点A上，它需要对X和Y两个表做连接。X是本地可达的，Y分布在节点B和节点C，这导致T的两个子事务T1和T2分布到了节点B和C上。这种调用结构（invocation structure）和嵌套事务相似，但是这种分解是基于数据位置的，它们仍然位于同一控制层次中。
</p>
</div>
</div>

<div id="outline-container-org6a43903" class="outline-3">
<h3 id="org6a43903">多级别事务</h3>
<div class="outline-text-3" id="text-org6a43903">
<p>
在嵌套事务中，如果允许子事务不等待父事务，自己进行最终提交，这种模式就是多级别事务。为了保证整体的一致性，多级别事务必须为每个子事务提供补偿事务，补偿事务可以从语义上撤销子事务的影响。
</p>


<p>
假设N是T的子事务，CN是N的补偿事务，事务N的规则如下：
</p>
<blockquote>
<p>
S<sub>B</sub>(N): -&gt; , , BEGIN WORK
</p>

<p>
S<sub>A</sub>(N): -&gt; , , ROLLBACK WORK
</p>

<p>
S<sub>C</sub>(N): -&gt; +(S<sub>A</sub>(T) | S<sub>B</sub>(CN)), , COMMIT WORK
</p>
</blockquote>

<p>
一旦CN执行，必须保证它能够提交成功，即使在系统奔溃的情况下。为此我们引入CN的一个实例CN‘，它和CN运行同样的代码，只是名字不同。
</p>
<blockquote>
<p>

</p>

<p>
S<sub>B</sub>(CN): -&gt; +(S<sub>C</sub>(restart) | S<sub>B</sub>(CN')), BEGIN WORK
</p>

<p>
S<sub>A</sub>(CN): -&gt; , S<sub>B</sub>(CN'), ROLLBACK WORK
</p>

<p>
S<sub>C</sub>(CN): -&gt; delete(CN'), , COMMIT WORK
</p>
</blockquote>

<p>
多层次事务和嵌套事务的最大区别在于，多层次事务中的对象可以具有层次结构，比如数据库使用的对象通常包括磁盘页和SQL元组，这些对象是位于不同的层次结构中。因此多层次事务需要规范抽象数据类型的层次结构：
</p>
<ul class="org-ul">
<li>抽象层次。系统由对象和对象所支持的操作组成，对象有严格的层次。</li>
<li>分层抽象。层次n上的对象由层次n-1上的操作实现。</li>
<li>法则。层次n不能访问层次n-1以外的对象。</li>
</ul>
</div>
</div>

<div id="outline-container-org28b9221" class="outline-3">
<h3 id="org28b9221">长事务</h3>
<div class="outline-text-3" id="text-org28b9221">
<p>
前面提到的事务模型都没有考虑数据量的因素。考虑银行需要更新100万条账目，使用扁平事务就可以完成。但是如果中途失败，重新执行的代价没有人愿意承受。我们可以把这个事务做成链事务，这样可以避免工作结果丢失。但是链事务无法从整体上保证ACID特性，如果事务中修改了全局对象，链事务在恢复时，难以重建这个状态。为了处理长事务，我们必须使用新的模型。首先要引入事务处理上下文（context）的概念。考虑下面的简单事务处理程序。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #0000ff;">simple_program</span>() {
    begin_work();
    read(input_message);
    <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#22312;&#36755;&#20837;&#30340;&#28040;&#24687;&#19978;&#23436;&#25104;&#35745;&#31639; */</span>
    send(output_message);
    commit_work();
}
</pre>
</div>

<p>
这个程序可以看成是一个函数f：
</p>
<blockquote>
<p>
f(input_message) -&gt; output_message
</p>
</blockquote>

<p>
我们再考虑下面的SQL语句：
</p>
<div class="org-src-container">
<pre class="src src-text">exec_sql("DECLARE CURSOR c AS
          SELECT a,b,c
          FROM rel_a
          WHERE d=10
          ORDER BY a ASCENDING;");
exec_sql("OPEN CURSOR c;");
do {
    int a, b, c;
    exec_sql("FETCH NEXT c INTO :a, :b, :c");
    /* &#23436;&#25104;&#35745;&#31639; */
} while (SQLCODE == 0);
exec_sql("CLOSE CURSOR c;");
</pre>
</div>

<p>
这个程序要完成计算所依赖的，除了输入的消息之外，还有游标。同时，计算本身也会改变游标的值。像游标这样的信息我们叫做上下文，这个程序可以看成是函数
</p>
<blockquote>
<p>
f(input_message, context) -&gt; {output_message, context}
</p>
</blockquote>

<p>
如果上下文是空集合，这个函数就叫做上下文无关的。对于上下文相关的程序，由谁来维护上下文呢？
</p>
<ul class="org-ul">
<li>事务。在上面的SQL例子中，上下文（游标）就是由事务管理的。</li>
<li>程序。程序中最后被提交的事务的信息。</li>
<li>终端。允许使用这个终端的用户列表、由终端唤起的程序列表等等。</li>
<li>用户。用户被确认的密码、用户工作的上一个序号。</li>
</ul>


<p>
现在考虑银行账户处理的问题。我们可以把事务拆分成小批量的方式，并建立一个上下文来帮助事务重启。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string.h&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">stepsize</span> 1000
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">max_account_number</span> 999999

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">compute_interest</span>(interest_rate) {

    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">account_number</span>, <span style="color: #a0522d;">last_account_done</span>, <span style="color: #a0522d;">batch_date</span>;
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">account_total</span>, <span style="color: #a0522d;">interest_rate</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">logsize</span>;

    logsize = 0;
    exec_sql(<span style="color: #8b2252;">"SELECT COUNT(*) INTO :logsize FROM batchcontext"</span>);
    <span style="color: #a020f0;">if</span> (SQLCODE != 0 || logsize == 0) {
        exec_sql(<span style="color: #8b2252;">"BEGIN WORK"</span>);
        exec_sql(<span style="color: #8b2252;">"DROP TABLE batchcontext"</span>);
        exec_sql(<span style="color: #8b2252;">"CREATE TABLE batchcontext (last_account_done INTEGER)"</span>);
        last_account_done = 0;
        exec_sql(<span style="color: #8b2252;">"INSERT INTO batchcontext VALUES(:last_account_done)"</span>);
        exec_sql(<span style="color: #8b2252;">"COMMIT WORK"</span>);
    } <span style="color: #a020f0;">else</span> {
        exec_sql(<span style="color: #8b2252;">"SELECT last_account_done INTO :last_account_done FROM batchcontext"</span>);
    }

    <span style="color: #a020f0;">while</span> (last_account_done &lt; max_account_number) {
        exec_sql(<span style="color: #8b2252;">"BEGIN WORK"</span>);
        exec_sql(<span style="color: #8b2252;">"UPDATE accounts SET account_total = account_total * (1+:interest_rate) WHERE account_number BETWEEN :last_account_done+1 AND :last_account_done + :stepsize"</span>);
        exec_sql(<span style="color: #8b2252;">"UPDATE batchcontext SET last_account_done = last_account_done + :stepsize"</span>);
        exec_sql(<span style="color: #8b2252;">"COMMIT WORK"</span>);
        last_account_done = last_account_done + stepsize;
    }

    exec_sql(<span style="color: #8b2252;">"BEGIN WORK"</span>);
    exec_sql(<span style="color: #8b2252;">"DROP TABLE batchcontext"</span>);
    exec_sql(<span style="color: #8b2252;">"COMMIT WORK"</span>);
}
</pre>
</div>


<p>
长事务的需求可以总结为：
</p>
<ul class="org-ul">
<li>最小化工作丢失。在系统崩溃时可以控制丢失工作的数量。</li>
<li>可恢复计算。工作可以暂时停止，而不是必须回滚。</li>
<li>显示控制流。应用程序必须可以控制事务序列。</li>
</ul>

<p>
为了支持长事务，Garcia-Molina和Salem提供了saga模式。（<a href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf">https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf</a>）
</p>

<p>
在saga模式中，事务由一个列扁平事务s<sub>1</sub>, s<sub>2</sub>, &#x2026;, s<sub>n</sub>构成。每个事务s<sub>i</sub>都有一个对应的补偿事务cs<sub>i</sub>。当事务s<sub>j</sub>中止后，系统依次调用s<sub>j-1</sub>, s<sub>j-2</sub>, &#x2026;, s<sub>1</sub>，将系统恢复到初始状态。
</p>
</div>
</div>
</div>

<div id="outline-container-org8218a93" class="outline-2">
<h2 id="org8218a93">事务处理监控器：概述</h2>
<div class="outline-text-2" id="text-org8218a93">
<p>
计算机系统处理任务的典型方式主要有：批处理、分时处理、实时处理、客户-服务器处理、面向事务处理等。批处理的目标是尽可能提高吞吐量。批处理以大批量的方式顺序执行作业。当发生错误时，由应用程序负责恢复。批处理的资源使用量是可预测的，资源分配粒度较粗，并发较低（通常为数十个）。分时处理是为了应对多终端的情况设计的。分时处理可以支持数以百计的终端，这些终端和主机以低带宽（哑终端）的线路连接。主机为每个终端分配一个进程，用来调用系统服务。在分时处理系统中，作业由用户控制，因此服务请求是随机到达的，资源使用难以预测。由于终端会话往往持续时间较长，分时处理也采用粗粒度的资源分配。当发生错误时，同样由应用程序负责恢复。实时系统除了接收操作员的指令，还会接收传感器数据，向控制器发出指令。实时系统必须具有高可用性和高效性，对于优先级高的事件，必须在固定的时间限制内做出可靠的行为。实时处理系统是由事件（传感器中断）驱动的，工作负载模式难以预测。客户-服务器处理由分时处理发展而来，用户通过向指定的服务器程序发送请求来执行相应服务。执行请求的服务可以运行在同一台机器，或网络中不同机器的进程中。和分时处理不同的是，服务器包含了预先定义好的特定服务程序，同时，永久性的数据由数据库服务器封装保存。面向事务处理的特点是：
</p>
<ul class="org-ul">
<li>共享性。多用户共享数据库。</li>
<li>工作负载随机。</li>
<li>多终端。</li>
<li>支持智能客户机。和哑终端不同，这些智能客户机拥有自己的数据和处理逻辑。</li>
<li>高可用。</li>
<li>系统负责恢复。</li>
</ul>

<p>
在事务处理系统中，影响事务调度和执行方式的因素有调度、输入/输出、资源管理器分配。按照这些因素，可以将事务分为8类：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">事务类型</td>
<td class="org-left">调度</td>
<td class="org-left">输入/输出</td>
<td class="org-left">资源管理器分配</td>
</tr>

<tr>
<td class="org-left">直接OLTP事务</td>
<td class="org-left">直接</td>
<td class="org-left">单消息</td>
<td class="org-left">本地</td>
</tr>

<tr>
<td class="org-left">直接OLTP事务（分布式）</td>
<td class="org-left">直接</td>
<td class="org-left">单消息</td>
<td class="org-left">分布式</td>
</tr>

<tr>
<td class="org-left">复杂联机事务</td>
<td class="org-left">直接</td>
<td class="org-left">会话</td>
<td class="org-left">本地</td>
</tr>

<tr>
<td class="org-left">复杂联机事务（分布式）</td>
<td class="org-left">直接</td>
<td class="org-left">会话</td>
<td class="org-left">分布式</td>
</tr>

<tr>
<td class="org-left">队列OLTP事务</td>
<td class="org-left">队列</td>
<td class="org-left">短</td>
<td class="org-left">本地</td>
</tr>

<tr>
<td class="org-left">队列OLTP事务（分布式）</td>
<td class="org-left">队列</td>
<td class="org-left">短</td>
<td class="org-left">分布式</td>
</tr>

<tr>
<td class="org-left">长的批处理事务</td>
<td class="org-left">队列</td>
<td class="org-left">长</td>
<td class="org-left">本地</td>
</tr>

<tr>
<td class="org-left">长的批处理事务（分布式）</td>
<td class="org-left">队列</td>
<td class="org-left">长</td>
<td class="org-left">分布式</td>
</tr>
</tbody>
</table>

<p>
按照请求调度方式，事务可以分为直接事务和队列事务。直接事务是用户和服务器程序直接交互的事务。队列事务则将请求放入请求队列，按照一定规则调度执行。注意队列本身的操作也要满足ACID特性。按照涉及对象的数量，又可以分为简单事务和复杂事务。简单事务代码长度较短，仅涉及几个对象。复杂事务具有复杂的内部结构，并涉及大量对象。复杂事务在系统中停留的时间较长。如果事务在网络的不同节点上执行，这个事务就叫做分布式事务，反之叫做本地事务。
</p>
</div>

<div id="outline-container-orgeb0f664" class="outline-3">
<h3 id="orgeb0f664">事务处理服务</h3>
<div class="outline-text-3" id="text-orgeb0f664">
<p>
事务处理服务的职责有：
</p>
<ul class="org-ul">
<li>管理异质资源。事务服务必须将自治对象上的全部操作包含到一个事务，这个组件叫做资源管理器（RM）。资源管理器通过TP监控器集成到全局事务中。</li>
<li>通信控制。通信状态必须受到事务的控制，这种机制称为事务型远程过程调用（TRPC）。</li>
<li>终端管理。TP监控器需要处理如下的问题：一个响应消息在传送时发生故障，如何确认该消息是否被传递给用户？</li>
<li>表示服务。如果用户使用复杂的表示服务，如X-Windows，工作站崩溃后，事务需要重建窗口环境。</li>
<li>上下文管理。一个事务执行后，下一个功能请求往往需要前驱事务的上下文（如已认证的用户编号）。TP监控器需要维护这些上下文。</li>
<li>开始/重启动。</li>
</ul>

<p>
考虑下面的场景：用户通过终端在服务器上执行一些功能，这些功能需要存取或操作数据库中的某些数据。必须有某个东西将这些组件联系起来。我们用事务程序名（Transaction Program Name，TPN）或事务代码（Transaction Code，TAC）表示实现服务的一段代码。在运行时，有一个由TP监控器维护的服务器类（server class），服务器类是一组进程，每个进程执行相同的代码，叫做服务器（进程）。请求被分派给正确的服务器进程。请求和进程的关系就决定了事务处理系统的进程结构。
</p>
<ul class="org-ul">
<li>每个终端一个进程结构。系统为每个终端分配一个服务器进程来处理会话，所有应用链接在一起形成一个应用程序。这种结构通常为分时系统所采用，对于面向事务的系统不是很友好。首先是进程数量多。面向事务的系统通常有1万到10万个终端，但是操作系统通常无法支持这么多的进程。而且每个进程都需要访问文件，由此产生的控制块数量将超过系统可以管理的范围。第三进程数量过多会引发频繁的进程切换，消耗大量内存和CPU。第四，每个终端一个进程的结构在处理负载均衡时不够灵活。因此，这种结构通常只适合用户数小于100的中小型系统。</li>
<li>只有一个终端进程。这个进程通常是TP监控器。这需要将全部应用链接到一个地址空间，无法提供容错和隔离，负载均衡也变得困难。同时TP监控器必须支持所有终端使用的协议。</li>
<li>多服务器单调度程序。在系统中有一个进程负责管理终端、处理请求及应答消息、提供表示服务。而应用则由多个进程执行。这个结构可以进行调度和负载控制，但是在高负载时，服务进程将成为瓶颈。</li>
<li>多服务器多调度程序。这种结构具有多个表示服务进程。</li>
</ul>


<p>
TP监控器提供的基本功能有：
</p>
<ul class="org-ul">
<li>调度。将客户发送的请求映射到服务器程序。</li>
<li>服务器类管理。启动服务器类，进行负载均衡。</li>
<li>认证和授权。用户不是登录到操作系统，而是注册到TP监控器。</li>
<li>资源管理。管理终端、数据库、应用程序、用户和其他组件。</li>
<li>系统操作。</li>
<li>恢复。在系统崩溃后重建事务环境。</li>
</ul>


<p>
TP监控器的包含下列组件：
</p>
<ul class="org-ul">
<li>表示服务。定义应用程序和要交互设备之间的接口。</li>
<li>队列管理。将请求加入队列并传递给服务器。根据应用的要求，请求有三种级别的保证；至少一次、至多一次和只能一次。</li>
<li>服务器类管理。保证对每个应用，都有一个服务器类被建立并处于激活状态。</li>
<li>请求调度。找到服务器位置，并将请求转发给服务器。如果需要，TP监控器会使用RPC或在本地建立服务器进程。</li>
<li>授权请求。TP监控器需要根据应用要求来检查请求的合法性。授权策略可以是简单的静态授权或动态授权。</li>
<li>上下文管理。一是保存处理上下文，这种上下文可以跨越事务边界，并在后续事务中访问。二是维护当前事务上下文，将事务调用的多个资源管理器的结果保存在一起。</li>
</ul>

<p>
同时，TP监控器还需要维护下列信息：
</p>
<ul class="org-ul">
<li>分布式事务系统涉及的节点信息，如名称、地址等。</li>
<li>事务处理器的本地组件，如日志管理程序、事务管理器和通信管理器。</li>
<li>TP监控系统必须了解的硬件部分。</li>
<li>本地节点上安装的事务程序和资源管理器。</li>
<li>应用程序和资源管理器有关的访问控制列表。</li>
<li>应用程序有关的屏幕格式定义。</li>
<li>服务器类配置数据（进程数、线程数、优先级）。</li>
<li>与操作系统、授权码、安全配置文件和其他安全相关的数据。</li>
<li>操作者界面配置。</li>
<li>重启配置和过程（资源管理器调用的顺序）。</li>
</ul>


<p>
现在我们从资源管理器的例子来观察TP监控器的角色。资源管理器是捆绑在TP监控器中的一个子系统，用来提供针对底层资源的有保护操作。从概念上看，资源管理器可以分为三类：第一类包含系统组件，用来管理系统本身，如目录和表示服务。第二类是实现事务的基本组件，用来保证事务的ACID特性，如事务管理器、日志管理器和通信管理器。第三类包含被应用使用的，以及支持事务范例的子系统实现的对象，如文件系统、SQL数据库、排队系统、X客户端等。
</p>


<p>
资源管理器之间的相互影响可以用下面的例子来描述，这是一个简单是事务程序：
</p>
<div class="org-src-container">
<pre class="src src-text">BEGIN WORK
receive (input message);
&lt;some SQL&gt;
send (statistics menu) to (window w1);
COMMIT WORK;
</pre>
</div>
<p>
这里的window w1是来自上下文的默认窗口。终端通过网络把请求传递过来，TP监控器把请求放入队列，然后调度相应的事务程序，让事务程序在一个服务器进程中执行。应用首先发出BEGIN WORK命令，向事务管理器登记，并得到一个事务标识符（TRID）。UPDATE命令产生了对资源管理器DB2的调用。DB2使用（本地或全局）日志管理器记录TRID和UNDO、REDO操作，然后返回到应用程序。应用程序的笑一个调用会发往另一个资源管理器，可能是一个X窗口。COMMIT WORK命令发往事务管理器，事务管理器也知道了哪些资源管理器参与了事务。
</p>


<p>
一旦事务开始，TP监控器不再需要进行事务管理工作，资源管理器之间的协调由事务管理器完成。事务管理器的目的是让资源管理器在必要时能够正确的恢复。对于本地配置的资源管理器，TP监控器承担以下职责：
</p>
<ul class="org-ul">
<li>启动和初始化。TP监控器唤醒资源管理器，然后让事务管理器负责处理崩溃后的恢复协议。</li>
<li>新资源管理器的定义。新的资源管理器需要显式的安装，TP监控器将资源管理器的信息写入数据库，以便在TP监控器启动时唤醒资源管理器。</li>
<li>改变进程配置。在进行负载均衡时，TP监控器需要调整服务器类，创建新进程，或者将进程绑定到合适的地址空间。</li>
<li>处理事务型远程过程调用。这是TP监控器的基本任务，TP系统中的各个组件通过服务请求交互。</li>
</ul>


<p>
在进行远程过程调用时，有两种方式可以找到资源管理器：通过全局唯一的名字RMNAME，或者通过本地唯一的编号RMID。调用会连到RPC存根（stub）上。如果访问的资源管理器不在本地，存根会从网络中找到它，并转发请求。
</p>


<p>
从服务器的角度来看，典型的事务型应用程序处理逻辑如下：
</p>
<ul class="org-ul">
<li>接收请求</li>
<li>BEGIN WORK</li>
<li>寻找处理上下文</li>
<li>处理请求，调用其他资源管理器</li>
<li>如果遇到问题，ROLLBACK WORK</li>
<li>保存上下文</li>
<li>返回响应</li>
<li>COMMIT WORK</li>
</ul>

<p>
下面是一个简单的例子，这个程序完全忽略事务：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">bool</span> <span style="color: #0000ff;">ignorant_server</span>(<span style="color: #228b22;">RmParams</span> *<span style="color: #a0522d;">InParams</span>, <span style="color: #228b22;">RmParams</span> *<span style="color: #a0522d;">OutResults</span>) {
    work_on_input_parameters();
    comp_code = RmCall(<span style="color: #8b2252;">"HelpMe"</span>, ...);
    prepare_output_parameters();
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}
</pre>
</div>

<p>
下面是一个稍微复杂的例子：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Context</span> {
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">length</span>;
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">data</span>[length];
};

<span style="color: #228b22;">TRID</span> <span style="color: #0000ff;">begin_work</span>(attributes, context);
<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">commit_work</span>(<span style="color: #228b22;">bool</span> <span style="color: #a0522d;">lazy</span>, context);
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">abort_work</span>();
<span style="color: #228b22;">TRID</span> <span style="color: #0000ff;">my_trid</span>();

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">simple_server</span>(<span style="color: #228b22;">RmParams</span> *<span style="color: #a0522d;">InParams</span>, <span style="color: #228b22;">RmParams</span> *<span style="color: #a0522d;">OutResults</span>) {
    <span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">new_trid</span>;
    <span style="color: #228b22;">RETCODE</span> <span style="color: #a0522d;">comp_code</span>;

    <span style="color: #a020f0;">if</span> (my_trid() != NULLTRID) {
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
    }

    new_trid = begin_work(...);
    do_work();
    comp_code = RmCall(<span style="color: #8b2252;">"HelpMe"</span>, ...);
    <span style="color: #a020f0;">if</span> (comp_code == BAD) {
        abort_work();
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
    }

    do_more_work();
    <span style="color: #a020f0;">if</span> (result_ok) {
        prepare_output_parameters();
        <span style="color: #228b22;">commit_work</span>(...);
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
    }

    abort_work();
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
}
</pre>
</div>

<p>
资源管理器中有一类叫做谨慎性资源管理器（cautious resource manager），它充分利用保存点和上下文，可以实现按步骤恢复。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">savepoint</span> <span style="color: #0000ff;">save_work</span>(<span style="color: #228b22;">bool</span> <span style="color: #a0522d;">persistent</span>, context);
<span style="color: #228b22;">savepoint</span> <span style="color: #0000ff;">rollback_work</span>(<span style="color: #228b22;">savepoint</span>);
<span style="color: #228b22;">context</span> <span style="color: #0000ff;">read_context</span>(<span style="color: #228b22;">savepoint</span>);
<span style="color: #228b22;">TRID</span> <span style="color: #0000ff;">chain_work</span>(<span style="color: #228b22;">bool</span> <span style="color: #a0522d;">persistent</span>, <span style="color: #228b22;">context</span>);

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">cautious_server</span>(<span style="color: #228b22;">RmParams</span> *<span style="color: #a0522d;">InParams</span>, <span style="color: #228b22;">RmParams</span> *<span style="color: #a0522d;">OutResults</span>) {
    <span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">new_trid</span>;
    <span style="color: #228b22;">savepoint</span> <span style="color: #a0522d;">last_ok_state</span>;
    <span style="color: #228b22;">context</span> <span style="color: #a0522d;">trusted_data</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">steps_p_savepoint</span>;
    <span style="color: #228b22;">RETCODE</span> <span style="color: #a0522d;">comp_code</span>;

    initialize_trusted_data();
    new_trid = begin_work(..., trusted_data, <span style="color: #008b8b;">false</span>);
    last_ok_state = 1;
    <span style="color: #a020f0;">while</span> (more_work) {
        <span style="color: #a020f0;">for</span> (i = 1; i &lt;= steps_p_savepoint; i++) {
            do_work();
            comp_code = RmCall(<span style="color: #8b2252;">"HelpMe"</span>, ...);
            do_more_work();
            <span style="color: #a020f0;">if</span> (error_occurs) {
                last_ok_state = rollback_work(last_ok_state);
                trusted_data = read_context(last_ok_state);
                reset_local_variables_from_trusted_data();
                i = 0;
            }
        }

        save_all_relevant_local_variables_in_trusted_data();
        last_ok_state = save_work(<span style="color: #008b8b;">false</span>, trusted_data);
    }

    <span style="color: #a020f0;">if</span> (result_ok) {
        prepare_output_parameters();
        commit_work();
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
    }

    abort_work();
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
}
</pre>
</div>

<p>
实现资源管理器的模块有指派服务的入口点和回调入口点（callback entry point）。比如Rm_savepoint就是指派服务入口点，它在事务要求建立保存点时，记录下资源管理器的上下文信息。类似的，Rm_rollback_savepoint从上下文中重建状态。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">bool</span> <span style="color: #0000ff;">rm_rollback_savepoint</span>(<span style="color: #228b22;">savepoint</span> <span style="color: #a0522d;">back_to</span>) {
    trusted_data = read_context(back_to);
    reset_local_variables_from_trusted_data();
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}
</pre>
</div>

<p>
如果一个资源管理器请求save_work()或rollback_work()，所有参与事务的资源管理器都会在合适的入口点得到通知，rm_savepoint()也是这样。
</p>


<p>
下面我们考虑复杂一点的资源管理器SRM。当它运行事务T1时，由于某些原因，T1被临时挂起，SRM开始执行T2。SRM开始操作T2涉及的资源管理器，并且当SRM返回时，控制权返回给T2事务。
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">TRID</span> <span style="color: #0000ff;">leave_transaction</span>();
<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">resume_transaction</span>(<span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">desired</span>);

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">bartlett</span>(<span style="color: #228b22;">RmParams</span> *<span style="color: #a0522d;">InParams</span>, <span style="color: #228b22;">RmParams</span> *<span style="color: #a0522d;">OutResults</span>) {
    <span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">client_trid</span>;
    <span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">myown_trid</span>;

    client_trid = leave_transaction();  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31163;&#24320;T1&#12290;</span>
    myown_trid = begin_work(...);
    do_database_lookup();
    prepare_reference_list();
    write_billing_record_to_database();
    commit_work(<span style="color: #008b8b;">false</span>, <span style="color: #008b8b;">nullptr</span>);
    resume_transaction(client_trid);

    <span style="color: #a020f0;">return</span>;
}
</pre>
</div>

<p>
下面是一个带有持久上下文的例子：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string.h&gt;</span>

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">stepsize</span> 1000
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">max_account_no</span> 999999

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">compute_interest</span>(interest_rate) {
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">account_no</span>, <span style="color: #a0522d;">last_account_done</span>, <span style="color: #a0522d;">batch_date</span>;
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">account_total</span>, <span style="color: #a0522d;">interest_rate</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">logsize</span>;
    <span style="color: #228b22;">savepoint</span> <span style="color: #a0522d;">here_we_are</span>;
    <span style="color: #228b22;">context</span> <span style="color: #a0522d;">finished_account</span>;

    last_account_done = 0;
    store_last_account_done_in_finished_account();
    begin_work(finished_account, <span style="color: #008b8b;">true</span>);
    <span style="color: #a020f0;">while</span> (last_account_done &lt; max_account_no) {
        exec_sql(<span style="color: #8b2252;">"UPATE accounts SET account_total=account_total * (1 + :interest_rate) WHERE account_no BETWEEN :last_account_done + 1 AND :last_account_done + :stepsize"</span>);
        last_account_done = last_account_done + stepsize;
        store_last_account_done_in_finished_account();
        here_we_are = save_work(finished_account, <span style="color: #008b8b;">true</span>);
    }

    commit_work();
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org2f343ea" class="outline-2">
<h2 id="org2f343ea">事务处理监控器</h2>
<div class="outline-text-2" id="text-org2f343ea">
<p>
事务处理操作系统（Transaction Processing Operating System，TPOS）运行在基本操作系统（Basic Operating System，BOS）上，以事务的模式管理BOS的对象和服务。事务调用的主要部分有：
</p>
<ul class="org-ul">
<li>参与者控制。为了管理提交和回滚，必须有一个组件记录下调用了哪个资源管理器。同时，这个组件必须知道各资源管理器是否可以正常提交。负责这个工作的组件叫事务管理器（TM）。而资源管理器则不应该记录任何事务信息，所有的信息和结果都通过参数传递。</li>
<li>保留与事务相关的信息。在一个事务中，同一个资源管理器可能被相同或不同的客户多次调用。TRPC必须提供某种机制，将这些调用关联起来。</li>
<li>事务协议支持。资源管理器必须遵循ACID特性所要求的规则。</li>
</ul>


<p>
资源管理器的接口如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">RMNAME</span> = <span style="color: #228b22;">char</span>*; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36164;&#28304;&#31649;&#29702;&#22120;&#21517;&#23383;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">RMInstance</span> {
    <span style="color: #228b22;">Node_id</span> <span style="color: #a0522d;">node_id</span>;       <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36827;&#31243;&#25152;&#22312;&#33410;&#28857;&#30340;&#32534;&#21495;</span>
    <span style="color: #228b22;">Process_id</span> <span style="color: #a0522d;">process_id</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36827;&#31243;&#32534;&#21495;</span>
    <span style="color: #228b22;">Timestamp</span> <span style="color: #a0522d;">birth_date</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26381;&#21153;&#22120;&#24314;&#31435;&#30340;&#26102;&#38388;</span>
};

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">RMParams</span> {
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">cb_length</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25511;&#21046;&#22359;&#38271;&#24230;</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">cb_bytes</span>[cb_length]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25511;&#21046;&#22359;&#25968;&#25454;</span>
};

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">rm_call</span>(<span style="color: #228b22;">RMNAME</span>, <span style="color: #228b22;">Bind_id</span> *<span style="color: #a0522d;">bound_to</span>, <span style="color: #228b22;">RMParams</span> *<span style="color: #a0522d;">in_params</span>, <span style="color: #228b22;">RMParams</span> *<span style="color: #a0522d;">out_results</span>);
</pre>
</div>

<p>
有两种方法来调用资源管理器：
</p>
<ul class="org-ul">
<li>单一入口。服务器只有一个服务入口点（消息缓冲区），在处理一个请求之前，服务器必须判断请求的类型，并找到合适的子程序。</li>
<li>服务入口加回调入口。资源管理器除了服务接口之外，还有一些回调入口点，比如：</li>
</ul>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">bool</span> <span style="color: #0000ff;">rm_prepare</span>();
<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">rm_roolback_savepoint</span>(Save_point);
<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">rm_commit</span>(<span style="color: #228b22;">bool</span>);
<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">rm_save_point</span>();
<span style="color: #228b22;">void</span> <span style="color: #a0522d;">rm_undo</span>(&amp;buffer);
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">rm_abort</span>();
<span style="color: #228b22;">void</span> <span style="color: #a0522d;">rm_redo</span>(&amp;buffer);
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">rm_check_point</span>();
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">rm_restart</span>(LSN);
</pre>
</div>

<p>
资源管理器和事务管理器往往运行在不同的地址空间中，因此事务管理器需要在不知道地址的情况下指向正确的入口点。在重启时，资源管理器通过方法identify()发出通知，告诉事务管理器自己已经准备好进行恢复操作。事务管理器提供必需的数据给资源管理器。当identify()返回后，资源管理器已经得到了最近的一致状态。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">bool</span> <span style="color: #0000ff;">identify</span>(RMID);
</pre>
</div>

<p>
下面是安装和移除资源管理器的函数调用：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">rm_install</span>(RMNAME,             <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20840;&#23616;&#21807;&#19968;&#30340;&#26381;&#21153;&#21517;</span>
                &amp;rm_callbacks[],    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#22238;&#35843;&#20837;&#21475;&#28857;</span>
                AccessControllList, <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25480;&#26435;</span>
                stuff);             <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20854;&#20182;&#20449;&#24687;</span>

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">rm_remove</span>(<span style="color: #228b22;">RMID</span>);
<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">rm_deactivate</span>(<span style="color: #228b22;">RMID</span>);
<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">rm_activate</span>(<span style="color: #228b22;">RMID</span>);

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">rm_startup</span>();  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21551;&#21160;&#21551;&#21160;&#26102;&#35843;&#29992;</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">rm_shutdown</span>(); <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21551;&#21160;&#20851;&#38381;&#26102;&#35843;&#29992;</span>
</pre>
</div>

<p>
TRPC有一个需要考虑的地方，就是上下文。考虑一下，如果一个事务中，客户C重复的调用服务器类S，要如何处理呢？可以分为以下三种情况：
</p>
<ul class="org-ul">
<li>相互独立的调用。服务器类S中的一个服务器可以被任意调用，每个调用的输出是相互独立的。</li>
<li>按顺序调用。客户端的请求和前面的服务请求相关。比如“取后面10条记录”。这种情况通常使用SQL游标来解决。首先调用open_cursor()，它执行SELECT语句并建立上下文。这个过程中会产生一个对SQL服务器的rm_call调用。然后，fetch_cursor()调用返回下一条记录。</li>
<li>复杂的相互作用。这种情况下，服务器类必须记录客户C的所有调用结果，否则无法保证一致性得到满足。</li>
</ul>

<p>
如果客户和服务器协同工作一段时间，并且双方都保存了协同工作的状态信息，就称它们在一个会话中。会话可以避免重复传递大量的状态信息，比如授权、认证和服务上下文。但是会话也使得服务器拥有了状态，因此故障恢复的难度和时间都有所增加。那么在会话和调用之间要如何选择呢？我们考虑下面的四种客户-服务器结构：
</p>
<ul class="org-ul">
<li>上下文由通信会话维护，后续的每个请求都转发到相同的服务器实例。在这种结构中，通信会话由TPOS维护，服务器像一个静态链接的子程序。缺点是TPOS维护和恢复成本的较高。</li>
<li>上下文在客户调用时作为参数传递给服务器。这种结构减轻了TPOS维护会话的压力，由服务器决定需要使用哪些信息，客户存储并传递上下文。</li>
<li>服务器将上下文保存到数据库，每个服务器实例都可以访问。维护会话的责任由服务器承担。</li>
<li>服务器类的所有服务共享一个存储器，上下文记录在这个存储器中。这种结构要求所有服务器运行在同一个节点上。</li>
</ul>


<p>
从服务器的角度来看，上下文可以分为两类，一类是面向客户的，比如用户编号、游标等，另一类是面向事务的，比如为了保证一致性而建立的锁。为了支持故障恢复，面向事务的上下文必须进行持久化。而对于面向用户的上下文，TPOS提供了两种机制：
</p>
<ul class="org-ul">
<li>会话管理。如果上下文通过通信会话维护，在调用期间，TP监控器会把客户绑定到服务器进程上。</li>
<li>进程管理。如果TP监控器不管理上下文，为了负载均衡，它也需要了解每个服务器已经存在的会话数量。</li>
</ul>

<p>
下面的代码使用两个TRPC调用来建立和解除客户与服务器之间的会话：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">RM_instance</span> <span style="color: #a0522d;">end_a</span>;
    <span style="color: #228b22;">RM_instance</span> <span style="color: #a0522d;">end_b</span>;
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">sequence_number</span>;
} <span style="color: #a0522d;">Bind_id</span>;

<span style="color: #228b22;">Bind_id</span> <span style="color: #0000ff;">rm_bind</span>(<span style="color: #228b22;">RM_instance</span>);
<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">rm_unbind</span>(<span style="color: #228b22;">Bind_id</span>);
</pre>
</div>

<p>
考虑用这些函数来处理SQL语句序列
</p>
<div class="org-src-container">
<pre class="src src-text">OPEN CURSOR
  FETCH CURSOR
  FETCH CURSOR
  ...
  FETCH CURSOR
CLOSE CURSOR
</pre>
</div>

<p>
这些SQL语句可能被映射为下面的TRPC序列
</p>

<div class="org-src-container">
<pre class="src src-c++">rm_call(SQL, <span style="color: #008b8b;">NULL</span>, ...);
bind_id = rm_bind(client_rmid);
rm_call(SQL, &amp;bind_id);
rm_call(SQL, &amp;bind_id);
...
rm_unbind(bind_id);
</pre>
</div>

<p>
对每个TRPC，TP监控器根据RMNAME找到RMID，再进一步找到服务器类，选择服务器类中的一个空闲进程来处理请求。如果服务器类中没有空闲进程，TP监控器可以启动一个进程，或者根据负载均衡策略，延迟TRPC请求的执行。
</p>


<p>
为了保证事务的可管理性，最好有一个起始点，从这里可以找到全部的全局数据结构：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">Timestamp</span> = <span style="color: #228b22;">char</span>*;
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Anchor</span> {
    <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">system_name</span>;           <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26412;&#22320;&#31995;&#32479;&#21517;&#23383;</span>
    <span style="color: #228b22;">Timestamp</span> <span style="color: #a0522d;">generate_date</span>;     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31995;&#32479;&#20135;&#29983;&#30340;&#26085;&#26399;</span>
    <span style="color: #228b22;">Timestamp</span> <span style="color: #a0522d;">last_startup_date</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31995;&#32479;&#21551;&#21160;&#26085;&#26399;</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">some_data</span>;              <span style="color: #b22222;">// </span><span style="color: #b22222;">&#19968;&#20123;&#31649;&#29702;&#30456;&#20851;&#30340;&#20449;&#24687;</span>
    <span style="color: #228b22;">TP_anchor</span> *<span style="color: #a0522d;">tp_monitor_cb</span>;    <span style="color: #b22222;">// </span><span style="color: #b22222;">TP&#30417;&#25511;&#22120;&#38170;&#28857;</span>
    <span style="color: #228b22;">TM_anchor</span> *<span style="color: #a0522d;">tm_cb</span>;            <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20107;&#21153;&#31649;&#29702;&#22120;&#38170;&#28857;</span>
    <span style="color: #228b22;">SM_anchor</span> *<span style="color: #a0522d;">sm_cb</span>;            <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20250;&#35805;&#31649;&#29702;&#22120;&#38170;&#28857;</span>
    <span style="color: #228b22;">LM_anchor</span> *<span style="color: #a0522d;">lm_cb</span>;            <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26085;&#24535;&#31649;&#29702;&#22120;&#38170;&#28857;</span>
    <span style="color: #228b22;">IM_anchor</span> *<span style="color: #a0522d;">im_cb</span>;            <span style="color: #b22222;">// </span><span style="color: #b22222;">&#23553;&#38145;&#31649;&#29702;&#22120;&#38170;&#28857;</span>
};
</pre>
</div>

<p>
在上面的例子中，系统中有5个资源管理器，即：TP监控器、事务管理器、日志管理器、封锁管理器和通信管理器。每个资源管理器都有自己的锚点。其中，TP监控器锚点如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">TP_anchor</span> {
    <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">my_version</span>;         <span style="color: #b22222;">// </span><span style="color: #b22222;">TP&#30417;&#25511;&#22120;&#29256;&#26412;</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">repository</span>[64];      <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20013;&#24515;&#24211;&#21517;&#23383;</span>
    <span style="color: #228b22;">handle</span> <span style="color: #a0522d;">repo_handle</span>;       <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20013;&#24515;&#24211;&#35843;&#29992;&#21477;&#26564;</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">context_db</span>;          <span style="color: #b22222;">// </span><span style="color: #b22222;">&#19978;&#19979;&#25991;&#25968;&#25454;&#24211;&#21517;&#31216;</span>
    <span style="color: #228b22;">handle</span> <span style="color: #a0522d;">context_db_handle</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#19978;&#19979;&#25991;&#25968;&#25454;&#24211;&#35843;&#29992;&#21477;&#26564;</span>
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">next_rmid</span>;
    <span style="color: #228b22;">RMCB</span> *<span style="color: #a0522d;">first_rmcb</span>;         <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36164;&#28304;&#31649;&#29702;&#22120;&#25511;&#21046;&#22359;&#38142;&#34920;</span>
    <span style="color: #228b22;">PCB</span> *<span style="color: #a0522d;">first_prcb</span>;          <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36827;&#31243;&#25511;&#21046;&#22359;&#38142;&#34920;</span>
    <span style="color: #228b22;">SECB</span> *<span style="color: #a0522d;">first_secb</span>;         <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20250;&#35805;&#25511;&#21046;&#22359;&#38142;&#34920;</span>
    <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">stuff</span>;              <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20854;&#20182;&#31649;&#29702;&#24615;&#30340;&#25968;&#25454;</span>
};
</pre>
</div>

<p>
当组件在执行函数的时候，TPOS需要了解TRPC的信息，包括：
</p>
<ul class="org-ul">
<li>它在哪个进程中执行。</li>
<li>它是哪个事务的一部分。</li>
<li>哪个资源管理器已经提出了该调用。</li>
</ul>

<p>
为了后续描述方面，我们先引入几个辅助函数：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">Process_id</span> <span style="color: #0000ff;">my_process_id</span>(); <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36820;&#22238;&#35843;&#29992;&#32773;&#25152;&#22312;&#36827;&#31243;&#30340;&#26631;&#35782;&#31526;&#12290;</span>
<span style="color: #228b22;">TRID</span> <span style="color: #0000ff;">my_trid</span>();             <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36820;&#22238;&#35843;&#29992;&#32773;&#20174;&#23646;&#30340;&#20107;&#21153;&#26631;&#35782;&#31526;&#12290;</span>
<span style="color: #228b22;">RMID</span> <span style="color: #0000ff;">my_rmid</span>();             <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36820;&#22238;&#21457;&#20986;&#35843;&#29992;&#30340;&#36164;&#28304;&#31649;&#29702;&#22120;&#30340;&#26631;&#35782;&#31526;&#12290;</span>
<span style="color: #228b22;">RMID</span> <span style="color: #0000ff;">client_rmid</span>();         <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36820;&#22238;&#35843;&#29992;&#32773;&#23458;&#25143;&#30340;RMID&#12290;</span>
<span style="color: #228b22;">PCB</span> <span style="color: #0000ff;">my_proc</span>();              <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36820;&#22238;&#36827;&#31243;&#25511;&#21046;&#22359;&#21103;&#26412;&#12290;</span>
<span style="color: #228b22;">TransCB</span> <span style="color: #0000ff;">my_trans</span>();         <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36820;&#22238;&#20107;&#21153;&#25511;&#21046;&#22359;&#21103;&#26412;&#12290;</span>
<span style="color: #228b22;">RMCB</span> <span style="color: #0000ff;">my_rm</span>();               <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36820;&#22238;&#36164;&#28304;&#31649;&#29702;&#22120;&#25511;&#21046;&#22359;&#21103;&#26412;&#12290;</span>
<span style="color: #228b22;">RMCB</span> <span style="color: #0000ff;">client_rm</span>();           <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36820;&#22238;&#23458;&#25143;&#36164;&#28304;&#31649;&#29702;&#22120;&#25511;&#21046;&#22359;&#21103;&#26412;&#12290;</span>
<span style="color: #228b22;">PCB</span>* <span style="color: #0000ff;">my_proc_p</span>();           <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36820;&#22238;&#36827;&#31243;&#25511;&#21046;&#22359;&#12290;</span>
<span style="color: #228b22;">TransCB</span>* <span style="color: #0000ff;">my_trans_p</span>();      <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36820;&#22238;&#20107;&#21153;&#25511;&#21046;&#22359;&#12290;</span>
<span style="color: #228b22;">RMCB</span>* <span style="color: #0000ff;">my_rmp</span>();             <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36820;&#22238;&#36164;&#28304;&#31649;&#29702;&#22120;&#25511;&#21046;&#22359;&#12290;</span>
<span style="color: #228b22;">RMCB</span>* <span style="color: #0000ff;">client_rmp</span>();         <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36820;&#22238;&#23458;&#25143;&#36164;&#28304;&#31649;&#29702;&#22120;&#25511;&#21046;&#22359;&#12290;</span>
</pre>
</div>

<p>
有关资源管理器的描述存储在中心库内，每个资源管理器都有一个服务器类。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b22222;">// </span><span style="color: #b22222;">&#33410;&#28857;&#19978;&#36164;&#28304;&#31649;&#29702;&#22120;&#65288;&#26381;&#21153;&#22120;&#31867;&#65289;&#30340;&#25511;&#21046;&#22359;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">ResMgr</span> {
    <span style="color: #228b22;">RMNAME</span> <span style="color: #a0522d;">rm_name</span>;            <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36164;&#28304;&#31649;&#29702;&#22120;&#20840;&#23616;&#21517;&#31216;</span>
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">rmid</span>;                 <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36164;&#28304;&#31649;&#29702;&#22120;&#26631;&#35782;&#31526;</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">rm_local</span>;             <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26159;&#21542;&#26159;&#26412;&#22320;&#36164;&#28304;&#31649;&#29702;&#22120;</span>
    <span style="color: #228b22;">pointer</span> <span style="color: #a0522d;">acl</span>;               <span style="color: #b22222;">// </span><span style="color: #b22222;">&#35775;&#38382;&#25511;&#21046;&#21015;&#34920;</span>
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">priority</span>;     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26412;&#22320;&#36827;&#31243;&#20248;&#20808;&#32423;</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">rm_active</span>;            <span style="color: #b22222;">// </span><span style="color: #b22222;">&#27963;&#36291;&#26631;&#24535;</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">rm_up</span>;                <span style="color: #b22222;">// </span><span style="color: #b22222;">&#19978;&#21319;/&#19979;&#38477;&#26631;&#24535;</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">up_after_redo</span>;        <span style="color: #b22222;">// </span><span style="color: #b22222;">redo&#21518;&#33021;&#21542;&#27491;&#24120;&#25805;&#20316;</span>
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">queue_length</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#35831;&#27714;&#38431;&#21015;&#38271;&#24230;</span>
    <span style="color: #228b22;">rm_queue</span> <span style="color: #a0522d;">waiters</span>;          <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36164;&#28304;&#31649;&#29702;&#22120;&#35831;&#27714;&#38431;&#21015;</span>
    <span style="color: #228b22;">rm_queue</span> <span style="color: #a0522d;">end_of_chain</span>;     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26368;&#21518;&#19968;&#20010;&#31561;&#24453;&#30340;&#35831;&#27714;</span>
    <span style="color: #228b22;">rmta_cbp</span> <span style="color: #a0522d;">rmta_chain</span>;       <span style="color: #b22222;">// </span><span style="color: #b22222;">&#27491;&#22312;&#25191;&#34892;&#30340;&#20107;&#21153;&#30340;&#31532;&#19968;&#20010;&#25511;&#21046;&#22359;</span>
    <span style="color: #228b22;">rmpr_cbp</span> <span style="color: #a0522d;">rmpr_chain</span>;       <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36827;&#31243;&#25511;&#21046;&#22359;</span>
    <span style="color: #228b22;">rmno_cbp</span> <span style="color: #a0522d;">rmno_chain</span>;       <span style="color: #b22222;">// </span><span style="color: #b22222;">&#32593;&#32476;&#19978;&#33410;&#28857;&#30340;&#25511;&#21046;&#22359;</span>
    <span style="color: #228b22;">procedure</span> <span style="color: #a0522d;">rm_startup</span>;      <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31995;&#32479;&#21551;&#21160;&#22238;&#35843;&#20989;&#25968;</span>
    <span style="color: #228b22;">procedure</span> <span style="color: #a0522d;">rm_shutdown</span>;     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31995;&#32479;&#20851;&#38381;&#22238;&#35843;&#20989;&#25968;</span>
    <span style="color: #228b22;">RMCB</span> *<span style="color: #a0522d;">next_rmcb</span>;           <span style="color: #b22222;">// </span><span style="color: #b22222;">&#19979;&#19968;&#20010;&#25511;&#21046;&#22359;&#38142;&#34920;</span>
};
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">RMCB</span> = ResMgr;
</pre>
</div>

<p>
上面只是一个简单的框架，对于完整的系统，将会需要更多的入口点。不过对于揭示TP监控器的原理，这些已经足够了。相比资源管理器控制块，进程控制块简单了很多：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b22222;">// </span><span style="color: #b22222;">&#22312;&#26381;&#21153;&#22120;&#31867;&#20013;&#25551;&#36848;&#19968;&#20010;&#36827;&#31243;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Processes</span> {
    <span style="color: #228b22;">Process_id</span> <span style="color: #a0522d;">process_id</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36827;&#31243;&#26631;&#35782;&#31526;</span>
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">instance_of</span>;      <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25317;&#26377;&#36827;&#31243;&#30340;&#26381;&#21153;&#22120;&#31867;</span>
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">run_in</span>;           <span style="color: #b22222;">// </span><span style="color: #b22222;">&#32465;&#23450;&#30340;&#36164;&#28304;&#31649;&#29702;&#22120;</span>
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">client_id</span>;        <span style="color: #b22222;">// </span><span style="color: #b22222;">&#23458;&#25143;&#36164;&#28304;&#31649;&#29702;&#22120;</span>
    <span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">work_for</span>;         <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20174;&#23646;&#20107;&#21153;</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">busy</span>;             <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26159;&#21542;&#27491;&#22312;&#22788;&#29702;&#35831;&#27714;</span>
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">priority</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20248;&#20808;&#32423;</span>
    <span style="color: #228b22;">PRTA_CB</span>* <span style="color: #a0522d;">ta_todo</span>;      <span style="color: #b22222;">// </span><span style="color: #b22222;">&#34987;&#25346;&#36215;&#30340;&#20107;&#21153;&#21015;&#34920;</span>
    <span style="color: #228b22;">PRRM_CB</span>* <span style="color: #a0522d;">i_may_use</span>;    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#22320;&#22336;&#31354;&#38388;&#21487;&#20197;&#20999;&#25442;&#30340;&#36164;&#28304;&#31649;&#29702;&#22120;&#30340;&#21015;&#34920;</span>
};
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">PCB</span> = Processes;
</pre>
</div>

<p>
TP监控器还需要复制管理客户和服务器之间的会话。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Sessions</span> {
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">name</span>[BIG];    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20250;&#35805;&#21517;</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">incoming</span>;     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26497;&#65288;&#32852;&#20837;&#25110;&#32852;&#20986;&#65289;</span>
    <span style="color: #228b22;">pid</span> <span style="color: #a0522d;">initiator</span>;     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21021;&#22987;&#32465;&#23450;&#30340;&#36827;&#31243;&#26631;&#35782;&#31526;</span>
    <span style="color: #228b22;">nodeid</span> <span style="color: #a0522d;">init_node</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21021;&#22987;&#21270;&#36827;&#31243;&#25152;&#22312;&#33410;&#28857;</span>
    <span style="color: #228b22;">pid</span> <span style="color: #a0522d;">other_end</span>;     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#23545;&#31471;</span>
    <span style="color: #228b22;">NODEID</span> <span style="color: #a0522d;">bound_node</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#32465;&#23450;&#36827;&#31243;&#25152;&#22312;&#30340;&#33410;&#28857;</span>
    <span style="color: #228b22;">HANDLE</span> <span style="color: #a0522d;">handle</span>;     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20250;&#35805;&#21477;&#26564;</span>
    <span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">used_by</span>;      <span style="color: #b22222;">// </span><span style="color: #b22222;">&#24403;&#21069;&#20107;&#21153;</span>
    <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">stuff</span>;       <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20854;&#20182;&#20449;&#24687;</span>
};
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">SECB</span> = Sessions;
</pre>
</div>

<p>
现在已经有了足够的实体类型，我们还需要建立它们之间交叉引用的控制块。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b22222;">// </span><span style="color: #b22222;">&#21253;&#21547;&#19968;&#20010;&#20107;&#21153;&#21644;&#19968;&#20010;&#36164;&#28304;&#31649;&#29702;&#22120;&#30340;&#25511;&#21046;&#22359;&#65292;&#20445;&#23384;&#22312;rmta_chain&#20013;&#12290;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">RMTA</span> {
    <span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">serivced_ta</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20107;&#21153;&#26631;&#35782;</span>
    <span style="color: #228b22;">pointer</span> <span style="color: #a0522d;">data</span>;     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36164;&#28304;&#31649;&#29702;&#22120;&#29992;&#20110;&#20445;&#23384;&#20107;&#21153;&#24037;&#20316;&#29366;&#24577;&#30340;&#25968;&#25454;&#32467;&#26500;</span>
    <span style="color: #228b22;">RMTA_CB</span> *<span style="color: #a0522d;">next_ta</span>;
};
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">RMTA_CB</span> = RMTA;

<span style="color: #b22222;">// </span><span style="color: #b22222;">&#36164;&#28304;&#31649;&#29702;&#22120;&#35831;&#27714;&#38431;&#21015;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">rmq</span> {
    <span style="color: #228b22;">pointer</span> <span style="color: #a0522d;">request_message</span>;     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#28040;&#24687;&#20869;&#23481;</span>
    <span style="color: #228b22;">pointer</span> <span style="color: #a0522d;">rpc_data</span>;            <span style="color: #b22222;">// </span><span style="color: #b22222;">RPC&#19978;&#19979;&#25991;&#25511;&#21046;&#22359;</span>
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">timeout</span>;                <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36229;&#26102;&#26102;&#38388;</span>
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">client_type</span>;            <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25552;&#20986;&#35831;&#27714;&#30340;&#36164;&#28304;&#31649;&#29702;&#22120;&#31867;&#22411;&#65292;&#29992;&#20110;&#26816;&#27979;&#27515;&#38145;</span>
    <span style="color: #228b22;">RM_instance</span> <span style="color: #a0522d;">client_instance</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25552;&#20986;&#35831;&#27714;&#30340;&#36164;&#28304;&#31649;&#29702;&#22120;&#23454;&#20363;&#65292;&#29992;&#20110;&#26816;&#27979;&#27515;&#38145;</span>
    <span style="color: #228b22;">RMQUEUE</span> *<span style="color: #a0522d;">next_waiter</span>;        <span style="color: #b22222;">// </span><span style="color: #b22222;">&#38431;&#21015;&#20013;&#30340;&#19979;&#19968;&#20010;&#20803;&#32032;</span>
};
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">RMQUEUE</span> = rmq;

<span style="color: #b22222;">// </span><span style="color: #b22222;">&#36164;&#28304;&#31649;&#29702;&#22120;&#30340;&#36827;&#31243;&#21015;&#34920;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">rmpr</span> {
    <span style="color: #228b22;">PID</span> <span style="color: #a0522d;">pid</span>;           <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36827;&#31243;&#32534;&#21495;</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">primary_proc</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26159;&#21542;&#20998;&#37197;&#32473;&#20102;&#36164;&#28304;&#31649;&#29702;&#22120;&#30340;&#26381;&#21153;&#22120;&#31867;</span>
    <span style="color: #228b22;">rmpr</span> *<span style="color: #a0522d;">next</span>;
};
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">RMPR_CB</span> = rmpr;

<span style="color: #b22222;">// </span><span style="color: #b22222;">&#36827;&#31243;&#30340;&#36164;&#28304;&#31649;&#29702;&#22120;&#21015;&#34920;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">prrm</span> {
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">rmid</span>;   <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36164;&#28304;&#31649;&#29702;&#22120;&#32534;&#21495;</span>
    <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">stuff</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20854;&#20182;&#20449;&#24687;</span>
    <span style="color: #228b22;">prrm</span> *<span style="color: #a0522d;">next</span>;
};

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">PRRM_CB</span> = prrm;

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">operation</span> { <span style="color: #a0522d;">Lookup</span>, <span style="color: #a0522d;">Insert</span> };
<span style="color: #228b22;">RMCB</span>* <span style="color: #0000ff;">rmcb_access</span>(<span style="color: #228b22;">RMID</span>, <span style="color: #228b22;">operation</span>);
</pre>
</div>


<p>
接下来我们遍历一个完整的TRPC路径。从资源管理器提出TRPC开始，这个过程分为：
</p>
<ul class="org-ul">
<li>本地调用处理。</li>
<li>准备联出调用。</li>
<li>联入调用处理。</li>
<li>调用执行。</li>
<li>调用返回。</li>
</ul>

<p>
本地调用处理在调用者的TRPC存根上执行，目的是找到调用的种类和目的地。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">bool</span> <span style="color: #0000ff;">rm_call</span>(RMNAME, <span style="color: #228b22;">Bind_id</span> *<span style="color: #a0522d;">bound_to</span>, <span style="color: #228b22;">RM_Params</span> *<span style="color: #a0522d;">in_params</span>, <span style="color: #228b22;">RM_Params</span> *<span style="color: #a0522d;">out_results</span>) {
    <span style="color: #228b22;">RMCB</span> *<span style="color: #a0522d;">rmcb</span>;
    <span style="color: #228b22;">PID</span> <span style="color: #a0522d;">pid</span> = my_pid();
    <span style="color: #228b22;">PCB</span> *<span style="color: #a0522d;">pcb</span> = my_proc_p();
    <span style="color: #228b22;">PID</span> <span style="color: #a0522d;">pid_new</span>;
    <span style="color: #228b22;">PCB</span> *<span style="color: #a0522d;">pcb_new</span>;
    <span style="color: #228b22;">PRRM_CBP</span> <span style="color: #a0522d;">prrm_cbp</span>;
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">can_switch</span>;
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">dest_rmid</span>;
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">caller_client</span>;
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">success</span>;
    caller_client = pcb-&gt;client_id;
    <span style="color: #a020f0;">if</span> (bound_to == <span style="color: #008b8b;">nullptr</span>) {
        rmcb = NameServer(rmname, <span style="color: #8b2252;">"LOOKUP"</span>);
        <span style="color: #a020f0;">if</span> (rmcb == <span style="color: #008b8b;">nullptr</span>) {
            handle_error();
            <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
        }

        <span style="color: #a020f0;">if</span> (!rmcb-&gt;is_remote()) {
            <span style="color: #a020f0;">return</span> remote_rmc(...);
        }

        dest_rmid = rmcb-&gt;rmid;
        can_swith = <span style="color: #008b8b;">false</span>;
        prrm_cb = pcb-&gt;i_may_use;
        <span style="color: #a020f0;">while</span> ((prrm_cb != <span style="color: #008b8b;">nullptr</span>) &amp;&amp; !can_switch) {
            can_switch = (prrm_cb-&gt;rmid == dest_rmid);
            prrm_cb = prrm_cb-&gt;next;
        }

        <span style="color: #a020f0;">if</span> (can_switch) {
            pcb-&gt;client_id = pcb-&gt;run_in;
            pcb-&gt;run_in = dest_rmid;
            success = domain_switch(dest_rmid, ...);
        } <span style="color: #a020f0;">else</span> {
            pcb_new-&gt;busy = <span style="color: #008b8b;">true</span>;
            pcb_new-&gt;client_id = pcb-&gt;run_in;
            pcb_new-&gt;run_in = dest_rmid;
            pcb_new-&gt;work_for = pcb-&gt;work_for;
            send_ipc(pid_new, request_message);
            receive(response_message);
        }

        <span style="color: #a020f0;">return</span> sueecess;
    } <span style="color: #a020f0;">else</span> {
        <span style="color: #a020f0;">if</span> (bound_to.end_b.node_id != <span style="color: #008b8b;">nullptr</span>) {
            <span style="color: #a020f0;">return</span> remote_rmc(...);
        }
        <span style="color: #a020f0;">if</span> (bound_to.end_b.pid == pid) {
            <span style="color: #a020f0;">return</span> do_domain_switch();
        } <span style="color: #a020f0;">else</span> {
            <span style="color: #a020f0;">return</span> send_ipc(...);
        }
    }
}
</pre>
</div>


<p>
如果资源管理器需要通过网络获得，请求就需要通过会话传递。通信管理器负责建立和维护会话。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">FRMsg</span> {
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">addressee</span>;               <span style="color: #b22222;">// </span><span style="color: #b22222;">&#30446;&#26631;&#26381;&#21153;&#22120;</span>
    <span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">request_trid</span>;            <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20107;&#21153;&#32534;&#21495;</span>
    <span style="color: #228b22;">NODEID</span> <span style="color: #a0522d;">orig_node</span>;             <span style="color: #b22222;">// </span><span style="color: #b22222;">&#34987;&#35843;&#29992;&#32773;&#30340;&#33410;&#28857;</span>
    <span style="color: #228b22;">HANDLE</span> <span style="color: #a0522d;">handle</span>;                <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20250;&#35805;&#21477;&#26564;</span>
    <span style="color: #228b22;">TERMID</span> <span style="color: #a0522d;">terminal_id</span>;           <span style="color: #b22222;">// </span><span style="color: #b22222;">&#32456;&#31471;&#32534;&#21495;</span>
    <span style="color: #228b22;">AUTHID</span> <span style="color: #a0522d;">user_id</span>;               <span style="color: #b22222;">// </span><span style="color: #b22222;">&#29992;&#25143;&#25480;&#26435;</span>
    <span style="color: #228b22;">AUTHID</span> <span style="color: #a0522d;">rm_authid</span>;             <span style="color: #b22222;">// </span><span style="color: #b22222;">&#35831;&#27714;&#32773;&#30340;&#25480;&#26435;</span>
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">source_authent</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26412;&#22320;TP&#30417;&#25511;&#22120;&#25480;&#26435;</span>
    <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">stuff</span>;
    <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">long</span> <span style="color: #a0522d;">data_length</span>;    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25968;&#25454;&#38271;&#24230;</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">payload</span>[data_length];    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25968;&#25454;</span>
};

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">RequestMessage</span> = FRMsg;
</pre>
</div>

<p>
下面是TP监控器检查资源管理器是否已经向事务管理器登记的代码
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">RMCB</span> <span style="color: #a0522d;">rmcb</span>;
<span style="color: #228b22;">RMTA_CB</span> <span style="color: #a0522d;">rmta_cb</span>;
<span style="color: #228b22;">bool</span> <span style="color: #a0522d;">have_to_join</span>;
<span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">trid</span> = my_trid();

<span style="color: #a020f0;">if</span> (trid != NULLTRID) {
    rmcb = my_rmp();
    rmta_cb = rmcb-&gt;rmta_chain;
    have_to_join = <span style="color: #008b8b;">true</span>;
    <span style="color: #a020f0;">while</span> ((rmta_cb != <span style="color: #008b8b;">nullptr</span>) &amp;&amp; have_to_join) {
        have_to_join = (rmta_cb-&gt;serviced_ta != trid);
        rmta_cb = rmta_cb-&gt;next;
    }

    <span style="color: #a020f0;">if</span> (have_to_join) {
        join_work();
    }
}
</pre>
</div>

<p>
在事务系统中，队列主要应用于以下方面：
</p>
<ul class="org-ul">
<li>负载均衡。如果预计负载在很短的时间内能够快速返回，将请求放入服务器类的临时队列比创建新的服务器经常更经济。</li>
<li>最终用户控制。在异步处理中，如果数据库更新成功，而随后向用户展示结果的输出事务因为系统崩溃，或用户关闭的工作站而回滚。这时需要保存异步事务的输出用于重发。</li>
<li>可恢复的数据项。对于数据项驱动的应用程序，数据高速输入到系统中。这样的系统需要高吞吐量，而非低响应时间。使用队列可以让程序更快的获取数据。</li>
<li>多重事务请求。各个服务器进程需要交互数据，这个步骤可以按异步的方式执行，即，按高吞吐量进行调度。</li>
</ul>

<p>
这里我们可以看到，系统需要两种类型的队列：易失队列用于支持直接事务，持久队列用于支持异步事务处理。
</p>


<p>
假设一个服务器类建立了P个进程。在某一时刻，系统中的并发请求数量可能超过P，如果TP不打算建立新进程，那么它有两种选择：一是让客户决定怎么办。TP监控器拒绝服务，并返回一个错误码给客户。客户可以等待一段时间后重新发送请求。第二种方法是将请求放入队列中，等待何时的时机进行分派。这时，对资源管理器的调用以异步方式进程。考虑到服务器类的多个进程可能同时访问队列，因此必须保证：
</p>
<ul class="org-ul">
<li>一个请求只能被一个进程获取，并执行一次。</li>
<li>队列的结构要时刻保持正确。</li>
</ul>


<p>
异步事务处理需要使用的持久队列。在面向队列处理的系统中，有一个事务处理客户请求，表示服务、认证、一致性检查等都是这个事务的部分。事务最后向服务器发出请求。请求被放入队列，然后事务进行提交。在这之后，客户可以开始一个新事务，也可以等待第一个请求的响应。在这里，一个请求对应了3个事务，第一个事务产生请求，把它放到服务器的输入队列，第二个事务在服务器处理请求并把结果放入客户的响应队列，第三个事务从客户响应队列取出应答，展现给用户。这种方式叫做排队事务处理（Queued Transaction Processing，QTP）。
</p>


<p>
面向队列的客户-服务器交互的活动可以用一下三个属性来描述：
</p>
<ul class="org-ul">
<li>请求-回复匹配。系统保证每个请求都有一个回复，即使是拒绝服务的时候。</li>
<li>ACID请求处理。一个请求只执行一次，保存响应式ACID事务的一部分。</li>
<li>至少一次的响应处理。保证客户对每个响应至少接收一次。</li>
</ul>

<p>
排队系统的客户接口如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">QUNAME</span> = <span style="color: #228b22;">char</span>[BIG]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#38431;&#21015;&#20840;&#23616;&#21807;&#19968;&#21517;&#31216;</span>
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">QUID</span> = uint;        <span style="color: #b22222;">// </span><span style="color: #b22222;">&#38431;&#21015;&#23616;&#37096;&#21807;&#19968;&#26631;&#35782;</span>
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">RQID</span> = TRID;        <span style="color: #b22222;">// </span><span style="color: #b22222;">&#35831;&#27714;&#26631;&#35782;</span>
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">REQUEST</span> = <span style="color: #228b22;">char</span>*;    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#35831;&#27714;</span>
<span style="color: #a020f0;">using</span> <span style="color: #228b22;">RESPONSE</span> = <span style="color: #228b22;">char</span>*;   <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21709;&#24212;</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">&#23558;&#35831;&#27714;&#21457;&#36865;&#21040;to_queue&#38431;&#21015;&#65292;&#24182;&#35201;&#27714;&#21709;&#24212;&#20445;&#23384;&#21040;resp_queue&#38431;&#21015;&#12290;</span>
<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">send</span>(<span style="color: #228b22;">REQUEST</span> <span style="color: #a0522d;">do_this</span>, <span style="color: #228b22;">RQID</span> <span style="color: #a0522d;">rqid</span>, <span style="color: #228b22;">QUID</span> <span style="color: #a0522d;">to_queue</span>, <span style="color: #228b22;">QUID</span> <span style="color: #a0522d;">resp_queue</span>);

<span style="color: #b22222;">// </span><span style="color: #b22222;">&#20174;resp_queue&#38431;&#21015;&#20013;&#25509;&#25910;&#19979;&#19968;&#20010;&#21709;&#24212;&#65292;&#20445;&#23384;&#21040;keep_that&#20013;&#12290;</span>
<span style="color: #228b22;">RESPONSE</span> <span style="color: #0000ff;">receive</span>(<span style="color: #228b22;">QUID</span> <span style="color: #a0522d;">resp_queue</span>, <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">keep_that</span>[1000]);

<span style="color: #b22222;">// </span><span style="color: #b22222;">&#23637;&#31034;&#23458;&#25143;&#26368;&#21518;&#19968;&#27425;&#21709;&#24212;&#12290;</span>
<span style="color: #228b22;">RESPONSE</span> <span style="color: #0000ff;">re_receive</span>(<span style="color: #228b22;">QUID</span> <span style="color: #a0522d;">resp_queue</span>);
</pre>
</div>

<p>
将客户注册到队列就可以建立一个可恢复的会话：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">QStatePtr</span> = *SessionParams;

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">SessionParams</span> {
    <span style="color: #228b22;">QUID</span> <span style="color: #a0522d;">quid</span>;
    <span style="color: #228b22;">RQID</span> <span style="color: #a0522d;">last_send</span>;
    <span style="color: #228b22;">RQID</span> <span style="color: #a0522d;">last_receive</span>;
    <span style="color: #228b22;">RESPONSE</span> <span style="color: #a0522d;">response</span>;
};

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">QState</span> = SessionParams;

<span style="color: #228b22;">QState</span> <span style="color: #0000ff;">connect</span>(<span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">my_rmid</span>, <span style="color: #228b22;">QUID</span> <span style="color: #a0522d;">to_queue</span>);
<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">disconnect</span>(<span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">my_rmid</span>, <span style="color: #228b22;">QUID</span> <span style="color: #a0522d;">from_queue</span>);
</pre>
</div>

<p>
对于持久队列，直接使用文件系统是不行的。为了将一个简单的队列变成资源管理器，我们需要支持前面描述的资源管理器接口，并为各种与事务相关的事件提供回调入口点。假设所有队列都保存在下面的数据表中：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #a020f0;">CREATE</span> <span style="color: #a020f0;">TABLE</span> <span style="color: #0000ff;">sys_queues</span>(quid <span style="color: #228b22;">integer</span> <span style="color: #a020f0;">not</span> <span style="color: #a020f0;">null</span>,
                        q_type <span style="color: #228b22;">char</span>(2) <span style="color: #a020f0;">not</span> <span style="color: #a020f0;">null</span>,
                        from_rmid <span style="color: #228b22;">integer</span> <span style="color: #a020f0;">not</span> <span style="color: #a020f0;">null</span>,
                        to_rmid <span style="color: #228b22;">integer</span> <span style="color: #a020f0;">not</span> <span style="color: #a020f0;">null</span>,
                        <span style="color: #228b22;">timestamp</span> <span style="color: #228b22;">time</span>,
                        rqid TRID <span style="color: #a020f0;">not</span> <span style="color: #a020f0;">null</span>,
                        keepthat <span style="color: #228b22;">char</span>(1000),
                        request_response <span style="color: #228b22;">char</span>(40000),
                        no_dequeues <span style="color: #228b22;">integer</span>,
                        delete_flag <span style="color: #228b22;">char</span>(1),
                        <span style="color: #a020f0;">primary</span> <span style="color: #a020f0;">key</span> (quid,rqid,<span style="color: #228b22;">time</span>)
);
</pre>
</div>

<p>
属性q_type是队列的用途，“CS”表示队列保存客户发给服务器的消息，“SC”则反之。“SS”表示服务器之间传递的消息队列。no_dequeues是请求频率计数器，delete_flag表示一个元素是否已经使用过。其他资源管理器和队列资源管理器之间的会话存储在下面的数据表中：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #a020f0;">CREATE</span> <span style="color: #a020f0;">TABLE</span> <span style="color: #0000ff;">qu_sessions</span>(quid <span style="color: #228b22;">integer</span> <span style="color: #a020f0;">not</span> <span style="color: #a020f0;">null</span>,
                         rmid <span style="color: #228b22;">integer</span> <span style="color: #a020f0;">not</span> <span style="color: #a020f0;">null</span>,
                         <span style="color: #a020f0;">role</span> <span style="color: #228b22;">char</span>(1),
                         <span style="color: #a020f0;">primary</span> <span style="color: #a020f0;">key</span> (quid,rmid)
);
</pre>
</div>

<p>
属性role表明rmid在会话中的身份是客户还是服务器。队列资源管理器提供的函数有：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">QAttrPtr</span> = queue_rel*;
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">queue_rel</span> {
    <span style="color: #228b22;">QUID</span> <span style="color: #a0522d;">quid</span>;
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">q_type</span>[2];
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">from_rmid</span>;
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">to_rmid</span>;
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">time</span>[8];
    <span style="color: #228b22;">RQID</span> <span style="color: #a0522d;">rqid</span>;
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">keepthat</span>[1000];
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">request_response</span>[40000];
    <span style="color: #228b22;">uint</span> <span style="color: #a0522d;">no_dequeues</span>;
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">delete_flag</span>;
} <span style="color: #a0522d;">QAttr</span>;

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">send</span>(<span style="color: #228b22;">QAttrPtr</span> <span style="color: #a0522d;">ptr</span>) {
    exec_sql(<span style="color: #8b2252;">"INSERT INTO sys_queues VALUES (...)"</span>);
    <span style="color: #a020f0;">return</span> (sqlcode == 0);
}

<span style="color: #228b22;">RESPONSE</span> <span style="color: #0000ff;">receive</span>(<span style="color: #228b22;">QUID</span> <span style="color: #a0522d;">from_there</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">keep_that</span>[1000]) {
    exec_sql(<span style="color: #8b2252;">"DECLARE CURSOR dequ ON SELECT * FROM sys_queues WHERE quid= :from_there AND delete_flag = NULL RODER BY rqid ASCENDING FOR UPDATE &lt;some isolation clauses&gt;"</span>);

    <span style="color: #a020f0;">while</span> (<span style="color: #008b8b;">true</span>) {
        exec_sql(<span style="color: #8b2252;">"OPEN dequ"</span>);
        exec_sql(<span style="color: #8b2252;">"FETCH dequ INTO :(QAttrPtr-&gt;QAttr)"</span>);
        <span style="color: #a020f0;">if</span> (sqlcode == 0) {
            exec_sql(<span style="color: #8b2252;">"UPDATE WHERE CURRENT OF CURSOR dequ SET delete_flag='D', QAttrPtr-&gt;KeepThat = :KeepThat"</span>);
            exec_sql(<span style="color: #8b2252;">"CLOSE dequ"</span>);
            <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
        }

        exec_sql(<span style="color: #8b2252;">"CLOSE dequ"</span>);
        wait(1);
    }
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">rm_startup</span>() { <span style="color: #a020f0;">return</span>; }
<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">rm_prepare</span>() { <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>; }
</pre>
</div>


<p>
除了上述几点，TP监控器还需要处理负载均衡、认证和授权，以及重启处理。实际上，TP监控器是一个管理其他资源管理器及处理器资源（进程、程序等）的资源管理器。
</p>
</div>
</div>

<div id="outline-container-org491d083" class="outline-2">
<h2 id="org491d083">隔离性的概念</h2>
<div class="outline-text-2" id="text-org491d083">
<p>
系统状态包含了以某些方式联系在一起的实体，这些联系被描述为实体的不变量（invariant）。如果不变量得到满足，我们就称系统状态是一致的。当系统从一个状态转变为另一种状态时，会有一瞬间无法满足一致性。为此，需要将操作封装到事务之中，当事务结束时，无论事务成功与否，系统状态总是一致的。由于事务是并发执行的，为了保证一致性，比如引入并发控制。
</p>

<p>
并发控制有两个法则：
</p>
<ul class="org-ul">
<li>并发执行不应导致程序失败。</li>
<li>相比于串行执行，并发执行不应有更低的吞吐量和更长的响应时间。</li>
</ul>

<p>
简单的封锁协议是给每个对象加一个锁，无论事务要存取哪个对象，资源管理器自动请求和获得对象的锁，直到事务结束。如果另外一个事务想要访问对象，它必须等待锁的释放。
</p>


<p>
事务可以看成是一组读写操作，只有在并发事务写同一个对象时才会破坏一致性。事务可以看成是一系列在对象上运行的操作（action)，一个特定对象只接受一个操作，这个操作要么是读操作，要么是写操作。对象经过写操作修改后，形成一些列版本。如果事务读一个对象，事务依赖于该对象的版本。如果事务写一个对象，对象版本依赖于事务。当一个事务中止或撤销时，所有的写操作被撤销。由于版本号只能增加，撤销操作会为对象建立一个新版本，保存其原始的值。我们考虑两个事务访问一个对象的情况，因为读操作不会产生版本，这里不考虑两个事务都读的情况。事务执行的序列一共有三种：
</p>
<ul class="org-ul">
<li>R-W依赖。</li>
</ul>
<div class="org-src-container">
<pre class="src src-text">T1 READ  &lt;o,1&gt;
T2 WRITE &lt;o,2&gt;
</pre>
</div>
<ul class="org-ul">
<li>W-R依赖。</li>
</ul>
<div class="org-src-container">
<pre class="src src-text">T1 WRITE &lt;o,2&gt;
T2 READ  &lt;o,1&gt;
</pre>
</div>
<ul class="org-ul">
<li>W-W依赖。</li>
</ul>
<div class="org-src-container">
<pre class="src src-text">T1 WRITE &lt;o,2&gt;
T2 WRITE &lt;o,3&gt;
</pre>
</div>

<p>
上面三种是最简单的情况。实际情况下，并发事务中的操作按照依赖会形成一个有向图。如果图中有环，事务不是以隔离方式执行的。如果图中没有环，使用拓扑排序可以产生等价的执行顺序。有环的情况有三种：
</p>
<ul class="org-ul">
<li>丢失更新。</li>
</ul>
<div class="org-src-container">
<pre class="src src-text">T2 READ  &lt;o,1&gt;
T1 WRITE &lt;o,2&gt;
T2 WRITE &lt;o,3&gt;
</pre>
</div>
<ul class="org-ul">
<li>读脏数据。</li>
</ul>
<div class="org-src-container">
<pre class="src src-text">T2 WRITE &lt;o,2&gt;
T1 READ  &lt;o,2&gt;
T2 WRITE &lt;o,3&gt;
</pre>
</div>
<ul class="org-ul">
<li>不可重复读。</li>
</ul>
<div class="org-src-container">
<pre class="src src-text">T1 READ  &lt;o,1&gt;
T2 WRITE &lt;o,2&gt;
T1 READ  &lt;o,2&gt;
</pre>
</div>

<p>
这三种情况覆盖了全部的并发异常。
</p>


<p>
下面我们从用户的角度来定义隔离性，我们给出两个等价的定义：
</p>
<ul class="org-ul">
<li>定义1。事务处理系统可以并发的执行事务，但它的结果如同顺序执行一样。就应用程序而言，事务好像是在没有并行的情况下运行。</li>
<li>定义2。如果事务T和其他事务满足下列条件，称它是隔离的：
<ul class="org-ul">
<li>T不会重写其他事务的脏数据。</li>
<li>T所写的数据，在T提交之前，不会被其他事务读或写。</li>
<li>T不读其他事务的脏数据。</li>
<li>在T提交之前，其他事务不会写T所要读的数据。</li>
</ul></li>
</ul>

<p>
现在我们对隔离性进行一个形式化的描述。首先我们要引入序列的概念。计算机科学中所有的东西都是序列，记录是字段序列，程序是语句序列，进程是执行步骤序列。我们用 &lt;a,b,c&gt; 表示由a、b和c组成的序列。对于序列S，S[i]表示其中第i个元素。序列可以拼接，S||S'表示序列S和S'拼接而成的序列。S的子序列用&lt;S[i]|谓词(S[i])&gt;表示。
</p>


<p>
键值对是一种常用的序列，它可以表示为&lt;名字,值&gt;。键值对有2个元素，第一个表示名字，第二个表示值。系统状态可以表示为键值对序列{&lt;name,value&gt;}，每个键值对记录了对象的名字和值。我们考虑一个简化的事务，系统支持对象上的操作（READ、WRITE、XLOCK、SLOCK、UNLOCK）和一般操作（BEGIN、COMMIT、ROLLBACK）。在事务读写一个对象之前，应该为对象加锁，然后在COMMIT或ROLLBACK时释放。
</p>


<p>
我们看到有两种类型的锁：SLOCK表示共享（shared）的，SLOCK用于保护读操作。XLOCK是排他的，用于保护写操作。如果一个事务是规范的，其中的所有读写操作都由锁保护，并且锁和解锁操作是成对出现的。随着事务的执行，事务会获得更多对象的锁，这个阶段叫做成长阶段。对应的，逐渐释放锁的阶段叫做收缩阶段。
</p>


<p>
一组事务中的所有操作序列，在保持各自顺序不变的情况下可以归并为一个单一序列，这个序列叫做调度（history），记为H=&lt;&lt;t,a,o&gt;<sub>i</sub>, i = 1, 2, &#x2026; n&gt;。其中&lt;t,a,o&gt;表示事务t在对象o上执行操作a。最简单的调度是依次执行事务，这种方式叫做串行调度（serial history），串行调度不会有脏数据。除此之外还有很多的调度。是不是每个调度都可以正确执行呢？答案是否定的。我们必须考虑锁的影响。符合封锁限制规则的调度才是合法的。封锁限制规则也叫锁的相容性，定义如下：
</p>
<ul class="org-ul">
<li>S锁和S锁相容。</li>
<li>X锁和其他锁冲突。</li>
</ul>

<p>
下面我们给出调度合法性的形式化定义。假设H是一个调度，事务T在H中的第k步可以为对象o加S锁的前提条件是，对于i&lt;k，动作H[i]=&lt;t,SLOCK,o&gt;，且在自调度H[i+1],&#x2026;,H[k-1]中没有&lt;t,UNLOCK,o&gt;。类似的可以定义加X锁的条件。如果一个调度中，有两个事务为一个对象施加了不相容的锁，这个调度就是非法的。
</p>


<p>
给定一个初始状态和一个调度，我们就可以知道系统的具体行为。对于调度H中的事务T<sub>1</sub>和T<sub>2</sub>，如果T<sub>1</sub>读写了T<sub>2</sub>写过的数据，或者T<sub>1</sub>写入T<sub>2</sub>读过的对象，就称T<sub>1</sub>依赖于T<sub>2</sub>。如果两个调度具有同样的依赖，对于相同的输入，它们会产生相同的输出。
</p>

<p>
我们用V(o,k)表示调度H中第k步时对象o的版本，这个版本就是在第k步值钱对象o的写的次数：
</p>
<blockquote>
<p>
V(o,k) = |{&lt;t<sub>j</sub>,a<sub>j</sub>,o<sub>j</sub> &isin; H| j &lt; k, a<sub>j</sub>=WRITE, o<sub>j</sub>=o}|
</p>
</blockquote>

<p>
假设T1和T2是两个不同的事务，o是一个对象，i，j(i&lt;j)是调度H中的两个步骤，H[i]涉及T1在o上的操作a1，H[j]涉及T2在o上的操作a2，并且在i到j之间没有任何一个事务对o进行了写操作。我们可以定义一个三元关系DEP(H)：
</p>
<blockquote>
<p>
&lt;T1,&lt;o,V(o,j)&gt;,T2&gt; &isin; DEP(H) 如果 &lt;a1,a2&gt;是下列三个序列之一：&lt;WRITE,WRITE&gt;，&lt;WRITE,READ&gt;，&lt;READ,WRITE&gt;
</p>
</blockquote>

<p>
DEP(H)叫做依赖关系，它定义了一个有向图，事务是图的节点，版本是边。依赖关系刻画了调度的根本特性，具有相同依赖关系的调度叫做等价的。如果一个调度等价于串行调度，它也叫做隔离的。
</p>


<p>
调度的依赖定义事务的一个时间序列，用符号&lt;&lt;&lt;<sub>H</sub>或&lt;&lt;&lt;表示。T&lt;&lt;&lt;T'表示在依赖图中有一条路径从T到T'。有了时间序列，对于事务T，我们就可以知道哪些事务在它之前，哪些事务在它之后：
</p>
<blockquote>
<p>
BEFORE(T) = {T'|T'&lt;&lt;&lt;T}
</p>

<p>
AFTER(T) = {T'|T&lt;&lt;&lt;T'}
</p>
</blockquote>

<p>
前面我们提到依赖图中可能出现环。出现环的时候，调度中存在事务T和T'，并且T'属于BEFORE(T)和AFTER(T)的交集。这时事务T'叫做虫洞事务。串行调度是没有虫洞事务，因此隔离调度也没有虫洞。反之，如果一个调度不是隔离调度，它一定存在一对虫洞事务。这种调度执行会出现并发异常，且不满足ACID性质。
</p>


<p>
上述讨论构成了并发控制的基本结论：
</p>
<ul class="org-ul">
<li>虫洞定理。一个调度是隔离的，当且仅当它没有虫洞事务。</li>
<li>封锁定理。如果事务是良构的，且是两阶段的，那么合法调度是隔离调度。</li>
<li>封锁定理（逆定理）。如果事务不是良构的，或者不是两阶段的，那么可以构造出一个事务与之组成虫洞。</li>
<li>回滚定理。一个先UNLOCK再ROLLBACK的更新事务不是两阶段的。</li>
</ul>


<p>
如果系统可以防止READ-WRITE依赖的情况，就叫做游标稳定的（cursor stability），这时ISO/ANSI SQL默认的隔离标准。一些系统允许用户自己设定隔离级别（degrees of isolation）：
</p>
<ul class="org-ul">
<li>0级（混乱）。0级隔离事务不会重写高级别事务的脏数据。</li>
<li>1级（浏览）。1级隔离事务不会丢失更新。</li>
<li>2级（游标稳定）。2级隔离事务不会丢失更新，也不会读脏数据。</li>
<li>3级（隔离或可重复读）。3级事务不会丢失更新，且可重复读。</li>
</ul>
<p>
这4个隔离级别对应的封锁协议如下：
</p>
<ul class="org-ul">
<li>0级。封锁协议对写操作是规范的。</li>
<li>1级。封锁协议对排他锁是两阶段的，对写操作是规范的。</li>
<li>2级。封锁协议是规范的，对排他锁是两阶段的。</li>
<li>4级。封锁协议是规范和两阶段的。</li>
</ul>

<p>
关于隔离性级别有一个重要的定理，叫做隔离性级别定理：
</p>
<blockquote>
<p>
如果一个事务遵守0、1、2或3级封锁协议，并且其他事务至少是1级的，任意一个合法调度将给这个事务带来1、2或3级隔离。
</p>
</blockquote>

<p>
这个定理表明，如果每个用户都是以只读或更高级别（1级）的方式运行，一个用户可以选择合适的隔离级别，而不会引起并发问题。当然，采用低隔离级别时，用户必须自己处理数据一致性问题。
</p>


<p>
隔离级别越低，事务请求的锁就越少，或者持有锁的时间就越短。考虑下面的SQL代码：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #a020f0;">SELECT</span> <span style="color: #483d8b;">COUNT</span>(*) <span style="color: #a020f0;">FROM</span> emp <span style="color: #a020f0;">WHERE</span> eyes="blue" <span style="color: #a020f0;">AND</span> haire="red";
</pre>
</div>
<p>
如果使用3级隔离，当它扫描完成时，会持有大量的记录锁或一个表锁。
</p>


<p>
SQL标准定义了4个隔离级别：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #a020f0;">SET</span> <span style="color: #a020f0;">TRANSACTION</span> <span style="color: #a020f0;">ISOLATION</span> <span style="color: #a020f0;">LEVEL</span> [<span style="color: #a020f0;">READ</span> <span style="color: #a020f0;">UNCOMMITTED</span>]
                                [<span style="color: #a020f0;">READ</span> <span style="color: #a020f0;">COMMITTED</span>]
                                [<span style="color: #a020f0;">REPEATABLE</span> <span style="color: #a020f0;">READ</span>]
                                [<span style="color: #a020f0;">SERIALIZABLE</span>]
</pre>
</div>
<p>
其中，READ UNCOMMITTED是浏览的，READ COMMITTED是游标稳定的，REPEATABLE READ是2.9999隔离，比3级隔离少了幻像保护，SERIALIZABLE是隔离的。
</p>


<p>
对于封锁有一个锁长度（lock duration）的概念，很快释放的锁叫短缩（short duration），一直到事务结束时才释放的锁叫长锁（long duration）。0级封锁协议中，读写锁都是短锁，在0级以上的协议中，读是短锁，写是长锁。ROLLBACK操作需要锁来保护，0级协议不支持ROLLBACK，因此对于只读事务，0级=1级。对于更新事务，如果需要ROLLBACK以防止失败，不能在0级隔离下执行。1级隔离适用于浏览数据库，比如SQL UPDATE STATISTICS语句，它允许读到老一点的数据。2级隔离和3级隔离的开销几乎相同，3级隔离不会重复请求一个锁，并且在事务结束时批量释放锁，可以节省一部分处理器时间。下表总结了四种隔离级别的性质：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">隔离级别</td>
<td class="org-left">0级</td>
<td class="org-left">1级</td>
<td class="org-left">2级</td>
<td class="org-left">3级</td>
</tr>

<tr>
<td class="org-left">名称</td>
<td class="org-left">混沌</td>
<td class="org-left">浏览</td>
<td class="org-left">游标稳定</td>
<td class="org-left">隔离的、可串行的、可重复读</td>
</tr>

<tr>
<td class="org-left">保护</td>
<td class="org-left">让其他事务运行在更高级别</td>
<td class="org-left">没有更新丢失</td>
<td class="org-left">没有更新丢失和读脏数据</td>
<td class="org-left">没有更新丢失和读脏数据，可重复读</td>
</tr>

<tr>
<td class="org-left">提交的数据</td>
<td class="org-left">立即可见</td>
<td class="org-left">事务结束时可见</td>
<td class="org-left">事务结束时可见</td>
<td class="org-left">事务结束时可见</td>
</tr>

<tr>
<td class="org-left">脏数据</td>
<td class="org-left">不会覆盖脏数据</td>
<td class="org-left">别人不会覆盖你的脏数据</td>
<td class="org-left">别人不会覆盖你的脏数据，且不会读脏数据</td>
<td class="org-left">别人不会覆盖你的脏数据，不会读脏数据，也不会弄脏你读的数据</td>
</tr>

<tr>
<td class="org-left">封锁协议</td>
<td class="org-left">写加排他短锁</td>
<td class="org-left">写加排他长锁</td>
<td class="org-left">写加排他长锁，读加共享短锁</td>
<td class="org-left">写加排他长锁，读加共享长锁</td>
</tr>

<tr>
<td class="org-left">事务结构</td>
<td class="org-left">规范的WRT写</td>
<td class="org-left">规范的WRT写和两阶段WRT写</td>
<td class="org-left">规范且两阶段WRT写</td>
<td class="org-left">规范且两阶段</td>
</tr>

<tr>
<td class="org-left">并发</td>
<td class="org-left">最大，仅加短写锁</td>
<td class="org-left">大，仅等待写锁</td>
<td class="org-left">中，加少量读锁</td>
<td class="org-left">小，涉及的任意数据都加长锁</td>
</tr>

<tr>
<td class="org-left">开销</td>
<td class="org-left">小，仅加短写锁</td>
<td class="org-left">小，仅加写锁</td>
<td class="org-left">中，设置两种类型的锁，不存储读锁</td>
<td class="org-left">中，设置和存储两种类型的锁</td>
</tr>

<tr>
<td class="org-left">回滚</td>
<td class="org-left">层叠撤销不能回滚</td>
<td class="org-left">撤销未完成的事务</td>
<td class="org-left">撤销未完成的事务</td>
<td class="org-left">撤销未完成的事务</td>
</tr>

<tr>
<td class="org-left">系统恢复</td>
<td class="org-left">更新可能丢失</td>
<td class="org-left">使用日志</td>
<td class="org-left">使用日志</td>
<td class="org-left">使用日志</td>
</tr>

<tr>
<td class="org-left">依赖</td>
<td class="org-left">无</td>
<td class="org-left">WRITE-WRITE</td>
<td class="org-left">WRITE-WRITE, WRITE-READ</td>
<td class="org-left">WRITE-WRITE,WRITE-READ,READ-WRITE</td>
</tr>
</tbody>
</table>


<p>
下面我们讨论另外两个封锁概念：跳读（read-past)锁和通知（notify）锁。0级和1级隔离通过使用通读（read-through）封锁来实现，跳读锁会略过未提交的更新，跳读游标只返回没有加X锁的记录。通知锁是一种触发器，创建一个施加于码区间的锁，当其他事务释放了与该码区间较长的锁，通知锁立即获得批准。
</p>


<p>
重新考虑前面的SQL语句：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #a020f0;">SELECT</span> * <span style="color: #a020f0;">FROM</span> emp <span style="color: #a020f0;">WHERE</span> eyes="blue" <span style="color: #a020f0;">AND</span> hair="red";
</pre>
</div>

<p>
系统可能对emp表加锁，或者对满足查询条件的全部记录加锁。如果采用后者，在读操作结束后，如何阻止其他事务插入一条“蓝眼睛红头发”的记录呢？不存在的记录是不会被封锁的。还有，如果这是一个DELETE语句，在提交之前，它必须放置其他事务看到记录消失，又不能让其他事务插入新记录，因此必须对要删除的记录加锁。这种新产生的，或者即将删除的记录叫做幻像记录（phantom record）。最简单的方法是采用表锁，但这回降低并发性和性能。另一种方法是使用谓词锁（predicate lock）或它的简化形式，粒度锁（granular lock）。谓词锁封锁的是一组满足某个谓词的集合：
</p>
<blockquote>
<p>
&lt;t, slock, emp.eyes="blue" and emp.hair="red"&gt;
</p>
</blockquote>
<p>
更一般的形式是&lt;t,[slock|xlock],predicate&gt;，可以看到，这是对象锁&lt;t,[slock|xlock],object&gt;的一般化。
</p>


<p>
谓词锁也有相容的概念。如果两个谓词锁&lt;t,mode,p&gt;和&lt;t',mode',p'&gt;满足下列条件之一，我们说它们是相容的：
</p>
<ul class="org-ul">
<li>t=t'</li>
<li>mode和mode'都是共享锁</li>
<li>谓词(p and p')为假</li>
</ul>

<p>
谓词锁有三个缺点，首先是执行代价高。谓词满足性是O(2^N)的。其次谓词锁是悲观的。第三，找出谓词来源比较困难。
</p>


<p>
幻像记录引发了封锁单元（lock unit）的概念，即为保证隔离性而封锁的数据集合。数据库、文件、记录、字段等都可以作为封锁单元。封锁粒度的选择要权衡并发性和开销。合理的封锁协议应当满足：对批量大事务提供覆盖整个文件的单一锁，对交互事务提供细粒度封锁。粒度锁的基本思想是选择一组固定的谓词集合，即预先计算谓词锁。这些谓词形成一个有向无环图，顶点是true。这个图可以看成是一棵树，最细的粒度上有一个谓词。如果系统的结构为site、file和record，那么粒度锁具有下列的形式：
</p>
<div class="org-src-container">
<pre class="src src-text">site="RIPA" AND file="PHONE" AND record="GIOVANNA"
</pre>
</div>

<p>
如果要对整个RIPA加锁，可以使用下面的谓词：
</p>
<div class="org-src-container">
<pre class="src src-text">site="RIPA"
</pre>
</div>

<p>
遵循层次封锁协议，对一个节点加锁则隐式的给其所有子节点加同样类型的锁。如果只封锁一个节点，而不封锁其子节点，这种锁叫做意向（intent）锁。意向锁、共享锁和排他锁的相容矩阵为
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">请求类型</td>
<td class="org-left">无</td>
<td class="org-left">意向</td>
<td class="org-left">共享</td>
<td class="org-left">排他</td>
</tr>

<tr>
<td class="org-left">意向</td>
<td class="org-left">+</td>
<td class="org-left">+</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
</tr>

<tr>
<td class="org-left">共享</td>
<td class="org-left">+</td>
<td class="org-left">-</td>
<td class="org-left">+</td>
<td class="org-left">-</td>
</tr>

<tr>
<td class="org-left">排他</td>
<td class="org-left">+</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
</tr>
</tbody>
</table>

<p>
如果一个事务对粗粒度对象加共享锁，另一个事务对细粒度对象加共享锁，二者不会冲突。因此意向锁又被细分为：
</p>
<ul class="org-ul">
<li>IX。将对细粒度对象加共享或排他锁。</li>
<li>IS。将对细粒度对象加共享锁。</li>
<li>SIX。将对粗粒度对象加共享锁，对其下的细粒度对象加排他锁。</li>
</ul>
<p>
这些锁的相容性为
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">请求类型\已持有的锁</td>
<td class="org-left">无</td>
<td class="org-left">IS</td>
<td class="org-left">IX</td>
<td class="org-left">S</td>
<td class="org-left">SIX</td>
<td class="org-left">U</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-left">IS</td>
<td class="org-left">+</td>
<td class="org-left">+</td>
<td class="org-left">+</td>
<td class="org-left">+</td>
<td class="org-left">+</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
</tr>

<tr>
<td class="org-left">IX</td>
<td class="org-left">+</td>
<td class="org-left">+</td>
<td class="org-left">+</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
</tr>

<tr>
<td class="org-left">S</td>
<td class="org-left">+</td>
<td class="org-left">+</td>
<td class="org-left">-</td>
<td class="org-left">+</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
</tr>

<tr>
<td class="org-left">SIX</td>
<td class="org-left">+</td>
<td class="org-left">+</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
</tr>

<tr>
<td class="org-left">U</td>
<td class="org-left">+</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">+</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
</tr>

<tr>
<td class="org-left">X</td>
<td class="org-left">+</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
<td class="org-left">-</td>
</tr>
</tbody>
</table>


<p>
粒度封锁协议定义如下：
</p>
<ul class="org-ul">
<li>从根到叶获取锁。</li>
<li>从叶到根释放锁。</li>
<li>对非根节点加S或IS锁，其中一个父节点必须持有更高级别的锁（IS、IX、S、SIX、U、X）。</li>
<li>对非根节点加X、U、SIX或IX锁，其所有父节点必须持有IX或更高级别的锁（IX、SIX、U、X）。</li>
</ul>

<p>
这里提到的U是update锁，即更新锁。更新锁是为了避免死锁而引入的。如果两个事务几乎同时读取了一条热点记录，并使用S锁保护，然后再修改时又要对记录加X锁，这就会产生死锁。一些研究表明大部分死锁都是这种情况。U锁和S锁相容，但S锁和U锁不相容，使用U锁可以延迟第二个事务的执行，避免死锁。
</p>


<p>
一般来说，锁共有7中类型：
</p>
<ul class="org-ul">
<li>没有锁（None）。</li>
<li>意向共享（IS）锁。保留锁持有者在较细粒度上显式加IS、S锁的权利，防止其他事务在该节点上加X、U锁。</li>
<li>意向排他（IX）锁。保留锁持有者在较细粒度上显式加IS、IX、S、SIX、U、X锁的权利，防止其他事务在节点上加S、SIX、X、U锁。</li>
<li>共享（S）锁。保留锁持有者对该节点及其后代节点读的权利，防止其他事务在该节点及其后代节点加X、IX、SIX锁。</li>
<li>共享意向排他（SIX）锁。保留锁持有者对该节点及其后代节点读的权利，防止其他事务在该节点及其后代节点加X、U、IX、SIX、S锁。保留锁持有者在细粒度上显式加IX、U、X锁。</li>
<li>更新（U）锁。保留锁持有者对该节点及其后代节点读的权利，防止其他事务在该节点及其后代节点加X、U、IX、SIX、IS锁。U锁表明将来可能对节点进行更新。为了防止死锁，U锁和自己不相容。</li>
<li>排他（X）锁。保留锁持有者对该节点写的权利，防止其他事务在该节点及其后代节点加X、U、S、SIX、IS、IX锁。</li>
</ul>


<p>
粒度锁实际就是谓词锁，粒度锁通过在记录集合上加锁来解决幻像问题。记录集合可以是物理上的，比如文件，也可以是逻辑上的，比如记录集合。如果在访问记录前，封锁具有相同主码前缀的记录集合，就可以避免幻像问题，这种锁叫做码区间封锁（key-range locking）。码区间使用半闭半开区间[R,S)表示。为了避免幻像记录，需要处理读唯一记录、读下一条记录、插入和删除这几种操作。假设码X不存在，事务T请求对码X进行唯一读操作。这中情况下，在事务T提交之前，必须禁止其他事务插入码X，否则就可能产生幻像。假设事务T的游标位于码W，事务T进行读下一个记录的操作，得到码Y。在T提交之前，W和Y不能被其他事务改变，在W和Y之间，其他事务也不能插入幻像记录。假设X、Y、Z是顺序排列的三条记录，事务T删除Y。在T提交之前其他事务不能插入幻像记录Y，而且其他事务不能在T提交之前发现Y消失，或者Z成为X的后继记录。码区间封锁协议需要在访问记录前对记录所在的码区间进行封锁。假设记录集被分为3个码区间：[A,N), [N,X), [X,+inf)，W、X、Y、Z是顺序的四个码值，那么对X或Y的读唯一记录操作需要对码区间[X,+inf)加共享锁。从W到Y的读下一条记录操作，需要为码区间[N,X)和[X,+inf)加共享锁。而插入记录X或删除Y需要对[X,+inf)加排他锁。这个例子中的码区间封锁协议是静态的，因为码区间是固定的。我们可以考虑把码W获得它的后继码X组成一个区间，这样可以得到码区间封锁的两个变体：后码封锁（next-key locking）和前码封锁（previous-key locking）。在前码封锁中，请求对W加锁的事务得到对[W,X)的封锁，而后码封锁中，得到的是对(W,X]的封锁。这两个变体可以支持动态码区间封锁。下面我们考察动态码区间的封锁协议，还是从读唯一记录、读下一记录、插入和删除四个操作入手。读唯一记录：如果码X存在，事务T获取X的共享锁[X,Y)。如果X不存在，事务T对覆盖X的区间[W,Y)加共享锁，防止幻像记录X的插入。读下一记录：事务T读唯一记录W，同时请求其后序记录Y。T已经对W加锁，得到了[W,Y)封锁。现在T只需要获得Y的共享锁，就可以完成对[Y,Z)的隐式加锁。插入：向[W,Y)插入X会将区间分成[W,X)和[X,Y)两部分。首先对[W,Y)加排他锁，然后对[X,Y)加排他锁。对[X,Y)加锁的目的是避免其他事务尝试读取[X,Y)时看到幻像记录。如果此时事务U等待[X,Y)锁，而事务T回滚，码区间会恢复为原来的[W,Y)，因此事务U在获得码区间锁时必须重新确认码区间，如果码区间发生变更，必须释放锁并重新申请。删除：将Y从序列X、Y、Z中删除会将[W,Y)和[Y,Z)合并为[W,Z)。首先对Y（[Y,Z)）加排他锁，然后对W（删除前的[W,Y)，删除后的[W,Z)）加排他锁，接着删除Y。
</p>


<p>
采用码区间锁需要DAG封锁的支持。考虑下面的查询：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #a020f0;">SELECT</span> * <span style="color: #a020f0;">FROM</span> emp <span style="color: #a020f0;">WHERE</span> eyes="blue" <span style="color: #a020f0;">AND</span> hair="red"
</pre>
</div>

<p>
假设主码是雇员编号，由于编号同眼睛颜色、头发颜色没有关系，我们必须封锁[0,+inf)，即整个emp表。如果我们建立了两个索引：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #a020f0;">CREATE</span> <span style="color: #a020f0;">TABLE</span> <span style="color: #0000ff;">eye_color</span>(eyes <span style="color: #228b22;">char</span>(8), empno <span style="color: #228b22;">int</span>) <span style="color: #a020f0;">PRIMARY</span> <span style="color: #a020f0;">KEY</span> (eyes, empno);
<span style="color: #a020f0;">CREATE</span> <span style="color: #a020f0;">TABLE</span> <span style="color: #0000ff;">hair_color</span>(hair <span style="color: #228b22;">char</span>(8), empno <span style="color: #228b22;">int</span>) <span style="color: #a020f0;">PRIMARY</span> <span style="color: #a020f0;">KEY</span> (hair, empno);
</pre>
</div>

<p>
我们就可以在建立两个码区间锁，一个是eye_color[blue, succeed_of_blue)，另一个是hair_color[red, succeed_of_red)，这就需要DAG锁支持。基于DAG的封锁协议粒度是：
</p>
<ul class="org-ul">
<li>从根到叶获取锁。</li>
<li>从叶到根释放锁。</li>
<li>要获取一个节点的S或IS锁，它的一个父节点必须拥有IS、IX、SIX、S、X锁之一。</li>
<li>要获取一个节点的X、U、SIX、IX锁，它的所有父节点必须拥有IX、SIX锁之一。</li>
</ul>

<p>
DAG和树的区别在于一个节点可以有多个父节点，因此在请求排他锁时，全部父节点必须首先被封锁。
</p>

<p>
上面都是对扁平事务的封锁进行的讨论。对于嵌套事务，子事务可以继承父事务的锁。当子事务结束后，父事务反向继承（anti-inherit）子事务的锁。当子事务执行COMMIT WORK语句时，封锁验证树上升到某个层次。这个树叫做事务家族树（transaction family tree）。如果锁被其他事务持有，在子事务请求封锁时，它必须判断：
</p>
<blockquote>
<p>
和持有锁的事务在同一个家族中吗？
</p>

<p>
如果是，它是子事务的祖先吗？
</p>

<p>
如果是，继承。
</p>

<p>
如果不是，等待，然后继承。
</p>

<p>
如果不是，等待。
</p>
</blockquote>

<p>
下面我们讨论锁的调度问题。锁管理程序是一个调度器，为了避免优先级翻转，锁管理程序需要和事务管理器一起，按照事务的优先级进行调度。采用FIFO方式调度的缺点在于可能引发护卫现象，即使用繁忙的锁成了分派列表。系统进程的执行受制于等待锁的情况。日志系统尤其容易产生“护卫”。解决护卫问题的方法有三种：
</p>
<ul class="org-ul">
<li>不再用FIFO方式调度。唤醒所有等待的进程，让调度-分派程序决定谁得到锁。</li>
<li>在多处理系统中使用自旋锁替代锁和信号量。</li>
<li>不允许持有热点锁的进程被强占。</li>
</ul>

<p>
锁的争夺后引发性能下降，下降的极限就是死锁：所有进程都没有执行。解决死锁的方法是对资源进行线性排列。有些系统要求程序事先声明对资源的最大需求，从而相应的调度作业。这种声明很多时候是悲观的。另一些系统允许死锁的发生，通过超时来检测死锁，并让死锁的事务回滚。根据事务对资源的申请可以构造一个等待图，节点是事务。如果有一条边从事务T指向T'，那么：
</p>
<ul class="org-ul">
<li>T等待T'占用的资源。</li>
<li>或T等待T'将要使用的资源。即二者在等待同一资源，且在等待队列中，T排在T'之后，并且二者的请求不相容。</li>
</ul>

<p>
如果等待图中出现了环，涉及的事务就会发生死锁。我们可以用锁的结构来建立等待图。每个锁有两个队列：持有者队列和等待者队列。两个队列具有相同的格式：&lt;&lt;t<sub>i</sub>,m<sub>i</sub>&gt;, &#x2026;&gt;，t<sub>i</sub>是事务，m<sub>i</sub>是锁类型。有了这两个队列，就可以得到事务之间的等待关系。通常还会建立一个事务等待队列，对每个事务，记录下当前等待的所有的锁。建立等待图的步骤如下：
</p>
<ul class="org-ul">
<li>假设G是持有锁的事务集合，W是等待队列。</li>
<li>对G中的每个g和W中的w，如果g和w不相容，将&lt;w,g&gt;加入图。</li>
<li>对W中的w和w'，如果w'在w之后，且w和w'不相容，将&lt;w',w&gt;加入图。</li>
</ul>


<p>
在分布式系统中，死锁的监测方式也是类似的，即在稀疏图中寻找环。区别在于锁必须和被保护的对象位于同一节点，锁不是分布式数据结构。要构建一个死锁检测程序，它必须了解每个资源管理器的等待图，并指定一个调度策略。这么做非常复杂，考虑到死锁发生的偶然性，大部分系统选择了简单的超时检测方法。
</p>


<p>
多数并发控制工作关注于减少事务冲突：即减少事务封锁的数据总量，以及封锁时间。字段调用（field call）是减少事务冲突最成功的方法。字段调用是对热点记录的一个操作，它由谓词和转换两部分组成，例如：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #a020f0;">UPDATE</span> inventory
<span style="color: #a020f0;">SET</span>    quantity = quantity - :delta
<span style="color: #a020f0;">WHERE</span>  item = :item
<span style="color: #a020f0;">AND</span>    quantity &gt;= :delta
</pre>
</div>

<p>
字段调用的语义如下：如果谓词存在，立即与当前的记录进行对照检查，检查时加短时间的共享锁。谓词检查完后立即释放锁。如果谓词为假，返回错误。如果谓词为真，调用产生一个REDO日志记录，在事务提交的时候执行。REDO日志包含了谓词和转换。在提交阶段1，检查事务所有延迟的REDO日志，对满足谓词的记录加共享锁，对转换涉及的记录加排他锁，并再次对谓词进行检查。如果谓词为假，回滚事务并返回谓词错误。如果谓词为真，在提交阶段2，执行每个转换并释放所有的锁。
</p>


<p>
将字段调用延迟的主要原因是有些操作没有对应的逆操作，因此，如果在事务提交时，由于其他事务的影响，谓词变为假，这时无法将事务恢复到初始状态。字段调用并非是万能的，对于串行号问题（serial number problem），字段调用就无能为力。串行号问题要求满足：
</p>
<ul class="org-ul">
<li>单调。</li>
<li>可读。</li>
<li>稠密。没有间隔。</li>
<li>回滚。</li>
<li>高吞吐量。</li>
</ul>
<p>
实际上，这样的方案是不存在的，比如方框某些条件。Oracle提供的序列号机制，就是放宽了对单调和稠密的限制。
</p>


<p>
乐观方法是和字段调用非常类似的一种方法，不同之处在于，乐观方法的谓词是“字段=旧值”，转换是“字段=新值”。时间戳模型是乐观方法的退化版本，每个记录包含一个时间戳，时间戳是谓词的一部分，谓词是“时间戳没有变”，而转换是“时间戳=当前时间”。
</p>


<p>
对并发控制的研究，除了字段调用之外，还产生了一个真正的新思想：不可变数据。就地更新（update in-place）的问题在于破坏了旧数据，丢失了对象的历史信息。一些提供将对象的历史也保存下来，每次建立一个新值。对象的地址为&lt;name, time&gt;，这种设计叫做时间域寻址（time domain addressing）、面向版本的系统（version-oriented system）或不可变对象（immutable object）。比如在Dave Reed系统中，每个对象都有一个时间序列，对象O的历史可以表示为：
</p>
<blockquote>
<p>
&lt;&lt;V0[t0,t1)&gt;,&lt;&lt;V1[t1,t2)&gt;,&lt;&lt;V2[t2,*)&gt;
</p>
</blockquote>
<p>
当时间在t0到t1之间时，对象具有值V0，在t1到t2时间，对象的值是V1，依此类推。每个事务也被分配了一个时间点。
</p>
</div>
</div>


<div id="outline-container-orge2031e2" class="outline-2">
<h2 id="orge2031e2">锁的实现</h2>
<div class="outline-text-2" id="text-orge2031e2">
<p>
锁管理程序通常采用细粒度封锁，一个信号量覆盖一个锁。锁管理程序通常是并发的，这么做的原因有三点，大部分操作系统采用抢占式调度，细粒度信号量可以减少优先级翻转产生的影响。其次锁管理程序通常运行在虚拟内存中，可能遇到缺页的情况。这时全部事务都会被阻塞，直到页请求被处理。第三，现代系统大多拥有多处理器，为了避免锁管理程序称为瓶颈，需要并发处理。
</p>


<p>
进程有两种方式共享内存，一种是在同一个地址空间中执行，另一种是在各自的地址空间中拥有共享段。每个进程有一个标识符，并发控制需要一个可以让进程进入等待状态的例程，以及一个唤醒其他进程的例程。这些基本函数如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">PID</span> = <span style="color: #228b22;">long</span>;
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Process</span> {
    <span style="color: #228b22;">PID</span> <span style="color: #a0522d;">pid</span>;
    <span style="color: #228b22;">PCB</span> *<span style="color: #a0522d;">sem_wait</span>;
};

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">PCB</span> = Process;

<span style="color: #228b22;">PID</span> <span style="color: #0000ff;">MyPID</span>(<span style="color: #228b22;">void</span>);
<span style="color: #228b22;">PCB</span>* <span style="color: #0000ff;">MyPCBP</span>(<span style="color: #228b22;">void</span>);
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">wait</span>(<span style="color: #228b22;">void</span>);
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">wakeup</span>(<span style="color: #228b22;">PCB</span>* <span style="color: #a0522d;">him</span>);
</pre>
</div>

<p>
唤醒其他进程的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">while</span> (<span style="color: #008b8b;">true</span>) {
    wakeup(him);  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21796;&#37266;&#20854;&#20182;&#36827;&#31243;</span>
    wait();       <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31561;&#24453;&#34987;&#21796;&#37266;</span>
}
</pre>
</div>


<p>
通过共享内存协调并行程序时，需要一种方法来同步。同步可以通过load-and-store指令完成。每个进程安排一个单元，每个进程设置自己的单元并轮询其他进程的单元。现代机器都支持load-and-store指令，比如位检验指令（bit-test-and-set）和比较并交换（compare-and-swap）指令。
</p>


<p>
位检验指令的逻辑如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">bool</span> <span style="color: #0000ff;">bit_test_and_set</span>(<span style="color: #228b22;">bit</span> <span style="color: #a0522d;">cell</span>) {
  <span style="color: #a020f0;">if</span> (cell == 0) {
    cell = 1;
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
  }
  <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
}
</pre>
</div>

<p>
比较并交换的逻辑如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">bool</span> <span style="color: #0000ff;">compare_and_swap</span>(<span style="color: #228b22;">int</span>* <span style="color: #a0522d;">cell</span>, <span style="color: #228b22;">int</span>* <span style="color: #a0522d;">old_value</span>, <span style="color: #228b22;">int</span>* <span style="color: #a0522d;">new_value</span>) {
  <span style="color: #a020f0;">if</span> (*cell == *old) {
    *cell = *new_value;
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
  }

  *old = *cell;
  <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
}
</pre>
</div>

<p>
下面两个例子展示了比较并交换指令的用途：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">increase_wrong</span>() {
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">tmp</span> = counter + 1;
  counter = tmp;  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21487;&#33021;&#20986;&#29616;&#26356;&#26032;&#20002;&#22833;&#12290;</span>
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">increase_right</span>() {
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">tmp</span> = counter;
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">new_value</span>;
  <span style="color: #a020f0;">do</span> {
    new_value = tmp + 1;
  } <span style="color: #a020f0;">while</span> (!compare_and_swap(&amp;counter, &amp;tmp, &amp;new_value));
}
</pre>
</div>

<p>
信号量是非常简单的锁，系统有一个get()例程可以获取信号量，一个give()例程用于将将信号置为空。信号量支持两种类型的锁：共享锁和排他锁。排他型信号量的锚点是一个进程链表。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">xsemaphore</span> = PCB*; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25490;&#20182;&#22411;&#20449;&#21495;&#37327;&#26159;&#19968;&#20010;&#36827;&#31243;&#38142;&#34920;&#65292;&#38142;&#34920;&#23614;&#37096;&#30340;&#36827;&#31243;&#25511;&#21046;&#30528;&#20449;&#21495;&#37327;&#65292;&#20854;&#20182;&#36827;&#31243;&#25353;&#29031;FIFO&#39034;&#24207;&#31561;&#24453;&#12290;</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">xsem_init</span>(<span style="color: #228b22;">xsemaphore</span>* <span style="color: #a0522d;">sem</span>) {
    sem = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #a020f0;">return</span>;
}

<span style="color: #b22222;">// </span><span style="color: #b22222;">&#33719;&#21462;&#20449;&#21495;&#37327;&#12290;&#23558;&#24403;&#21069;&#32447;&#31243;&#21152;&#20837;&#31561;&#24453;&#38431;&#21015;&#65292;&#22914;&#26524;&#38431;&#21015;&#20026;&#31354;&#65292;&#31435;&#21363;&#33719;&#24471;&#20449;&#21495;&#37327;&#12290;&#21542;&#21017;&#31561;&#24453;&#34987;&#21796;&#37266;&#12290;</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">xsem_get</span>(<span style="color: #228b22;">xsemaphore</span>* <span style="color: #a0522d;">sem</span>) {
    <span style="color: #228b22;">PCB</span>* <span style="color: #a0522d;">new_block</span> = my_pcbp();
    <span style="color: #228b22;">PCB</span>* <span style="color: #a0522d;">old_block</span> = <span style="color: #008b8b;">nullptr</span>;

    <span style="color: #a020f0;">do</span> {
        new_block-&gt;sem_wait = old_block;
    } <span style="color: #a020f0;">while</span> (!cas(sem, &amp;old, &amp;<span style="color: #a020f0;">new</span>));  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#23558;&#33258;&#24049;&#21152;&#20837;&#38431;&#21015;&#65292;&#22768;&#26126;&#33258;&#24049;&#35831;&#27714;&#20449;&#21495;&#37327;&#12290;</span>

    <span style="color: #a020f0;">if</span> (old_black != <span style="color: #008b8b;">nullptr</span>) {
        wait();  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#27809;&#26377;&#33719;&#24471;&#20449;&#21495;&#37327;&#65292;&#31561;&#24453;&#12290;</span>
    }
}

<span style="color: #b22222;">// </span><span style="color: #b22222;">&#37322;&#25918;&#20449;&#21495;&#37327;&#12290;&#23558;&#36827;&#31243;&#20174;&#38142;&#34920;&#23614;&#37096;&#31227;&#38500;&#12290;&#22914;&#26524;&#26377;&#20854;&#20182;&#36827;&#31243;&#22312;&#31561;&#24453;&#20449;&#21495;&#37327;&#65292;&#21796;&#37266;&#36825;&#20010;&#36827;&#31243;&#12290;</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">xsem_give</span>(<span style="color: #228b22;">xsemphore</span>* <span style="color: #a0522d;">sem</span>) {
    <span style="color: #228b22;">PCB</span>* <span style="color: #a0522d;">new_block</span> = <span style="color: #008b8b;">nullptr</span>;
    <span style="color: #228b22;">PCB</span>* <span style="color: #a0522d;">old_block</span> = my_pcbp();

    <span style="color: #a020f0;">if</span> (cas(sem, &amp;old_block, &amp;new_block)) {
        <span style="color: #a020f0;">return</span>;
    }

    <span style="color: #a020f0;">while</span> (old_block-&gt;sem_wait != my_pcbp()) {
        old_block = old_block-&gt;sem_wait;
    }
    old_block-&gt;sem_wait = <span style="color: #008b8b;">nullptr</span>;
    wakeup(old_block);
}
</pre>
</div>

<p>
函数xsem_give()的不变量是：“由信号量指向的进程链表只在头部增长，拥有信号量的进程在尾部”。为了避免护卫问题，xsem_give()可以简单的释放信号量，并唤醒全部进程，这时，每个进程必须重新执行xsem_get()：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">xsem_get</span>(<span style="color: #228b22;">xsemaphore</span> *<span style="color: #a0522d;">sem</span>) {
    <span style="color: #228b22;">PCB</span>* <span style="color: #a0522d;">new_pcb</span> = my_pcbp();
    <span style="color: #228b22;">PCB</span>* <span style="color: #a0522d;">old_pcb</span> = <span style="color: #008b8b;">nullptr</span>;

    <span style="color: #a020f0;">do</span> {
        new_pcb-&gt;sem_wait = old_pcb;
    } <span style="color: #a020f0;">while</span> (!cas(sem, &amp;old_pcb, &amp;new_pcb));

    <span style="color: #a020f0;">if</span> (old != <span style="color: #008b8b;">nullptr</span>) {
        wait();
        xsem_get(sem);  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21796;&#37266;&#21518;&#37325;&#26032;&#35831;&#27714;&#20449;&#21495;&#37327;</span>
    }
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">xsem_give</span>(<span style="color: #228b22;">xsemaphore</span>* <span style="color: #a0522d;">sem</span>) {
    <span style="color: #228b22;">PCB</span>* <span style="color: #a0522d;">old_pcb</span> = my_pcbp();
    <span style="color: #228b22;">PCB</span>* <span style="color: #a0522d;">new_pcb</span> = <span style="color: #008b8b;">nullptr</span>;

    <span style="color: #a020f0;">while</span> (!cas(sem, &amp;old_pcb, &amp;new_pcb)) {}  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#23558;&#31561;&#24453;&#21015;&#34920;&#28165;&#31354;</span>
    <span style="color: #a020f0;">while</span> (old_pcb != my_pcbp()) {            <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21796;&#37266;&#20840;&#37096;&#31561;&#24453;&#36827;&#31243;</span>
        new_pcb = old-&gt;sem_wait;
        old_pcb-&gt;sem_wait = <span style="color: #008b8b;">nullptr</span>;
        wakeup(old_pcb);
        old_pcb = new_pcb;
    }
}
</pre>
</div>

<p>
通常一个数据结构由一些通过指针连接在一起节点组成。在并发遍历这样的结构时，必须保证每个指针的稳定，不能在遍历下一个对象之前发生变化。当然最简单的方法是用信号量覆盖整个数据结构，但是这么做，系统性能会大幅下降，以至于几乎不可用。
</p>


<p>
下面是共享信号量的代码：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">Lock_mode</span> {
    <span style="color: #a0522d;">free</span>, <span style="color: #a0522d;">s</span>, <span style="color: #a0522d;">x</span>, <span style="color: #a0522d;">u</span>, <span style="color: #a0522d;">is</span>, <span style="color: #a0522d;">ix</span>, <span style="color: #a0522d;">six</span>, <span style="color: #a0522d;">wait</span>;
};

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">lock_mode</span> = <span style="color: #228b22;">int</span>;

<span style="color: #b22222;">// </span><span style="color: #b22222;">&#20849;&#20139;&#38145;&#21644;&#25490;&#20182;&#38145;</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">semaphore</span> {
    <span style="color: #228b22;">lock_mode</span> <span style="color: #a0522d;">mode</span>;      <span style="color: #b22222;">// </span><span style="color: #b22222;">&#38145;&#30340;&#31867;&#22411;</span>
    <span style="color: #228b22;">int</span>       <span style="color: #a0522d;">count</span>;     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25480;&#20104;&#30340;&#36827;&#31243;&#25968;</span>
    <span style="color: #228b22;">PCB</span>*      <span style="color: #a0522d;">wait_list</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31561;&#24453;&#36827;&#31243;&#38431;&#21015;</span>
};

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">sem_init</span>(<span style="color: #228b22;">semaphore</span>* <span style="color: #a0522d;">sem</span>) {
    sem-&gt;mode = <span style="color: #008b8b;">Lock_mode</span>::free;
    sem-&gt;count = 0;
    sem-&gt;wait_list = <span style="color: #008b8b;">nullptr</span>;
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">sem_get</span>(<span style="color: #228b22;">semaphore</span>* <span style="color: #a0522d;">sem</span>, <span style="color: #228b22;">lock_mode</span> <span style="color: #a0522d;">mode</span>) {
    <span style="color: #228b22;">semaphore</span> <span style="color: #a0522d;">new_sem</span>;
    <span style="color: #228b22;">semaphore</span> <span style="color: #a0522d;">old_sem</span>;
    <span style="color: #228b22;">PCB</span>* <span style="color: #a0522d;">me</span> = my_pcbp();

    <span style="color: #a020f0;">while</span> (<span style="color: #008b8b;">true</span>) {
        old_sem = { <span style="color: #008b8b;">LockMode</span>::free, 0, <span style="color: #008b8b;">nullptr</span> };
        new_sem = { mode, 1, <span style="color: #008b8b;">nullptr</span> };
        <span style="color: #a020f0;">if</span> (csd(sem, &amp;old_sem, &amp;new_sem)) {
            <span style="color: #b22222;">// </span><span style="color: #b22222;">&#22914;&#26524;&#20449;&#21495;&#37327;&#31354;&#38386;&#65292;&#33719;&#24471;&#20449;&#21495;&#37327;&#24182;&#36820;&#22238;&#12290;</span>
            <span style="color: #a020f0;">return</span>;
        }

        <span style="color: #a020f0;">while</span> ((mode == <span style="color: #008b8b;">LockMode</span>::s) &amp;&amp;
               (old_sem.mode == <span style="color: #008b8b;">LockMode</span>::s) &amp;&amp;
               (old_sem.wait_list == <span style="color: #008b8b;">nullptr</span>)) {
            new_sem.count = old_sem.count + 1;
            <span style="color: #a020f0;">if</span> (csd(sem, &amp;old, &amp;<span style="color: #a020f0;">new</span>)) {
                <span style="color: #b22222;">// </span><span style="color: #b22222;">&#22914;&#26524;&#27492;&#26102;&#20449;&#21495;&#37327;&#24050;&#32463;&#21152;&#20102;&#20849;&#20139;&#38145;&#65292;&#24182;&#19988;&#27809;&#26377;&#31561;&#24453;&#38431;&#21015;&#65292;&#31435;&#21363;&#33719;&#24471;&#20849;&#20139;&#38145;&#24182;&#36820;&#22238;&#12290;</span>
                <span style="color: #a020f0;">return</span>;
            }
        }

        new_sem.mode = <span style="color: #008b8b;">LockMode</span>::wait;
        new_sem.count = old_sem.count;
        new_sem.wati_list = me;
        me-&gt;sem_wait = old_sem.wait_list;

        <span style="color: #b22222;">// </span><span style="color: #b22222;">&#23581;&#35797;&#21152;&#20837;&#31561;&#24453;&#38431;&#21015;&#12290;</span>
        <span style="color: #a020f0;">if</span> (csd(sem, &amp;old_sem, &amp;new_sem)) {
            <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31561;&#24453;&#21035;&#21796;&#37266;</span>
            wait();
        }
        <span style="color: #b22222;">// </span><span style="color: #b22222;">&#22914;&#26524;&#21152;&#20837;&#31561;&#24453;&#38431;&#21015;&#22833;&#36133;&#65292;&#37325;&#26032;&#24320;&#22987;&#12290;</span>
    }
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">sem_give</span>(<span style="color: #228b22;">semaphore</span>* <span style="color: #a0522d;">sem</span>) {
    <span style="color: #228b22;">semaphore</span> <span style="color: #a0522d;">new_sem</span> = { <span style="color: #008b8b;">LockMode</span>::free, 0, <span style="color: #008b8b;">nullptr</span> };
    <span style="color: #228b22;">semaphore</span> <span style="color: #a0522d;">old_sem</span> = { <span style="color: #008b8b;">LockMode</span>::s, 1, <span style="color: #008b8b;">nullptr</span> };
    <span style="color: #228b22;">PCB</span>* <span style="color: #a0522d;">him</span>;
    <span style="color: #228b22;">PCB</span>* <span style="color: #a0522d;">next</span>;

    <span style="color: #a020f0;">if</span> (csd(sem, &amp;old_sem, &amp;new_sem)) {
        <span style="color: #a020f0;">return</span>;
    }

    <span style="color: #a020f0;">do</span> {
        <span style="color: #a020f0;">if</span> (old_sem.count &gt; 1) {
            new_sem = { <span style="color: #008b8b;">LockMode</span>::s, old_sem.count - 1, old_sme.wait_list };
        } <span style="color: #a020f0;">else</span> {
            new_sem = { <span style="color: #008b8b;">LockMode</span>::free, 0, <span style="color: #008b8b;">nullptr</span> };
        }
    } <span style="color: #a020f0;">while</span> (!csd(sem, &amp;old_sem, &amp;new_em));

    <span style="color: #a020f0;">if</span> (old_sem.count == 1) {
        him = old_sem.wait_list;
        <span style="color: #a020f0;">while</span> (him != <span style="color: #008b8b;">nullptr</span>) {
            next = him-&gt;sem_wait;
            him-&gt;sem_wait = <span style="color: #008b8b;">nullptr</span>;
            wakeup(him);
            him = next;
        }
    }
}
</pre>
</div>

<p>
标准的快速分配存储的方法是预先分配一个存储区块池，每个都有固定的长度。池中的空闲块由一个锚定在头部的链表连接。信号量可以从存储池中分配和释放：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">block</span> {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">block</span>* <span style="color: #a0522d;">next</span>;
    <span style="color: #228b22;">void</span>* <span style="color: #a0522d;">stuff</span>;
};

<span style="color: #a020f0;">static</span> <span style="color: #228b22;">block</span>* <span style="color: #a0522d;">free</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31354;&#38386;&#38142;&#34920;&#12290;</span>

<span style="color: #228b22;">block</span>* <span style="color: #0000ff;">bad_get_block</span>() {
    <span style="color: #228b22;">block</span>* <span style="color: #a0522d;">new_block</span>;
    <span style="color: #228b22;">block</span>* <span style="color: #a0522d;">old_block</span> = free;
    <span style="color: #a020f0;">do</span> {
        <span style="color: #a020f0;">if</span> (old_block == <span style="color: #008b8b;">nullptr</span>) {
            panic();
        }

        new_block = old_block-&gt;next;
    } <span style="color: #a020f0;">while</span> (!cas(&amp;free, &amp;old_block, &amp;new_block));

    <span style="color: #a020f0;">return</span> old_block;
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">give_block</span>(<span style="color: #228b22;">block</span>* <span style="color: #a0522d;">free_it</span>) {
    <span style="color: #228b22;">block</span>* <span style="color: #a0522d;">new_block</span> = free_it;
    <span style="color: #228b22;">block</span>* <span style="color: #a0522d;">old_block</span> = free;
    <span style="color: #a020f0;">do</span> {
        new_block-&gt;next = old_block;
    } <span style="color: #a020f0;">while</span> (!cas(&amp;free, &amp;old_block, &amp;new_block));
}
</pre>
</div>

<p>
在上面的代码中，bad_get_block()存在缺陷。我们回顾一下cas的不变量：
</p>
<blockquote>
<p>
如果free == old_block, 那么空闲链表中old_block的下一块是new_block。
</p>
</blockquote>
<p>
我们考虑一下这种情况：
</p>
<blockquote>
<p>
初始：free-&gt;1-&gt;2-&gt;3
</p>

<p>
1和2被分配：free-&gt;3
</p>

<p>
1被释放：free-&gt;1-&gt;3
</p>

<p>
此时free指向1，但是1已经指向3，而不是2。
</p>
</blockquote>

<p>
为了避免这种情况，可已将PCB指针和block指针放在一起，使用双字的csd来操作：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">freelist</span> {
    <span style="color: #228b22;">PCB</span>* <span style="color: #a0522d;">kilroy</span>;
    <span style="color: #228b22;">block</span>* <span style="color: #a0522d;">free</span>;
};

<span style="color: #a020f0;">static</span> <span style="color: #228b22;">freelist</span> <span style="color: #a0522d;">free</span>;
<span style="color: #228b22;">block</span>* <span style="color: #0000ff;">get_block</span>() {
    <span style="color: #228b22;">freelist</span> <span style="color: #a0522d;">new_list</span>;
    <span style="color: #228b22;">freelist</span> <span style="color: #a0522d;">old_list</span>;

    <span style="color: #a020f0;">do</span> {
        free.kilroy = old_list.kilroy = new_list.kilroy = my_pid();
        old_list.free = free.free;
        <span style="color: #a020f0;">if</span> (old_list.free == <span style="color: #008b8b;">nullptr</span>) {
            panic();
        }
        new_list.free = old_list.free-&gt;next;
    } <span style="color: #a020f0;">while</span> (!csd(&amp;free, &amp;old_list, &amp;new_list));

    <span style="color: #a020f0;">return</span> old_list.free;
}
</pre>
</div>
<p>
在get_block()中，不变量是：
</p>
<blockquote>
<p>
如果kilroy等于my_pid()，链表将不会改变。
</p>
</blockquote>

<p>
如果一个进程在持有信号量的时候失败了，信号量所保护的数据结构是不可信的，这时需要重启子系统，进而引起事务失败和系统恢复。
</p>
</div>

<div id="outline-container-orgff128f2" class="outline-3">
<h3 id="orgff128f2">锁管理程序</h3>
<div class="outline-text-3" id="text-orgff128f2">
<p>
锁记录了当前对每个具名资源的请求，并调度对这些资源的存取。每个锁都有一个名字：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Lock_name</span> {
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">rmid</span>;
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">resource</span>[14];
};
</pre>
</div>
<p>
资源管理器通常会将对象名经过压缩或散列得到一个简称，以此作为锁的名字。如果两个对象具有相同的简称，就可能造成伪等待。大部分锁是空闲的，而于非空闲的锁会保留两个列表，一个记录已经授予锁的事务，叫做授予组（granted group），另一个是等待锁的事务列表，叫做等待组（waiting group）。传统的调度策略是FIFO，将新事务放在等待组的末尾。授予组中有一个概括类型，就是组中锁类型最大的那个。如果一个事务申请锁，它的锁类型与概率类型相容，并且等待组为空，这个事务可以立即获得锁。锁转换允许事务首先持有一个锁，然后对同一个对象申请另一种类型的锁，锁转换将选择类型最大值。比如事务已经持有IX锁，再申请S锁，将会得到一个SIX锁。
</p>

<p>
锁转换不需要同概括类型相容，但必须和授权组内的其他锁类型相容。如果有不相容的情况，事务必须等待，这时授予组不得接受新成员。锁转换矩阵如下：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">授予类型</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">请求类型</td>
<td class="org-left">-</td>
<td class="org-left">IS</td>
<td class="org-left">IX</td>
<td class="org-left">S</td>
<td class="org-left">SIX</td>
<td class="org-left">U</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-left">IS</td>
<td class="org-left">IS</td>
<td class="org-left">IS</td>
<td class="org-left">IX</td>
<td class="org-left">S</td>
<td class="org-left">SIX</td>
<td class="org-left">U</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-left">IX</td>
<td class="org-left">IX</td>
<td class="org-left">IX</td>
<td class="org-left">IX</td>
<td class="org-left">SIX</td>
<td class="org-left">SIX</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-left">S</td>
<td class="org-left">S</td>
<td class="org-left">S</td>
<td class="org-left">SIX</td>
<td class="org-left">S</td>
<td class="org-left">SIX</td>
<td class="org-left">U</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-left">SIX</td>
<td class="org-left">SIX</td>
<td class="org-left">SIX</td>
<td class="org-left">SIX</td>
<td class="org-left">SIX</td>
<td class="org-left">SIX</td>
<td class="org-left">SIX</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-left">U</td>
<td class="org-left">U</td>
<td class="org-left">U</td>
<td class="org-left">X</td>
<td class="org-left">U</td>
<td class="org-left">SIX</td>
<td class="org-left">U</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
</tr>
</tbody>
</table>


<p>
下面我们来考察锁类和锁计数的概念。锁类是锁长度的推广：
</p>

<p>
立即锁。只被瞬间持有的锁。
短锁。某个特定操作结束后释放。
中锁。显式释放，如用于游标稳定的共享锁。
长锁。在事务提交时释放。
特长锁。跨事务的锁。
</p>

<p>
和锁转换一样，锁的类也可以升级（class escalation），一个短锁可以变成长锁。锁类的定义如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #228b22;">lock_class</span> = <span style="color: #228b22;">int</span>;
<span style="color: #a020f0;">class</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">Lock_class</span> {
    <span style="color: #a0522d;">instant_lock</span>, <span style="color: #a0522d;">short_lock</span>, <span style="color: #a0522d;">medium_lock</span>, <span style="color: #a0522d;">long_lock</span>, <span style="color: #a0522d;">very_long_lock</span>;
}
</pre>
</div>

<p>
另一个概念是锁计数。资源管理器可以对一个对象加若干次锁。锁管理程序把一条记录上锁的次数记录下来。
</p>


<p>
下面我们来看锁管理程序的接口和数据结构。最重要的结构是锁散列表，它的表项有一个指向锁链的指针，每个锁由一个映射到该散列桶的名字。对锁链和锁名域的访问由桶上的排他信号量保护。空闲锁以空缺（not found）的形式表现。已经分配的锁有一个结构叫做锁头，它包含锁名、指向下一个锁头的指针、一个排他信号量和一些其他信息。锁包含锁请求列表，列表里包含了请求的描述信息（所有者、类型、长度等）。此外，锁管理程序还维护了一个事务锁列表，记录了被事务持有的锁。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">class</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">Lock_reply</span> {
    <span style="color: #a0522d;">Ok</span>, <span style="color: #a0522d;">Timeout</span>, <span style="color: #a0522d;">Dead_lock</span>, <span style="color: #a0522d;">Not_locked</span>;
};

<span style="color: #a020f0;">using</span> <span style="color: #228b22;">Lock_reply</span> = <span style="color: #228b22;">int</span>;
<span style="color: #228b22;">Lock_reply</span> <span style="color: #0000ff;">lock</span>(<span style="color: #228b22;">Lock_name</span> <span style="color: #a0522d;">name</span>, <span style="color: #228b22;">Lock_mode</span> <span style="color: #a0522d;">mode</span>, <span style="color: #228b22;">Lock_class</span> <span style="color: #a0522d;">lock_class</span>, <span style="color: #228b22;">long</span> <span style="color: #a0522d;">timeout</span>);
<span style="color: #228b22;">Lock_reply</span> <span style="color: #0000ff;">unlock</span>(<span style="color: #228b22;">Lock_name</span> <span style="color: #a0522d;">name</span>);
<span style="color: #228b22;">Lock_reply</span> <span style="color: #0000ff;">unlock_class</span>(<span style="color: #228b22;">Lock_class</span> <span style="color: #a0522d;">lock_class</span>, <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">all_le</span>, <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">rmid</span>);

<span style="color: #a020f0;">static</span> <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">max_hash</span> = 97;
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Lock_hash_entry</span> {
    <span style="color: #228b22;">xsemaphore</span> <span style="color: #a0522d;">xsem</span>;
    <span style="color: #228b22;">Lock_head</span>* <span style="color: #a0522d;">chain</span>;
};

<span style="color: #228b22;">Lock_hash_entry</span> <span style="color: #a0522d;">lock_hash</span>[max_hash];

<span style="color: #228b22;">long</span> <span style="color: #0000ff;">lock_hash</span>(<span style="color: #228b22;">Lock_name</span> <span style="color: #a0522d;">name</span>);

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Lock_head</span> {
    <span style="color: #228b22;">xsemaphore</span> <span style="color: #a0522d;">xsem</span>;
    <span style="color: #228b22;">Lock_head</span>* <span style="color: #a0522d;">chain</span>;
    <span style="color: #228b22;">Lock_name</span> <span style="color: #a0522d;">name</span>;
    <span style="color: #228b22;">Lock_request</span>* <span style="color: #a0522d;">queue</span>;
    <span style="color: #228b22;">Lock_mode</span> <span style="color: #a0522d;">granted_mode</span>;
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">waiting</span>;
};

<span style="color: #228b22;">Lock_head</span>* <span style="color: #0000ff;">lock_head_get</span>(<span style="color: #228b22;">Lock_name</span> <span style="color: #a0522d;">name</span>, <span style="color: #228b22;">Lock_mode</span> <span style="color: #a0522d;">mode</span>);
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">lock_head_give</span>(<span style="color: #228b22;">Lock_head</span>* <span style="color: #a0522d;">it</span>);

<span style="color: #a020f0;">class</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">Lock_status</span> {
    <span style="color: #a0522d;">granted</span>, <span style="color: #a0522d;">converting</span>, <span style="color: #a0522d;">waiting</span>, <span style="color: #a0522d;">denied</span>;
};

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Lock_request</span> {
    <span style="color: #228b22;">Lock_request</span>* <span style="color: #a0522d;">queue</span>;
    <span style="color: #228b22;">Lock_head</span>* <span style="color: #a0522d;">head</span>;
    <span style="color: #228b22;">Lock_status</span> <span style="color: #a0522d;">status</span>;
    <span style="color: #228b22;">Lock_mode</span> <span style="color: #a0522d;">mode</span>;
    <span style="color: #228b22;">Lock_mode</span> <span style="color: #a0522d;">convert_mode</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">count</span>;
    <span style="color: #228b22;">Lock_class</span> <span style="color: #a0522d;">lock_class</span>;
    <span style="color: #228b22;">PCB</span>* <span style="color: #a0522d;">process</span>;
    <span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">tran</span>;
    <span style="color: #228b22;">Lock_request</span>* <span style="color: #a0522d;">tran_prev</span>;
    <span style="color: #228b22;">Lock_request</span>* <span style="color: #a0522d;">tran_next</span>;
};

<span style="color: #228b22;">Lock_request</span>* <span style="color: #0000ff;">lock_request_get</span>(<span style="color: #228b22;">Lock_head</span>*, <span style="color: #228b22;">Lock_mode</span>, <span style="color: #228b22;">Lock_class</span>);
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">Lock_request_give</span>(<span style="color: #228b22;">Lock_request</span>* <span style="color: #a0522d;">it</span>);
</pre>
</div>

<p>
每个事务都有一个描述符，事务锁列表锚定在这个描述符中：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">TransCB</span> {
    <span style="color: #228b22;">Lock_request</span>* <span style="color: #a0522d;">locks</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20107;&#21153;&#38145;&#21015;&#34920;</span>
    <span style="color: #228b22;">Lock_request</span>* <span style="color: #a0522d;">wait</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31561;&#24453;&#30340;&#38145;</span>
    <span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">cycle</span>;      <span style="color: #b22222;">// </span><span style="color: #b22222;">&#29992;&#20110;&#26816;&#27979;&#27515;&#38145;</span>
    <span style="color: #228b22;">void</span>* <span style="color: #a0522d;">stuff</span>;
};

<span style="color: #228b22;">TransCB</span>* <span style="color: #0000ff;">my_transcbp</span>();
</pre>
</div>

<p>
下面是一个简单的lock()例程：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b22222;">// </span><span style="color: #b22222;">&#19981;&#22788;&#29702;&#36716;&#25442;&#12289;&#31435;&#21363;&#38145;&#21644;&#36890;&#30693;&#38145;&#12290;</span>
<span style="color: #228b22;">Lock_reply</span> <span style="color: #0000ff;">lock</span>(<span style="color: #228b22;">Lock_name</span> <span style="color: #a0522d;">name</span>, <span style="color: #228b22;">Lock_mode</span> <span style="color: #a0522d;">mode</span>, <span style="color: #228b22;">Lock_class</span> <span style="color: #a0522d;">lock_class</span>, <span style="color: #228b22;">long</span> <span style="color: #a0522d;">timeout</span>) {
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">bucket</span>;
    <span style="color: #228b22;">Lock_head</span>* <span style="color: #a0522d;">lock</span>;
    <span style="color: #228b22;">Lock_request</span>* <span style="color: #a0522d;">request</span>;
    <span style="color: #228b22;">Lock_request</span>* <span style="color: #a0522d;">last</span>;
    <span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">me</span> = my_trancCBP();
    <span style="color: #228b22;">Lock_reply</span> <span style="color: #a0522d;">error</span>;

    bucket = lockhash(name);
    xsem_get(&amp;lock_hash[bucket].xsem);
    lock = lock_hash[bucket].chain;
    <span style="color: #a020f0;">while</span> ((lock != <span style="color: #008b8b;">nullptr</span>) &amp;&amp; (lock-&gt;name != name)) {
        lock = lock-&gt;chain;
    }

    <span style="color: #a020f0;">if</span> (lock == <span style="color: #008b8b;">nullptr</span>) {
        lock = lock_head_get(name, mode);
        lock-&gt;queue = lock_request_get(lock, mode, lock_class);
        lock-&gt;chain = lock_hash[bucket].chain;
        lock_hash[bucket].chain = lock;
        xsem_give(&amp;lock_hash[bucket].xsem);
        <span style="color: #a020f0;">return</span> LOCK_OK;
    }

    xsem_get(&amp;lock-&gt;xsem);
    xsem_give(&amp;lock_hash[bucket].xsem);
    <span style="color: #a020f0;">for</span> (request = lock-&gt;queue; request != <span style="color: #008b8b;">nullptr</span>; request = request-&gt;queue) {
        <span style="color: #a020f0;">if</span> (request-&gt;tran == me) {
            <span style="color: #a020f0;">break</span>;
        }

        last = request;
    }

    <span style="color: #a020f0;">if</span> (request == <span style="color: #008b8b;">nullptr</span>) {
        request = lock_request_get(lock, mode, lock_class);
        last-&gt;queue = request;
        <span style="color: #a020f0;">if</span> ((!lock-&gt;waiting) &amp;&amp; lock_compat(mode, lock-&gt;granted_mode)) {
            lock-&gt;granted_mode = lock_max(mode, lock-&gt;granted_mode);
            xsem_give(&amp;lock-&gt;xsem);
            <span style="color: #a020f0;">return</span> LOCK_OK;
        } <span style="color: #a020f0;">else</span> {
            lock-&gt;waiting = <span style="color: #008b8b;">true</span>;
            request-&gt;status = LockWaiting;
            xsem_give(&amp;lock-&gt;xsem);
            wait(timeout);
            error = request-&gt;status;
            <span style="color: #a020f0;">if</span> (error == LockGranted) {
                <span style="color: #a020f0;">return</span> LockOk;
            }

            <span style="color: #a020f0;">if</span> (error == LockWaiting) {
                error = LockTimeout;
            }

            request-&gt;lock_class = LockInstant;
            unlock(name);
            <span style="color: #a020f0;">return</span> error;
        }
    } <span style="color: #a020f0;">else</span> {
        <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21516;&#19968;&#20107;&#21153;&#20877;&#27425;&#35831;&#27714;&#38145;&#65292;&#26242;&#26102;&#30053;&#36807;&#12290;</span>
    }
}

<span style="color: #228b22;">Lock_reply</span> <span style="color: #0000ff;">unlock</span>(<span style="color: #228b22;">Lock_name</span> <span style="color: #a0522d;">name</span>) {
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">bucket</span>;
    <span style="color: #228b22;">Lock_head</span>* <span style="color: #a0522d;">lock</span>;
    <span style="color: #228b22;">Lock_head</span>* <span style="color: #a0522d;">prev</span> = <span style="color: #008b8b;">nullptr</span>;
    <span style="color: #228b22;">Lock_request</span>* <span style="color: #a0522d;">request</span>;
    <span style="color: #228b22;">Lock_request</span>* <span style="color: #a0522d;">prev_req</span> = <span style="color: #008b8b;">nullptr</span>;
    <span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">me</span> = my_transcbp();
    <span style="color: #228b22;">Lock_reply</span> <span style="color: #a0522d;">status</span>;

    bucket = lockhash(name);
    xsem_get(&amp;lock_hash[bucket].xsem);
    lock = lock_hash[bucket].chain;
    <span style="color: #a020f0;">while</span> ((lock != <span style="color: #008b8b;">nullptr</span>) &amp;&amp; (lock-&gt;name != name)) {
        prev = lock;
        lock = lock-&gt;chain;
    }

    <span style="color: #a020f0;">if</span> (lock == <span style="color: #008b8b;">nullptr</span>) {
        <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">B</span>;
    }

    xsem_get(&amp;lock-&gt;xsem);
    <span style="color: #a020f0;">for</span> (request = lock-&gt;chain; request != <span style="color: #008b8b;">nullptr</span>; request = request-&gt;queue) {
        <span style="color: #a020f0;">if</span> (request-&gt;tran == me) {
            <span style="color: #a020f0;">break</span>;
        }

        prev_req = request;
    }

    <span style="color: #a020f0;">if</span> (request == <span style="color: #008b8b;">nullptr</span>) {
        <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">A</span>;
    }

    <span style="color: #a020f0;">if</span> (request-&gt;lock_class &gt;= LOCK_LONG || request-&gt;count &gt; 1) {
        request-&gt;count = request-&gt;count - 1;
        <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">A</span>;
    }

    <span style="color: #a020f0;">if</span> (lock-&gt;queue == request &amp;&amp; request-&gt;queue == <span style="color: #008b8b;">nullptr</span>) {
        <span style="color: #a020f0;">if</span> (prev == <span style="color: #008b8b;">nullptr</span>) {
            lock_hash[bucket].chain = lock-&gt;chain;
        } <span style="color: #a020f0;">else</span> {
            prev-&gt;chain = lock-&gt;chain;
        }

        lock_head_give(lock);
        lock_request_give(request);
        <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">B</span>;
    }

    <span style="color: #a020f0;">if</span> (prev_req != null) {
        prev_req-&gt;queue = request-&gt;queue;
    } <span style="color: #a020f0;">else</span> {
        lock-&gt;queue = request-&gt;queue;
    }
    lock_request_give(request);
    lock-&gt;waiting = <span style="color: #008b8b;">false</span>;
    lock-&gt;granted_mode = LOCK_FREE;

    <span style="color: #a020f0;">for</span> (request = lock-&gt;queue; request != <span style="color: #008b8b;">nullptr</span>; request = request-&gt;queue) {
        <span style="color: #a020f0;">if</span> (request-&gt;status == Lock_granted) {
            lock-&gt;granted_mode = lock_max(request-&gt;mode, lock-&gt;granted_mode);
        } <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (request-&gt;status == Lock_waiting) {
            <span style="color: #a020f0;">if</span> (lock_compat(request-&gt;mode, lock-&gt;granted_mode)) {
                request-&gt;status = Lock_granted;
                lock-&gt;granted_mode = lock_max(request-&gt;mode, lock-&gt;granted_mode);
                wakeup(request-&gt;process);
            } <span style="color: #a020f0;">else</span> {
                lock-&gt;waiting = <span style="color: #008b8b;">true</span>;
                <span style="color: #a020f0;">break</span>;
            }
        } <span style="color: #a020f0;">else</span> {
            <span style="color: #b22222;">// </span><span style="color: #b22222;">&#22788;&#29702;&#31561;&#24453;&#36716;&#25442;&#65292;&#24573;&#30053;</span>
        }
    }

 <span style="color: #008b8b;">A</span>: xsem_give(&amp;lock-&gt;xsem);
 <span style="color: #008b8b;">B</span>: xsem_give(&amp;lock_hash[bucket].xsem);
    <span style="color: #a020f0;">return</span> Lock_OK;
}
</pre>
</div>

<p>
锁的升级需要锁管理程序和资源管理器协商处理，下面是一个示例。资源管理器记录事务申请的各类锁的计数，如果达到了上线，新的申请将被拒绝，并返回一个“需要升级锁”错误。资源管理器枚举事务所有的锁，找到可以覆盖它们的一个粗粒度锁，对粗粒度锁加锁，然后释放细粒度锁。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Buffer</span> {
    <span style="color: #228b22;">lock_name</span> <span style="color: #a0522d;">name</span>;
    <span style="color: #228b22;">lock_mode</span> <span style="color: #a0522d;">mode</span>;
} <span style="color: #a0522d;">buffer</span>[ESCALATION_LIMIT];  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#35760;&#24405;&#20107;&#21153;&#25345;&#26377;&#30340;&#38145;</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">locks</span>(rmid, trid, count, buffer);

<span style="color: #228b22;">lock_reply</span> <span style="color: #0000ff;">unlock_class</span>(<span style="color: #228b22;">lock_class</span> <span style="color: #a0522d;">lock_class</span>, <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">all_le</span>, <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">rmid</span>) {
    <span style="color: #228b22;">lock_head</span>* <span style="color: #a0522d;">lock</span>;
    <span style="color: #228b22;">lock_request</span>* <span style="color: #a0522d;">request</span>;
    <span style="color: #228b22;">lock_request</span>* <span style="color: #a0522d;">next</span>;

    <span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">me</span> = my_trans_cb();
    <span style="color: #a020f0;">for</span> (request = me-&gt;locks; request != <span style="color: #008b8b;">nullptr</span>; request = next) {
        next = request-&gt;tran_next;
        lock = request-&gt;head;
        <span style="color: #a020f0;">if</span> (request-&gt;lock_class == lock_class || (request-&gt;lock_class &lt; lock_class  &amp;&amp; all_le)) {
            <span style="color: #a020f0;">if</span> (rmid == 0 || lock-&gt;name.rmid == rmid) {
                request-&gt;lock_class = Lock_INSTANT;
                request-&gt;count = 1;
                unlock(lock-&gt;name);
            }
        }
    }
}
</pre>
</div>

<p>
下面是一个简单的局部死锁检查程序：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">TransCB</span> {
    <span style="color: #228b22;">lock_request</span>* <span style="color: #a0522d;">locks</span>;
    <span style="color: #228b22;">lock_request</span>* <span style="color: #a0522d;">wait</span>;
    <span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">cycle</span>;
};

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">visit</span>(<span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">me</span>) {
    <span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">him</span>;
    <span style="color: #228b22;">lock_request</span> *<span style="color: #a0522d;">them</span>;

    <span style="color: #a020f0;">if</span> (me-&gt;wait == <span style="color: #008b8b;">nullptr</span>) {
        <span style="color: #a020f0;">return</span>;
    }
    them = ((me-&gt;wait)-&gt;head)-&gt;queue;
    <span style="color: #a020f0;">while</span> (them-&gt;tran != me) {
        <span style="color: #a020f0;">if</span> (!compat(them-&gt;mode, me-&gt;wait-&gt;mode) || them-&gt;status != Granted) {
            him = them-&gt;tran;
            me-&gt;cycle = him;
            <span style="color: #a020f0;">if</span> (him-&gt;cycle != <span style="color: #008b8b;">nullptr</span>) {
                <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21457;&#29983;&#27515;&#38145;</span>
            } <span style="color: #a020f0;">else</span> {
                visit(him);
            }
            me-&gt;cycle = <span style="color: #008b8b;">nullptr</span>;
            them = them-&gt;queue;
        }
    }
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">deadlock</span>() {
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">i</span>;
    <span style="color: #a020f0;">for</span> (i = 0; i &lt; NTRANS; i++) {
        tran[i].cycle = <span style="color: #008b8b;">nullptr</span>;
    }

    <span style="color: #a020f0;">for</span> (i = 0; i &lt; NTRANS; i++) {
        visit(&amp;tran[i]);
    }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org60afcc5" class="outline-2">
<h2 id="org60afcc5">日志管理程序</h2>
<div class="outline-text-2" id="text-org60afcc5">
<p>
日志是一个顺序文件，由于事务型对象的每次插入、删除或修改都会产生日志，因此日志很容易成为瓶颈，体积也会变得很大。为了避免影响性能，需要采用专门的方法来处理，常见的有谨慎写（carefull write）、串行写、乒乓写（ping-pong）、成组提交、提前写数据集（WADS）、交错分配等。日志是时态数据库，在线的会话、表、队列等永久对象仅仅表现了它们的当前版本。最初日志只是用来恢复事务，现在越来越多的被用来在应用层的对象时域寻址，即寻找一个对象在历史某个时刻的状态。
</p>


<p>
日志管理程序为日志表提供了一个接口，日志表中顺序的存放着日志记录，每个记录包含日志头和日志体。日志头记录了资源管理程序的名字、事务的名字和其他信息。日志体由资源管理器提供，它包含了操作的UNDO-REDO信息，日志管理程序并不关心这些信息，只是作为二进制数据保存。在日志表中，每个日志都有唯一的编号，叫做日志序号（Log Sequence Number，LSN）。下面是使用SQL表达的日志表定义：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #a020f0;">create</span> <span style="color: #a020f0;">domain</span> LSN unsigned <span style="color: #228b22;">integer</span>(64);  <span style="color: #b22222;">-- &#26085;&#24535;&#24207;&#21495;</span>
<span style="color: #a020f0;">create</span> <span style="color: #a020f0;">domain</span> RMID unsigned <span style="color: #228b22;">integer</span>;     <span style="color: #b22222;">-- &#36164;&#28304;&#31649;&#29702;&#31243;&#24207;&#26631;&#35782;&#31526;</span>
<span style="color: #a020f0;">create</span> <span style="color: #a020f0;">domain</span> TRID <span style="color: #228b22;">char</span>(12);             <span style="color: #b22222;">-- &#20107;&#21153;&#26631;&#35782;&#31526;</span>
<span style="color: #a020f0;">create</span> <span style="color: #a020f0;">table</span> <span style="color: #0000ff;">log_table</span> (
  lsn              LSN,                  <span style="color: #b22222;">-- &#26085;&#24535;&#24207;&#21495;</span>
  prev_lsn         LSN,                  <span style="color: #b22222;">-- &#21069;&#19968;&#26465;&#26085;&#24535;&#30340;&#24207;&#21495;</span>
  <span style="color: #228b22;">timestamp</span>        <span style="color: #228b22;">TIMESTAMP</span>,            <span style="color: #b22222;">-- &#26085;&#24535;&#35760;&#24405;&#21019;&#24314;&#26102;&#38388;</span>
  resource_manager RMID,                 <span style="color: #b22222;">-- &#36164;&#28304;&#31649;&#29702;&#22120;&#26631;&#35782;&#31526;</span>
  trid             TRID,                 <span style="color: #b22222;">-- &#20107;&#21153;&#26631;&#35782;&#31526;</span>
  tran_prev_lsn    LSN,                  <span style="color: #b22222;">-- &#21516;&#20107;&#21153;&#20013;&#21069;&#19968;&#26465;&#26085;&#24535;&#30340;&#24207;&#21495;</span>
  body             <span style="color: #228b22;">varchar</span>,              <span style="color: #b22222;">-- &#26085;&#24535;&#20307;</span>
  <span style="color: #a020f0;">primary</span> <span style="color: #a020f0;">key</span> (lsn),
  <span style="color: #a020f0;">foreign</span> <span style="color: #a020f0;">key</span> (prev_lsn)
    reference log_table(lsn)
  <span style="color: #a020f0;">foreign</span> <span style="color: #a020f0;">key</span> (tran_prev_lsn)
    reference log_table(lsn)
) entry sequenced;
</pre>
</div>

<p>
日志管理程序把日志映射到一个顺序文件集合中，当日志表填满一个文件后，系统会分配另一个文件。通常只有最近的记录才会联机保存。旧的记录会保存在便宜的存储介质（如磁带）上，由归档系统来管理。而更早的日志将被丢弃。为了提供可靠性，日志通常是双工的：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">log_files</span> {
    <span style="color: #228b22;">filename</span> <span style="color: #a0522d;">a_prefix</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">a&#26085;&#24535;&#25991;&#20214;&#30446;&#24405;</span>
    <span style="color: #228b22;">filename</span> <span style="color: #a0522d;">b_prefix</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">b&#26085;&#24535;&#25991;&#20214;&#30446;&#24405;</span>
    <span style="color: #228b22;">long</span>     <span style="color: #a0522d;">index</span>;     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26085;&#24535;&#25991;&#20214;&#32034;&#24341;</span>
};
</pre>
</div>

<p>
日志文件采用标准的文件名，以LOGA00000000和LOGB00000000格式结尾，其中的0使用日志目录中的文件索引来替换。日志序号LSN由记录的文件号和记录在文件中的偏移量组成，定义如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">LSN</span> {
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">file</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26085;&#24535;&#30446;&#24405;&#20013;&#30340;&#25991;&#20214;&#21495;</span>
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">rba</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#35760;&#24405;&#22312;&#25991;&#20214;&#20013;&#30340;&#20559;&#31227;&#37327;</span>
};
<span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">NullLSN</span> = {0, 0};  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31354;LSN&#65292;&#29992;&#20110;&#26631;&#35760;&#38142;&#34920;&#23614;&#12290;</span>
</pre>
</div>

<p>
LSN可以看成是一个64位无符号整数，并且是递增的。如果日志记录A在记录B之前生成，必然有LSN(A)&lt;LSN(B)。
</p>


<p>
日志管理程序提供两个读取日志的接口，一个是SQL接口，一个是低层次的接口。低层次接口在系统恢复时使用，这时系统还无法提供SQL服务。考虑到日志包含了所有对象的历史，拥有了日志访问权就等于拥有了所有对象的读操作权限，因此日志接口必须考虑权限管理。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">enum</span> <span style="color: #a020f0;">class</span> <span style="color: #228b22;">Access</span> {<span style="color: #a0522d;">Read</span>, <span style="color: #a0522d;">Write</span>};
<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">logtable_open</span>(<span style="color: #228b22;">Access</span> <span style="color: #a0522d;">access</span>);
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">logtable_close</span>();

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">log_record_header</span> {
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">lsn</span>;
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">prev_lsn</span>;
    <span style="color: #228b22;">TIMESTAMP</span> <span style="color: #a0522d;">timestamp</span>;
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">rmid</span>;
    <span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">trid</span>;
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">tran_prev_lsn</span>;
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">length</span>;
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">body</span>[];
};

<span style="color: #b22222;">// </span><span style="color: #b22222;">&#35835;&#21462;&#26085;&#24535;&#35760;&#24405;&#65292;&#36820;&#22238;&#35835;&#21462;&#30340;&#23383;&#33410;&#25968;&#12290;</span>
<span style="color: #228b22;">long</span> <span style="color: #0000ff;">log_read_lsn</span>(<span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">lsn</span>, <span style="color: #228b22;">log_record_header</span>* <span style="color: #a0522d;">header</span>, <span style="color: #228b22;">long</span> <span style="color: #a0522d;">offset</span>, <span style="color: #228b22;">pointer</span> <span style="color: #a0522d;">buffer</span>, <span style="color: #228b22;">long</span> <span style="color: #a0522d;">n</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">&#36820;&#22238;&#26368;&#22823;LSN&#12290;</span>
<span style="color: #228b22;">LSN</span> <span style="color: #0000ff;">log_max_lsn</span>();
</pre>
</div>

<p>
大部分时候，资源管理器使用SQL接口来访问日志。
</p>
<div class="org-src-container">
<pre class="src src-sql">long sql_count(RMID rmid) {
    long rec_count;
    exec_sql("<span style="color: #a020f0;">SELECT</span> <span style="color: #483d8b;">count</span>(*) <span style="color: #a020f0;">INTO</span> :rec_count <span style="color: #a020f0;">FROM</span> log_table <span style="color: #a020f0;">WHERE</span> resource_manager = :rmid");
    <span style="color: #a020f0;">return</span> rec_count;
}

long c_count(RMID rmid) {
    log_record_header header;
    LSN lsn;
    <span style="color: #228b22;">char</span> buffer[1];
    long rec_count = 0;
    <span style="color: #228b22;">int</span> n = 1;
    if (!log_table_open(<span style="color: #a020f0;">READ</span>)) {
        panic();
    }

    lsn = log_max_lsn();
    while (lsn != NullLSN) {
        n = log_read_lsn(lsn, &amp;header, 0L, &amp;buffer, 1L);
        if (header.rmid == rmid) {
            rec_count = rec_count + 1;
        }
        lsn = header.prev_lsn;
    }
    logtable_close();
    <span style="color: #a020f0;">return</span> rec_count;
}

LSN log_insert(<span style="color: #228b22;">char</span>* buffer, long n);
LSN log_flush(LSN lsn, bool lazy);
</pre>
</div>

<p>
为了简化日志管理程序，日志记录不能够跨文件保存。如果文件剩余空间不足，系统写入一个虚拟记录填充，然后在新的文件中保存日志。读日志相对简单，只有最后一条日志需要加锁。日志可以采用乐观读的方式，读取双工的一个副本。每个日志页上设置一个标志，用来表明日志页是否已满。最后一个日志页大多数时间都缓存在内存中，读取这个页面不需要磁盘IO。因此如果从磁盘读取的日志页中没有这个标志位，就从另外一个副本中读取。这种方法可以提高乐观读的安全性。
</p>


<p>
日志锚点的结构如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">log_anchor</span> {
    <span style="color: #228b22;">filename</span> <span style="color: #a0522d;">tablename</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26085;&#24535;&#34920;&#21517;</span>
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">log_files</span>;    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26085;&#24535;&#25991;&#20214;</span>
    <span style="color: #228b22;">xsemaphore</span> <span style="color: #a0522d;">lock</span>;     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25511;&#21046;&#26085;&#24535;&#20889;&#30340;&#20449;&#21495;&#37327;</span>
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">prev_lsn</span>;        <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26368;&#26032;&#20889;&#20837;&#30340;LSN</span>
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">lsn</span>;             <span style="color: #b22222;">// </span><span style="color: #b22222;">&#19979;&#19968;&#20010;&#35760;&#24405;&#30340;LSN</span>
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">durable_lsn</span>;     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#27704;&#20037;&#23384;&#20648;&#22120;&#20013;&#35760;&#24405;&#30340;&#26368;&#22823;LSN</span>
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">TM_anchor_lsn</span>;   <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20107;&#21153;&#31649;&#29702;&#22120;&#26368;&#36817;&#26816;&#26597;&#28857;&#35760;&#24405;&#30340;LSN</span>
    <span style="color: #a020f0;">struct</span> {
        <span style="color: #228b22;">long</span> <span style="color: #a0522d;">partno</span>;     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20998;&#21306;&#21495;</span>
        <span style="color: #228b22;">int</span> <span style="color: #a0522d;">os_fnum</span>;     <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25805;&#20316;&#31995;&#32479;&#25991;&#20214;&#21495;</span>
    } <span style="color: #a0522d;">part</span>[MAXOPENS];    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25171;&#24320;&#30340;&#26085;&#24535;&#25991;&#20214;</span>
};
</pre>
</div>

<p>
事务管理器也保存关于每个活动事务的日志信息，即该事务的首个和最后一个日志记录。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">TransCB</span> {
    <span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">trid</span>;    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20107;&#21153;&#32534;&#21495;n</span>
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">min_lsn</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20107;&#21153;&#39318;&#26465;&#26085;&#24535;</span>
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">max_lsn</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20107;&#21153;&#26368;&#36817;&#19968;&#26465;&#26085;&#24535;</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">stuff</span>
};
</pre>
</div>

<p>
每次插入一条日志时，日志管理程序都要通知事务管理器：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">LSN</span> <span style="color: #0000ff;">log_transaction</span>(<span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">new_lsn</span>) {
    <span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">trans</span> = my_trans();
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">prev</span>;
    prev = tans-&gt;max_lsn;
    tans-&gt;max_lsn = new_lsn;
    <span style="color: #a020f0;">if</span> (trans-&gt;min_lsn == NullLSN) {
        trans-&gt;min_lsn = new_lsn;
    }

    <span style="color: #a020f0;">return</span> prev;
}
</pre>
</div>

<p>
下面是插入日志的示例：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b22222;">// </span><span style="color: #b22222;">&#22312;&#26085;&#24535;&#20013;&#25554;&#20837;&#19968;&#26465;&#35760;&#24405;&#12290;&#19981;&#32771;&#34385;&#36328;&#39029;&#12289;&#36328;&#25991;&#20214;&#24773;&#20917;&#12290;</span>
<span style="color: #228b22;">LSN</span> <span style="color: #0000ff;">log_insert</span>(<span style="color: #228b22;">char</span>* <span style="color: #a0522d;">buffer</span>, <span style="color: #228b22;">long</span> <span style="color: #a0522d;">n</span>) {
    <span style="color: #228b22;">pointer</span> <span style="color: #a0522d;">log_page</span>;
    <span style="color: #228b22;">log_record_header</span>* <span style="color: #a0522d;">header</span>;
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">lsn</span>;
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">part</span>;
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">i</span>;
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">rec_len</span>;

    rec_len = <span style="color: #a020f0;">sizeof</span>(log_record_header) + n;
    xsem_get(&amp;log_anchor.lock);
    lsn = log_anchor.lsn;
    <span style="color: #a020f0;">for</span> (part = 0; part &lt;= MAXOPENS; part++) {
        <span style="color: #a020f0;">if</span> (log_anchor.part[part].partno == lsn.file) {
            <span style="color: #a020f0;">break</span>;
        }
    }

    <span style="color: #a020f0;">if</span> (part == MAXOPENS) {
        panic(); <span style="color: #b22222;">// </span><span style="color: #b22222;">&#27809;&#26377;&#25214;&#21040;&#26085;&#24535;&#25991;&#20214;&#21495;</span>
    }
    log_page = page_fix(log_anchor.part[part].os_fnum, lsn.rba); <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25214;&#21040;&#39029;</span>
    header = log_record_allocate(log_page, rec_len);
    <span style="color: #a020f0;">if</span> (header == <span style="color: #008b8b;">nullptr</span>) {
        <span style="color: #b22222;">// </span><span style="color: #b22222;">&#39029;&#28322;&#20986;&#12290;&#24573;&#30053;&#12290;</span>
    }

    header-&gt;lsn = lsn;
    header-&gt;prev_lsn = log_anchor.prev_lsn;
    header-&gt;timestamp = timestamp();
    header-&gt;rmid = client_rmid();
    header-&gt;trid = my_trid();
    header-&gt;tran_prev_lsn = log_transaction(lsn);
    header-&gt;length = n;
    <span style="color: #a020f0;">for</span> (i = 0; i &lt; n; i++) {
        header-&gt;body[i] = buffer[i];
    }
    page_unfix(log_page);
    log_anchor.prev_lsn = lsn;
    log_anchor.lsn.rba = log_anchor.lsn.rba + rec_len;
    xsem_give(&amp;log_anchor.lock);
    <span style="color: #a020f0;">return</span> lsn;
}
</pre>
</div>

<p>
分配文件是耗时的工作，通常由日志管理程序守护进程完成。守护进程每隔一段时间启动一次，如果当前文件已经半满，守护进程分配一个新文件。在当前文件全满时，新文件已经分配好并打开。守护进程把心文件的描述符加入到log_anchor并持久化，以便在系统重启时可以使用这个新的日志分区文件。高性能系统需要一些特殊的写日志技术。数据向永久存储器的传送时通过叫做日志刷新守护进程的异步进程协调的。这个进程可以由日志刷新请求唤醒，也可以由周期性的锚点唤醒。唤醒后，它将最新的日志增长部分刷写到磁盘上。双工日志表可以屏蔽大部分介质故障。如果磁盘上最后一个日志页已经包含了部分信息，但是未满。当包含新记录的页覆盖旧的页时，如果系统故障，旧页中的数据将被损坏。这个问题可以用串行写来解决：首先写一个副本，然后再写另一个副本。另一种方法叫做乒乓写。假设最后一个页面时page(i)，在写入新记录时，乒乓写将页面写入page(i+1)，然后再page(i)和page(i+1)之前乒乓式来回重写。乒乓写的最后一个页面总是正确的，在读取时，必须接受page(i)和page(i+1)中时间戳较大者。写一个日志页的开销包括分派守护进程、准备和发出磁盘I/O以及磁盘I/O操作完成后的清理工作。为了提高日志性能，应当将日志批量写入，这就导致日志延迟写入。这种方式叫做成组提交（group commit）。当然，延迟刷新日志也存在着一些缺点，比如延迟了锁的释放。
</p>


<p>
在重启时，资源管理器需要从一个特定的LSN开始重复执行日志中的操作，以此完成实际的重启工作。这个LSN叫做资源管理器底线。为了简化操作，日志管理器为资源你管理器提供了一个通用的锚点，这个锚点也是一个日志，记录了资源管理器的LSN。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">log_write_anchor</span>(<span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">anchor</span>);
<span style="color: #228b22;">LSN</span> <span style="color: #0000ff;">log_read_anchor</span>();
</pre>
</div>

<p>
为了保证可靠性，锚点应当采用谨慎写。日志锚点不是立即刷写到磁盘中的，因此在重启时，系统不能盲目相信日志锚点中的信息，必须重新计算最大LSN。
</p>
</div>
</div>

<div id="outline-container-org64230ce" class="outline-2">
<h2 id="org64230ce">事务管理器概念</h2>
<div class="outline-text-2" id="text-org64230ce">
<p>
当放生以下情况时，需要事务管理器来协调恢复：
</p>
<ul class="org-ul">
<li>事务回滚。回滚到一个保存点或中止事务。</li>
<li>资源管理器重启。事务管理器提供日志让资源管理器恢复到最近提交的状态。</li>
<li>系统重启。帮助资源管理器建立永久状态。</li>
<li>介质恢复。帮助资源管理器重建对象。</li>
<li>节点重启。</li>
</ul>

<p>
在进行事务回滚时，事务管理器反向读取日志日志，调用参与事务的资源管理器的UNDO()接口，将日志传递给它。资源管理器撤销操作，将对象恢复到原来的状态。如果撤销到某个保存点后，所有资源管理器都投票赞成，那么回滚成功。否则的话，继续向前一个保存点回滚。在重启时，事务管理器正向扫描日志，将里面的REDO操作传递给资源管理器。
</p>
</div>

<div id="outline-container-org493f9f5" class="outline-3">
<h3 id="org493f9f5">DO-UNDO-REDO协议</h3>
<div class="outline-text-3" id="text-org493f9f5">
<p>
这个协议要求DO程序、UNDO程序和REDO程序成组实现。DO程序执行对象上的一个操作，并生成日志。UNDO程序通过对象的新状态和日志将对象恢复到初始状态。REDO程序通过旧状态和日志构建新状态：
</p>
<div class="org-src-container">
<pre class="src src-text">do(state_a) -&gt; (log_op, state_b)
undo(state_b, log_op) -&gt; state_a
redo(state_a, log_op) -&gt; state_b
</pre>
</div>

<p>
随着事务的执行，所有更新操作的日志组成了一个日志记录序列，叫做事务日志：
</p>
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #a020f0;">declare</span> <span style="color: #a020f0;">cursor</span> <span style="color: #a020f0;">for</span> transaction_log
<span style="color: #a020f0;">select</span> rmid, lsn
<span style="color: #a020f0;">from</span> log
<span style="color: #a020f0;">where</span> trid = :trid
descending lsn;
</pre>
</div>

<p>
在回滚事务时，事务管理器反向读取日志，让资源管理器执行UNDO操作，恢复对象状态：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">transaction_undo</span>(<span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">trid</span>) {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">sqlcode</span>;
    open <span style="color: #228b22;">cursor</span> <span style="color: #a0522d;">transaction_log</span>;
    <span style="color: #a020f0;">while</span> (<span style="color: #008b8b;">true</span>) {
        fetch <span style="color: #228b22;">transaction_log</span> <span style="color: #a0522d;">into</span> :rmid, :lsn;
        <span style="color: #a020f0;">if</span> (sqlcode != 0) {
            <span style="color: #a020f0;">break</span>;
        }
        rmid.undo(lsn);
    }

    close <span style="color: #228b22;">cursor</span> <span style="color: #a0522d;">transaction_log</span>;
}
</pre>
</div>

<p>
通过REDO操作，资源管理器可以恢复对象的状态：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">log_redo</span>(<span style="color: #228b22;">void</span>) {
    <span style="color: #228b22;">declare</span> <span style="color: #a0522d;">cursor</span> <span style="color: #a020f0;">for</span> the_log select rmid, <span style="color: #a0522d;">lsn</span> from log ascending lsn;
    open <span style="color: #228b22;">cursor</span> <span style="color: #a0522d;">the_log</span>;
    <span style="color: #a020f0;">while</span> (<span style="color: #008b8b;">true</span>) {
        fetch <span style="color: #228b22;">the_log</span> <span style="color: #a0522d;">into</span> :rmid, :lsn;
        <span style="color: #a020f0;">if</span> (sqlcode != 0) { <span style="color: #a020f0;">break</span>; }
        rm.redo(lsn);
    }
    close <span style="color: #228b22;">cursor</span> <span style="color: #a0522d;">the_log</span>;
}
</pre>
</div>

<p>
下面我们讨论如何使用DO-UNDO-REDO协议恢复会话。会话的可恢复状态包括两个会话端点、顺序号（入站和出站）以及未传送的消息。会话通常是私有的，因此不涉及锁和并发控制。通过会话发送一条消息时，消息值和顺序号被写入日志。当从会话收到一个消息时，会建立一个保存点，将收到的消息顺序号记入日志，并作出应答：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">enum</span> <span style="color: #a020f0;">class</span> <span style="color: #228b22;">Message_operation</span> {<span style="color: #a0522d;">Open</span>, <span style="color: #a0522d;">Close</span>, <span style="color: #a0522d;">Get</span>, <span style="color: #a0522d;">Send</span>};
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Message_log_record_body</span> {
    <span style="color: #228b22;">Session</span> <span style="color: #a0522d;">session</span>;
    <span style="color: #228b22;">Message_operation</span> <span style="color: #a0522d;">operation</span>;
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">sequence_number</span>;
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">length</span>;
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">message</span>[length];
};
</pre>
</div>
<p>
会话Open和Close操作的REDO就是自身，Open和Close互为UNDO操作。Send的REDO是使用原序列号重新发送消息，Get的REDO操作是增加局部入站序列号。Send的UNDO操作可以通过发送取消消息完成。取消消息告诉对方：忽略之前发送的序号为n的消息。
</p>


<p>
前面提到过实操作的问题，实操作无法UNDO，因此必须延迟到事务提交的第二阶段执行。延迟的方法是生成REDO日志记录，但不发送实际消息。在提交时，通过REDO实现真正的消息传递。和UNDO一样，REDO也可能产生问题。一些操作不能重复执行。消息的顺序号让Send操作具有幂等性。如果一个操作不具有幂等性，但是具有可测试性，可以通过重复尝试达到只做一次的效果：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">while</span> (old_state) {
  Send();
}
</pre>
</div>

<p>
如果操作既不幂等，又不可测试，那么无法提供“只做一次”的保证。下面的表格总结了会话的DO-UNDO-REDO协议：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">发送者</td>
<td class="org-left">接收者</td>
</tr>

<tr>
<td class="org-left">DO</td>
<td class="org-left">在日志中记录消息和顺序号，发送消息</td>
<td class="org-left">建立保存点，记录消息和顺序号，确认</td>
</tr>

<tr>
<td class="org-left">UNDO</td>
<td class="org-left">发送取消消息，生成日志记录</td>
<td class="org-left">返回保存点，确认</td>
</tr>

<tr>
<td class="org-left">REDO</td>
<td class="org-left">重新发送消息</td>
<td class="org-left">如果不是重复副本，执行正常DO处理，否则仅确认</td>
</tr>

<tr>
<td class="org-left">COMMIT</td>
<td class="org-left">发送任何延迟的消息</td>
<td class="org-left">执行</td>
</tr>
</tbody>
</table>

<p>
编写UNDO_REDO程序的方法有多种，最简单的是旧值-新值日志（old value-new value logging），将新旧的值都写入日志中：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">value_log_record_for_page_update</span> {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">opcode</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25805;&#20316;</span>
    <span style="color: #228b22;">filename</span> <span style="color: #a0522d;">lname</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26356;&#26032;&#30340;&#25991;&#20214;&#21517;</span>
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">pageno</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#39029;&#21495;</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">old_value</span>[PAGESIZE]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#39029;&#26087;&#20540;</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">new_value</span>[PAGESIZE]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#39029;&#26032;&#20540;</span>
};
</pre>
</div>

<p>
如果对象庞大，而且每次往往只更新一小部分，可以对日志进行压缩：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">compressed_log_record_for_page_update</span> {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">opcode</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25805;&#20316;</span>
    <span style="color: #228b22;">filename</span> <span style="color: #a0522d;">fname</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26356;&#26032;&#30340;&#25991;&#20214;</span>
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">pageno</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#39029;&#21495;</span>
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">offset</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#39029;&#20559;&#31227;&#37327;</span>
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">length</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26356;&#26032;&#25968;&#25454;&#22359;&#38271;&#24230;</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">old_value</span>[length]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21407;&#20540;</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">new_value</span>[length]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26032;&#20540;</span>
};
</pre>
</div>

<p>
值日志也叫做物理日志，它记录了对象的物理地址和值。另一种日志叫逻辑日志或操作日志，它记录的是UNDO-REDO功能的名称和参数，而不是值本身。比如SQL可能使用下面的格式记录向某个表插入记录的操作：
</p>
<div class="org-src-container">
<pre class="src src-text">&lt;&#25554;&#20837;&#25805;&#20316;, &#34920;&#21517;, &#35760;&#24405;&#20540;&gt;
</pre>
</div>

<p>
逻辑日志的记录比物理日志少。但是逻辑日志也存在缺点。逻辑日志假设所有操作都是原子的，并且在每一种失败情况下系统的状态都是一致的。我们考上面的插入记录操作，失败的场景有：
</p>
<ul class="org-ul">
<li>逻辑失败。在唯一索引上发生重复并启动回滚。</li>
<li>界限失败。某一索引文件空间耗尽并启动回滚。</li>
<li>竞争失败。某一索引插入遇到死锁并启动回滚。</li>
<li>介质失败。文件的某一页被破坏，或远程节点上的索引无法使用。</li>
<li>系统失败。在插入过程中，系统崩溃。</li>
</ul>

<p>
在某些情况下，操作可能只有部分完成，系统状态不是一致的。因此，逻辑日志主要有两方面的问题：
</p>
<ul class="org-ul">
<li>部分操作。部分完成的操作需要进行撤销。这部分操作的UNDO不能用一个操作来表示。</li>
<li>操作一致性。涉及多条消息或多次写入的操作不一定是原子的，重启时UNDO和REDO可能呈现出不一致的状态。</li>
</ul>

<p>
有一种折中的方案，叫做物理-逻辑日志，具体的说，是“页面物理，页内逻辑”（physical-to-a-page, logical-within-a-page）。在这个方案中，复杂的操作由一些列消息和页面操作组成，每一个消息应用于唯一的会话，每个页面操作应用于唯一的页面。页面和消息构成微型事务，这个事务使用逻辑日志，当操作完成时，页面被更新，产生一个UNDO-REDO日志记录这个操作。这时，操作是原子的、一致的和隔离的微型事务。每个微型事务对页面和会话状态的改变都生成一条日志记录，这是物理日志部分。而物理对象（页面或会话）的状态变化采用逻辑方式描述。
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">physiological_log_record_for_record_insert</span> {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">opcode</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#34920;&#26126;&#26159;&#29289;&#29702;-&#36923;&#36753;&#25554;&#20837;</span>
    <span style="color: #228b22;">filename</span> <span style="color: #a0522d;">fname</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25991;&#20214;&#21517;</span>
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">pageno</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#39029;&#21495;</span>
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">record_id</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#39029;&#20013;&#30340;&#35760;&#24405;&#32034;&#24341;</span>
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">length</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#35760;&#24405;&#38271;&#24230;</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">record</span>[length]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#35760;&#24405;&#20869;&#23481;</span>
};
</pre>
</div>

<p>
插入操作可能引起页面的重组，页面中的其他记录需要移动。插入操作也经常更新页头和页尾。这些操作记录在逻辑日志中。除了描述数据表的变化外，索引的变化，触发器产生的更新都要记录下来。我们考虑下面的逻辑日志：
</p>
<div class="org-src-container">
<pre class="src src-text">&lt;insert op, tablename=A, record value = r&gt;
</pre>
</div>

<p>
如果表有两个索引，并且没有触发器，则相应的物理-逻辑日志为：
</p>
<div class="org-src-container">
<pre class="src src-text">&lt;insert op, base filename=A, page number=508, record value=4&gt;
&lt;insert op, index1 filename=B, page number=72, index1 record value=keyB of r=s&gt;
&lt;insert op, index2 filename=C, page number=94, index2 record value=keyC of r=t&gt;
</pre>
</div>

<p>
这些记录分别由3个页面操作（更新表A、B、C的数据页）生成。如果插入时涉及溢出处理、B-树节点分裂或触发器，那么将涉及更多的页面。物理-逻辑日志的一致性主要有两个方面：
</p>
<ul class="org-ul">
<li>页面操作一致性。在易失性存储器和永久存储器中，页面的状态是一致的。</li>
<li>日志一致性。日志记录了全部的页面操作历史。</li>
</ul>

<p>
为了保证一致性，所有对页面的操作都改造成了如下的微型事务：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">mini_tx</span>() {
    exclude_lock(object);
    update(object);
    generate_undo_redo_log();
    release_lock(object);
}
</pre>
</div>

<p>
在重启时，物理-逻辑日志同样要保证下面两个一致性：
</p>
<ul class="org-ul">
<li>页面-动作一致性。持久存储器处于页面操作一致性状态。</li>
<li>日志一致性。持久日志记录了所有已提交的更新和持久性页面的变更记录。</li>
</ul>

<p>
为了满足上述要求，需要在将页面刷写到持久存储器之前，首先刷写日志。这个方法叫做先写日志（WAL）协议。先写日志协议的规则如下：
</p>
<ul class="org-ul">
<li>每个易失页面都有一个LSN字段用来命名页面最近更新的日志记录。</li>
<li>每次更新都会维护易失页面的LSN字段。</li>
<li>在将易失页面刷写到持久存储器之前，首先请求日志记录器，把LSN对应的日志，以及更早的日志刷写到持久存储器中。</li>
<li>将易失页面刷写到持久存储器。</li>
<li>在写入和拷贝过程中，页面必须被固定，以保证页面工作一致性。</li>
</ul>

<p>
假设事务已经提交，但是页面没有被拷贝到持久存储器，如果这时系统崩溃，事务无法进行REDO，持久性无法保证。因此事务日志必须作为提价的一部分，保存到持久存储器上。这个规则叫做提交时强制写日志（force-log-at-commit）。总的来说，物理-逻辑日志的一致性需要下面的规则来保证：
</p>
<ul class="org-ul">
<li>固定规则。用信号量来保护对所有页面的读和写。</li>
<li>先写日志。在将页刷写到持久性存储器之前，强制写该页面的日志记录。</li>
<li>提交时强制写日志。作为提价工作的一部分，强制写该事务的日志记录。</li>
</ul>

<p>
在两阶段提交时，如果一个资源管理器投赞成票，即使失败或重启，资源管理器必须能够提交或撤销这个事务的改变。这意味着，在准备阶段完成之后，资源管理器不能进行任何不能保证成功的操作，而且准备状态必须是持久的。一个成功过的集中式两阶段提交由下列步骤组成：
</p>
<ul class="org-ul">
<li>准备。调用列表中的每一个资源管理器，要求它们投票。</li>
<li>决定。如果所有资源管理器都投票赞成，持久性的写入该事务提交的日志记录。</li>
<li>提交。调用列表中的每一个资源管理器，告诉它提交决定。</li>
<li>完成。当所有管理器都对提交消息进行了应答，在日志中写入一个提交完成记录，表示阶段2结束。当日志完成持久化，释放事务状态。</li>
</ul>

<p>
回滚要用到事务日志和资源管理器列表，abort_work()的逻辑如下：
</p>
<ul class="org-ul">
<li>撤销。反向读取事务日志，对每一条记录发出UNDO，调用写该记录的资源管理器来执行UNDO操作。</li>
<li>广播。在每一个保存点，调用参与事务的资源管理器，告诉它们事务在保存点上。</li>
<li>中止。在日志中写入中止记录。（这是begin_work()的UNDO）</li>
<li>完成。在日志上写入记录表明中止结束，释放事务状态。事务管理器可以不用等待所有参与者确认就可以将中止完成记录写入日志。</li>
</ul>


<p>
在分布式事务的两阶段提交中，如果一个事务管理器通过执行begin_work()开始一个事务，这个事务管理器就叫做根事务管理器。当事务的操作从一个节点转向另一个节点时，参与它的事务管理器形成一棵树，叫做事务树。提交信息沿着树传递。在事务树中，只有根可以提交事务，它是协调者。其他成员是参与者。每个参与者都可以中止事务。协调者在阶段1轮询参与者，如果参与者反对或在规定时间内无应答，协调者将拒绝提交，并将参与者广播中止决定。否则协调者持久性写入提交记录并广播提交决定。对参与者来说，它收到阶段1的PREPARE轮询，在自己的节点上协调工作，然后投票赞成或反对这个轮询。当一个参与者投赞成票时，这个节点上的资源管理器必须准备好提交或中止，且准备状态必须是持久化的。当参与者收到阶段2的决定时（提交或中止），它向本地资源管理器广播这个决定。在得到本地资源管理器的应答后，参与者得到一个完成记录并持久化，然后向协调者确认。在通信时，每个节点只和它的直接后代进行通信。
</p>

<p>
分布式事务上的commit_work()工作步骤如下：
</p>
<ul class="org-ul">
<li>局部准备。调用每个句柄资源管理器，为提交做准备。</li>
<li>分布式准备。在事务的每一个联出会话上发送一个准备请求。</li>
<li>决定。如果资源管理器都投赞成票，并且所有联出会话都响应赞成，持久性写入事务提交日志记录。记录包含参与的资源管理器和事务管理器列表。</li>
<li>提交。调用参与事务的每个资源管理器，告诉它们提交决定，并在每个事务的联出会话上发送提交消息。</li>
<li>完成。当所有局部资源管理器和联出会话都确认提交之后，向日志写入一个完成记录，。在完成记录持久化之后，释放事务状态。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org0dd3e8d" class="outline-2">
<h2 id="org0dd3e8d">事务管理器结构</h2>
<div class="outline-text-2" id="text-org0dd3e8d">
<p>
大多数事务管理和恢复都围绕着事务标识符（trid）进行。事务标识符必须始终唯一。事务管理器可能在丢失日志的情况下完成重启，这时trid顺序计数器重置为0。为了让其他事务管理器可以发现这种情况，每个事务管理器必须记住自己的生日，而trid需要包含这个生日：
</p>
<div class="org-src-container">
<pre class="src src-text">trid := &lt;&#20107;&#21153;&#31649;&#29702;&#22120;&#29983;&#26085;, &#20107;&#21153;&#31649;&#29702;&#22120;&#26631;&#35782;, &#39034;&#24207;&#21495;&gt;
</pre>
</div>

<p>
事务管理器的根数据结构（也叫做锚点）存储了几个关键值，标记出资源管理器列表和事务列表：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">TM_anchor</span> {
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">name</span>[BIG];  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20107;&#21153;&#31649;&#29702;&#22120;&#21517;&#23383;&#65292;&#22312;&#32593;&#32476;&#20013;&#21807;&#19968;</span>
    <span style="color: #228b22;">RMDI</span> <span style="color: #a0522d;">tmid</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20107;&#21153;&#31649;&#29702;&#22120;&#26631;&#35782;&#31526;</span>
    <span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">next_trid</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#24453;&#20998;&#37197;&#30340;&#19979;&#19968;&#20010;&#20107;&#21153;&#26631;&#35782;&#31526;</span>
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">ckpt_lsn</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26368;&#36817;&#30340;&#26816;&#26597;&#28857;</span>
    <span style="color: #228b22;">RMCB</span>* <span style="color: #a0522d;">rm_list</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36164;&#28304;&#31649;&#29702;&#22120;&#21015;&#34920;</span>
    <span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">tran_list</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20107;&#21153;&#21015;&#34920;</span>
};
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">RMCB</span>* <span style="color: #a0522d;">next_rmcb</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#19979;&#19968;&#20010;&#36164;&#28304;&#31649;&#29702;&#22120;</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">name</span>[BIG]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36164;&#28304;&#31649;&#29702;&#22120;&#21517;&#23383;</span>
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">rmid</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36164;&#28304;&#31649;&#29702;&#22120;&#26631;&#35782;&#31526;</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">up</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36164;&#28304;&#31649;&#29702;&#22120;&#29366;&#24577;&#65288;up&#25110;down&#65289;</span>
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">low_water_lsn</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36164;&#28304;&#31649;&#29702;&#22120;REDO&#25195;&#25551;&#25152;&#38656;&#30340;&#26368;&#23567;LSN</span>
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">ckpt_lsn</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36164;&#28304;&#31649;&#29702;&#22120;&#26368;&#36817;&#26816;&#26597;&#28857;&#35760;&#24405;&#30340;LSN</span>
} <span style="color: #228b22;">RMCB</span>;

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">tran_status</span> { <span style="color: #a0522d;">Active</span>, <span style="color: #a0522d;">Prepared</span>, <span style="color: #a0522d;">Aborting</span>, <span style="color: #a0522d;">Committing</span>, <span style="color: #a0522d;">Aborted</span>, <span style="color: #a0522d;">Committed</span> };

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">TransCB</span> {
    <span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">next</span>;
    <span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">trid</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20107;&#21153;&#32534;&#21495;</span>
    <span style="color: #228b22;">tran_status</span> <span style="color: #a0522d;">status</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20107;&#21153;&#29366;&#24577;</span>
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">next_save_pt</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#19979;&#19968;&#20010;&#20445;&#23384;&#28857;&#38656;&#35201;</span>
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">save_pt</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#24403;&#21069;&#20445;&#23384;&#28857;&#24207;&#21495;</span>
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">save_pt_lsn</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#24403;&#21069;&#20445;&#23384;&#28857;LSN</span>
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">max_lsn</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20107;&#21153;&#26368;&#26032;LSN</span>
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">min_lsn</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20107;&#21153;&#31532;&#19968;&#26465;&#26085;&#24535;LSN</span>
    <span style="color: #228b22;">RMTranCB</span>* <span style="color: #a0522d;">RM_list</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#28041;&#21450;&#30340;&#36164;&#28304;&#31649;&#29702;&#22120;&#21015;&#34920;</span>
    <span style="color: #228b22;">SECB</span>* <span style="color: #a0522d;">ses_list</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#28041;&#21450;&#30340;&#20250;&#35805;&#21015;&#34920;</span>
    <span style="color: #228b22;">pointer</span> <span style="color: #a0522d;">lock_list</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#38145;&#21015;&#34920;</span>
    <span style="color: #228b22;">pointer</span> <span style="color: #a0522d;">wait</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31561;&#24453;&#30340;&#38145;</span>
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">timeout</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#38145;&#36229;&#26102;&#26102;&#38388;</span>
    <span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">cycle</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26816;&#27979;&#27515;&#38145;&#20351;&#29992;  </span>
};
</pre>
</div>

<p>
下面是资源管理器列表入口的基本结构
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">RMTransCB</span> {
    <span style="color: #228b22;">RMTransCB</span>* <span style="color: #a0522d;">next</span>;
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">rmid</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36164;&#28304;&#31649;&#29702;&#22120;&#32534;&#21495;</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">prepared</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26159;&#21542;&#24050;&#20934;&#22791;&#25552;&#20132;</span>
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">save_pt_lsn</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26368;&#36817;&#19968;&#20010;&#20445;&#23384;&#28857;&#30340;LSN</span>
};
</pre>
</div>
<p>
在每个保存点，事务管理器通过savepoint()通知资源管理器，后者在日志中写入savepoint记录，返回的LSN记录在RMTransCB.save_pt_lsn中。
</p>

<p>
通信管理器维护分配给该事务的会话列表，新的TRPC为事务分配会话。会话列表的每个入口如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">SECB</span> {
    <span style="color: #228b22;">SECB</span>* <span style="color: #a0522d;">tran_next_ses</span>;
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">name</span>[BIG]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20250;&#35805;&#21517;&#23383;</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">incoming</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#32852;&#20837;&#25110;&#32852;&#20986;</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">him</span>[BIG]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#23545;&#31471;TM&#21517;&#23383;</span>
    <span style="color: #228b22;">timestamp</span> <span style="color: #a0522d;">birthday</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#23545;&#31471;TM&#29983;&#26085;</span>
};
</pre>
</div>

<p>
保存点日志记录结构如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">enum</span> <span style="color: #228b22;">Save_Pt_type</span> {
                   <span style="color: #a0522d;">Begin</span>, <span style="color: #a0522d;">Save</span>, <span style="color: #a0522d;">Prepare</span>, <span style="color: #a0522d;">Commit</span>, <span style="color: #a0522d;">Abort</span>, <span style="color: #a0522d;">Commit_complete</span>, <span style="color: #a0522d;">Abort_complete</span>
};

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">TM_savepoint</span> {
    <span style="color: #228b22;">Save_pt_type</span> <span style="color: #a0522d;">record_type</span>;
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">save_pt_num</span>;
    <span style="color: #228b22;">tran_status</span> <span style="color: #a0522d;">status</span>;
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">soft</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26242;&#26102;&#25110;&#25345;&#20037;</span>
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">num_rm</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21442;&#19982;&#35813;&#20107;&#29289;&#30340;&#36164;&#28304;&#31649;&#29702;&#22120;&#25968;&#37327;</span>
    <span style="color: #228b22;">RMTransCB</span> <span style="color: #a0522d;">RM</span>[num_rm]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#27599;&#20010;&#21442;&#19982;&#30340;&#36164;&#28304;&#31649;&#29702;&#22120;&#21517;&#23383;</span>
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">sessions</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20250;&#35805;&#25968;&#37327;</span>
    <span style="color: #228b22;">SECB</span> <span style="color: #a0522d;">session</span>[sessions]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20250;&#35805;&#20449;&#24687;</span>
    <span style="color: #228b22;">context</span> <span style="color: #a0522d;">it</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20445;&#23384;&#28857;&#30340;&#24212;&#29992;&#31243;&#24207;&#19978;&#19979;&#25991;</span>
};
</pre>
</div>

<p>
begin_work()的逻辑如下
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">TRID</span> <span style="color: #0000ff;">begin_work</span>(<span style="color: #228b22;">context</span>* <span style="color: #a0522d;">it</span>, <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">soft</span>) {
    <span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">trans</span>;
    <span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">him</span>;
    <span style="color: #228b22;">TM_savepoint</span> <span style="color: #a0522d;">save</span>;

    <span style="color: #a020f0;">if</span> (my_trid() != NULLTrid) {
        <span style="color: #a020f0;">return</span> NULLTrid;
    }

    him = TM_anchor.next_trid;
    TM_anchor.next_trid.sequence++;

    (MyProcessP())-&gt;trid = him;
    trans = malloc(<span style="color: #a020f0;">sizeof</span>(TransCB));
    trans-&gt;next = TM_anchor.tran_list;
    TM_anchor.tran_list = trans;
    trans-&gt;trid = him;
    trans-&gt;status = ACTIVE;
    trans-&gt;save_pt = 1;
    trans-&gt;next_save_pt = 2;
    trans-&gt;RM_list = trans-&gt;lock_list = trans-&gt;ses_list = <span style="color: #008b8b;">NULL</span>;
    save.record_type = begin;
    save.save_pt_num = 1;
    save.soft = soft;
    save.num_RM = save.sessions = 0;
    copy(save.it, it, it.length);
    trans-&gt;save_pt_lsn = log_insert(save, <span style="color: #a020f0;">sizeof</span>(save));
    <span style="color: #a020f0;">if</span> (!soft) {
        log_flush(trans-&gt;max_lsn, FALSE);
    }
    <span style="color: #a020f0;">return</span> him;
}
</pre>
</div>

<p>
commit_work()的逻辑大致如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">bool</span> <span style="color: #0000ff;">commit_work</span>(<span style="color: #228b22;">context</span>* <span style="color: #a0522d;">it</span>, <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">lazy</span>) {
    <span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">trans</span> = MyTransP();
    <span style="color: #228b22;">TM_savepoint</span> <span style="color: #a0522d;">save</span>;
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">save_num</span>;
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">vote</span>;
    <span style="color: #228b22;">RMTransCB</span>* <span style="color: #a0522d;">rm</span>;
    <span style="color: #228b22;">SECB</span>* <span style="color: #a0522d;">session</span>;

    <span style="color: #a020f0;">if</span> (MyTrid() == NULLTrid) {
        <span style="color: #a020f0;">return</span> 0;
    }

    <span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">rm</span>: trans-&gt;RM_list) {
        rm-&gt;prepared = rmid.Prepare(&amp;rm-&gt;save_pt_lsn);
        <span style="color: #a020f0;">if</span> (!rm-&gt;prepared) {
            abort_work();
            <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
        }
    }

    <span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">session</span>: trans-&gt;ses_list) {
        vote = TM.Prepare();
        <span style="color: #a020f0;">if</span> (!vote || timeout) {
            abort_work();
            <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
        }
    }

    trans-&gt;status = PREPARED;
    save_num = trans-&gt;save_pt++;
    save.record_type = commit;
    save.soft = <span style="color: #008b8b;">false</span>;
    save.save_pt_num = save_num;
    copy(save, trans-&gt;RM_list);
    copy(save, trans-&gt;ses_list);
    copy(save.it, it);
    trans-&gt;save_pt_lsn = log_insert(save, <span style="color: #a020f0;">sizeof</span>(save));
    log_flush(trans-&gt;max_lsn, lazy);

    trans-&gt;status = COMMITTING;
    <span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">rm</span>: trans-&gt;RM_list) {
        <span style="color: #a020f0;">if</span> (rmid.Commit()) {
            deallocate_rmid_from_tx();
        } <span style="color: #a020f0;">else</span> {
            rm_commit(&amp;rm);
        }
    }

    <span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">session</span>: trans-&gt;ses_list) {
        TM.Commit();
        <span style="color: #a020f0;">if</span> (!timeout) {
            free_session();
        } <span style="color: #a020f0;">else</span> {
            session_failure(&amp;session);
        }
    }

    <span style="color: #a020f0;">if</span> (trans-&gt;RM_list == <span style="color: #008b8b;">NULL</span> &amp;&amp; trans-&gt;ses_list == <span style="color: #008b8b;">NULL</span>) {
        trans-&gt;status = COMMITTED;
        save.record_type = commit_complete;
        log_insert(save, <span style="color: #a020f0;">sizeof</span>(save));
        dequeue_and_free_trans_structure();
    }

    MyProcessP()-&gt;trid = NULLTrid;
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}
</pre>
</div>

<p>
如果在阶段2发生失败，commit_work()可以直接返回，并启动一个异步例程session_failure来复制错误处理：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">session_failure</span>(<span style="color: #228b22;">SECB</span>* <span style="color: #a0522d;">session</span>) {
    <span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">trans</span> = MyTransP();
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">timeout</span> = <span style="color: #008b8b;">true</span>;
    <span style="color: #228b22;">TM_savepoint</span> <span style="color: #a0522d;">save</span>;
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">tm</span> = session-&gt;him;
    <span style="color: #a020f0;">while</span> (timeout) {
        TM.commit();
    }

    free_session();

    <span style="color: #a020f0;">if</span> (trans-&gt;RM_list == <span style="color: #008b8b;">NULL</span> &amp;&amp; trans-&gt;ses_list == <span style="color: #008b8b;">NULL</span>) {
        trans-&gt;status = COMMITTED;
        save.record_type = commit_complete;
        log_insert(save, <span style="color: #a020f0;">sizeof</span>(save));
        dequeue_and_free_trans_structure();
    }

    exit();
}
</pre>
</div>

<p>
在分布式事务中，如果根事务管理器失败，参与者事务管理器无法判断应当提交还是回滚，因此需要循环向根事务管理器请求事务状态：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">coordinator_failure</span>(<span style="color: #228b22;">SECB</span>* <span style="color: #a0522d;">session</span>) {
    <span style="color: #228b22;">tran_status</span> <span style="color: #a0522d;">outcome</span> = prepared;
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">TM</span> = session-&gt;him;
    <span style="color: #a020f0;">while</span> (outcome != committing &amp;&amp; outcome != aborting) {
        outcome = TM.Status_Transaction(MyTrid()); <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21521;&#36828;&#22788;TM&#35810;&#38382;&#32467;&#26524;</span>
    }

    <span style="color: #a020f0;">switch</span> (outcome) {
    <span style="color: #a020f0;">case</span> aborting: abort_work();
        <span style="color: #a020f0;">break</span>;
    <span style="color: #a020f0;">case</span> committing: commit_work();
        <span style="color: #a020f0;">break</span>;
    }
}
</pre>
</div>

<p>
save_work()的代码如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">int</span> <span style="color: #0000ff;">save_work</span>(<span style="color: #228b22;">context</span>* <span style="color: #a0522d;">it</span>, <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">soft</span>) {
    <span style="color: #228b22;">TransCB</span>* <span style="color: #0000ff;">trans</span>-&gt;MyTransP();
    <span style="color: #228b22;">TM_savepoint</span> <span style="color: #a0522d;">save</span>;
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">save_num</span>;
    <span style="color: #228b22;">RMTransCB</span>* <span style="color: #a0522d;">rm</span>;
    <span style="color: #228b22;">SECB</span>* <span style="color: #a0522d;">session</span>;
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">vote</span>;

    <span style="color: #a020f0;">if</span> (MyTrid() == NULLTrid) {
        <span style="color: #a020f0;">return</span> 0;
    }

    save_num = trans-&gt;next_save_pt++;
    <span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">rm</span>: trans-&gt;RM_list) {
        <span style="color: #a020f0;">if</span> (!vote = rmid.savepoint(&amp;rm-&gt;save_pt_lsn)) {
            abort_work();
            <span style="color: #a020f0;">return</span> 0;
        }
    }

    <span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">session</span>: trans-&gt;ses_list) {
        vote = TM.savepoint(save_num);
        <span style="color: #a020f0;">if</span> (timeout || !vote) {
            abort_work();
            <span style="color: #a020f0;">return</span> 0;
        }
    }

    trans-&gt;save_pt = trans-&gt;next_save_pt++;
    save.record_type = save;
    save.save_pt_num = save_num;
    save.soft = soft;
    copy(save, trans-&gt;RM_list);
    copy(save, trans-&gt;ses_list);
    copy(save.it, it);
    trans-&gt;save_pt_lsn = log_insert(save, <span style="color: #a020f0;">sizeof</span>(save));
    <span style="color: #a020f0;">if</span> (!soft) {
        log_flush(trans-&gt;max_lsn, soft);
    }
    <span style="color: #a020f0;">return</span> save_num;
}
</pre>
</div>

<p>
rollback_work()的逻辑如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">long</span> <span style="color: #0000ff;">rollback_work</span>(<span style="color: #228b22;">long</span> <span style="color: #a0522d;">target_savepoint</span>) {
    <span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">trans</span> = MyTransP();
    <span style="color: #228b22;">TM_savepoint</span> <span style="color: #a0522d;">save</span>;
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">lsn</span>;
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">rmid</span>;
    <span style="color: #228b22;">log_record_header</span> <span style="color: #a0522d;">header</span>;
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">abort</span> = <span style="color: #008b8b;">false</span>;

    <span style="color: #a020f0;">if</span> (MyTrid() == NULLTrid) {
        <span style="color: #a020f0;">return</span> 0;
    }

    lsn = trans-&gt;max_lsn;
    <span style="color: #a020f0;">while</span> (lsn != NULLLSN) {
        log_read(lsn, &amp;header, save, <span style="color: #a020f0;">sizeof</span>(save));
        rmid = header.rmid;
        rmid.undo(lsn);
        <span style="color: #a020f0;">if</span> (timeout || error) {
            abort = <span style="color: #008b8b;">true</span>;
        }
        <span style="color: #a020f0;">if</span> (!abort &amp;&amp;
            trans-&gt;save_pt &lt;= target_savepoint &amp;&amp;
            trans-&gt;max_lsn == trans-&gt;save_pt_lsn) {
            <span style="color: #a020f0;">return</span> trans-&gt;save_pt;
        }
        lsn = hreader.trans_prev_lsn;
    }

    <span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">rm</span>: trans-&gt;RM_list) {
        rm.abort();
    }

    <span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">session</span>: trans-&gt;ses_list) {
        TM.abort();
    }

    format_abort_complete_savepoint_record();
    log_insert(abort_complete_savepoint_record());
    deallocate_transcb();
    (MyProcessP())-&gt;trid = NULLTrid;
    <span style="color: #a020f0;">return</span> 0;
}

</pre>
</div>

<p>
undo由事务管理器UNDO例程执行：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">UNDO</span>(<span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">lsn</span>) {
    <span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">trans</span> = MyTransP();
    <span style="color: #228b22;">TM_savepoint</span> <span style="color: #a0522d;">save</span>;
    <span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">him</span> = MyTrid();
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">rmid</span>;
    <span style="color: #228b22;">RMTransCB</span>* <span style="color: #a0522d;">rm</span>;
    <span style="color: #228b22;">SECB</span>* <span style="color: #a0522d;">session</span>;
    <span style="color: #228b22;">log_record_header</span> <span style="color: #a0522d;">header</span>;
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">vote</span> = <span style="color: #008b8b;">true</span>;

    log_read(lsn, &amp;header, save, <span style="color: #a020f0;">sizeof</span>(save));
    trans-&gt;save_pt = save.save_pt_num;
    <span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">rm</span>: trans-&gt;RM_list) {
        <span style="color: #a020f0;">if</span> (rm.participate(savepoint)) {
            rm-&gt;save_pt_lsn = save.RM.save_pt_lsn;
        } <span style="color: #a020f0;">else</span> {
            rm-&gt;save_pt_lsn = NULLLSN;
        }
        vote = vote &amp;&amp; rmid.UNDO_savepoint(rm-&gt;save_pt_lsn);
    }

    <span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">session</span>: trans-&gt;ses_list) {
        vote = vote &amp;&amp; TM.UNDO_savepoint(trans-&gt;save_pt);
    }

    <span style="color: #a020f0;">if</span> (vote) {
        trans-&gt;max_lsn = header.tran_prev_lsn;
        trans-&gt;save_pt_lsn = log_insert(save, <span style="color: #a020f0;">sizeof</span>(save));
    }
    <span style="color: #a020f0;">return</span>;
}
</pre>
</div>

<p>
检查点（checkpoint）用于资源管理器或节点失败时加速系统的重启。重启时，易失性存储器复位，系统状态必须通过持久存储器重构。检查点是较近状态的持久拷贝，它是系统重启的基础。建立检查点有两种方式，一种是同步的，程序得到页面的信号量，将页面写入持久存储器。这种方式叫做清晰检查点（sharp checkpoint）。这种方式会阻塞服务。另一种方式叫模糊检查点（fuzzy checkpoint），检查点的建立和正常活动并行。事务管理器检查点的示例如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">TM_checkpoint</span> {
    <span style="color: #228b22;">SAVE_PT_TYPE</span> <span style="color: #a0522d;">record_type</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#34920;&#26126;checkpoint&#35760;&#24405;</span>
    <span style="color: #228b22;">TM_anchor</span> <span style="color: #a0522d;">anchor</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">TM&#38170;&#28857;&#20449;&#24687;</span>
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">low_water</span>;
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">num_RM</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36164;&#28304;&#31649;&#29702;&#22120;&#25968;&#37327;</span>
    <span style="color: #228b22;">RMCB</span> <span style="color: #a0522d;">RM</span>[num_RM]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36164;&#28304;&#31649;&#29702;&#22120;&#29366;&#24577;</span>
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">num_trans</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#27963;&#21160;&#20107;&#21153;&#25968;&#37327;</span>
    <span style="color: #228b22;">TM_savepoint</span> <span style="color: #a0522d;">trans</span>[num_trans]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20107;&#21153;&#25551;&#36848;</span>
};

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">TM_Checkpoint</span>(<span style="color: #228b22;">void</span>) {
    <span style="color: #228b22;">TM_checkpoint</span> <span style="color: #a0522d;">tm_checkpoint</span>;
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">checkpoint_lsn</span>;
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">low_water</span> = log_max_lsn();
    <span style="color: #228b22;">RMCB</span>* <span style="color: #a0522d;">rm</span>;

    <span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">rm</span>: TM_anchor.RM_list) {
        rm-&gt;checkpoint_lsn = rmid.Checkpoint(&amp;rm-&gt;low_water_lsn);
        <span style="color: #a020f0;">if</span> (fail) {
            rm-&gt;RMup = <span style="color: #008b8b;">false</span>;
        } <span style="color: #a020f0;">else</span> {
            low_water = min(low_water, rm-&gt;low_water_lsn);
        }
    }

    copy(tm_checkpoint, TM_anchor);
    TM_checkpoint.low_water = low_water;
    <span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">rm</span>: TM_anchor.RM_list) {
        copy(tm_checkpoint, RMCB);
    }
    <span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">trans</span>: TM_anchor.tran_list) {
        copy(tm_checkpoint, cb)
    }
    TM_anchor.checkpoint_lsn = log_insert(tm_checkpoint);
    log_write_anchor(TM_anchor.checkpoint_lsn);
    <span style="color: #a020f0;">return</span>;
}
</pre>
</div>

<p>
重启可以分为热启动（hotstart）、暖启动（warmstart）和冷启动（coldstart）。热启动从一个活跃的状态启动，类似接管。暖启动从持久存储器启动，冷启动则从归档启动。通常说的重启指的就是暖启动。在重启时，系统读取最近的检查点，并正向扫描日志到末尾，以重构事务管理器的状态。然后开始恢复资源管理器，把检查点记录发送给资源管理器，并从底线开始执行REDO扫描。REDO完成后，事务启动一个UNDO扫描，让资源管理器回到最近的持久保存点。在重启时，事务可能处于以下状态：
</p>
<ul class="org-ul">
<li>已完成。事务已经提交或中止，并在持久性日志中完成了记录。</li>
<li>正在完成。事务已经做出提交或中止的决定，并将提交记录写入日志，但是一些资源管理器可能还没有收到阶段2的调用。</li>
<li>持久状态。事务的输出还是不确定的，可能是一个远程提交协调者的“准备就绪”分布式事务，也可能处于一个持久性保存点上。事务还不能提交或中止。</li>
<li>活动状态。事务已经完成了一些工作，但是还没有建立一个持久化的保存点。这样的事务在重启时会被中止。</li>
</ul>

<p>
事务管理器的重启逻辑。系统重启时，TP监控器启动日志管理程序、事务管理器和其他已经安装的资源管理器。TP监控器调用每个资源管理器的rm_startup()回调函数。事务管理器从日志管理程序中得到最近检查点日志记录的LSN，事务管理器根据检查点记录重建资源管理器表和事务表，然后正向扫描日志，读取事务日志来更新这些表。当它发现一个开始事务的日志时，就分配一个TransCB。当它发现一个提交完成或中止完成日志时，就释放相关的TransCB。当它发现任意类型的保存点日志时，就更新TransCB、参与的资源管理器列表以及事务相关的会话列表。下面是完成一个单事务管理器日志记录REDO操作的示例：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">REDO</span>(<span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">lsn</span>) {
    <span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">trans</span>;
    <span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">him</span>;
    <span style="color: #228b22;">TM_savepoint</span> <span style="color: #a0522d;">save</span>;
    <span style="color: #228b22;">log_record_header</span> <span style="color: #a0522d;">header</span>;
    log_read_lsn(lsn, &amp;header, save, <span style="color: #a020f0;">sizeof</span>(save));
    him = header(trid);
    <span style="color: #a020f0;">switch</span>(save.record_type) {
    <span style="color: #a020f0;">case</span> Begin:
        allocate_transcb();
        <span style="color: #a020f0;">break</span>;
    <span style="color: #a020f0;">case</span> Save:
    <span style="color: #a020f0;">case</span> Prepare:
    <span style="color: #a020f0;">case</span> Commit:
    <span style="color: #a020f0;">case</span> Abort:
        trans = &amp;TransCB;
        copy_save_to_trans();
        copy_save_to_trans_rm_list();
        copy_save_to_trans_session_list();
        <span style="color: #a020f0;">break</span>;
    <span style="color: #a020f0;">case</span> Commit_complete:
    <span style="color: #a020f0;">case</span> Abort_complete:
        deallocate_transcb();
        <span style="color: #a020f0;">break</span>;
    }
}
</pre>
</div>

<p>
对于不能确定的事务，事务管理器启动一个进程执行coordinator_failure()例程，不断向远程协调者询问事务状态，并根据结果执行。同样的，对于正在提交或正在中止的联出会话，事务管理器建立session_failure()进程，不断的将commit()或abort()消息发给对方。
</p>


<p>
事务管理器失败后，可能会忘记自己最后分配的几个事务标识符，因为事务标识符计数器只是在检查点上是持久的。这个事务标识符可能被发送到了其他节点上。为了避免重复，事务管理器在重启时要增加顺序计数器的值。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">transaction_manager_restart</span>(<span style="color: #228b22;">void</span>) {
    <span style="color: #228b22;">TM_checkpoint</span> <span style="color: #a0522d;">tm_checkpoint</span>;
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">checkpoint_lsn</span>;
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">rmid</span>;
    <span style="color: #228b22;">TRID</span> <span style="color: #a0522d;">trid</span>;
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">lsn</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">sqlcode</span>;
    <span style="color: #228b22;">log_reader_header</span> <span style="color: #a0522d;">header</span>;

    checkpoint_lsn = log_read_anchor();
    log_read_lsn(checkpoint_lsn, header, tm_checkpoint, <span style="color: #a020f0;">sizeof</span>(tm_checkpoint));
    TM_anchor.checkpoint_lsn = checkpoint_lsn;
    TM_anchor.next_trid = tm_checkpoint.TM_ahcnor.next_trid + BIG;  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36991;&#20813;&#37325;&#22797;&#12290;</span>
    declare_cursor_for_the_log(<span style="color: #8b2252;">"select rmid,trid,lsn from log where lsn&gt;checkpoint_lsn order by lsn ascending;"</span>);
    open_cursor_the_log();
    <span style="color: #a020f0;">while</span> (<span style="color: #008b8b;">true</span>) {
        fetch_the_log_into(rmid, trid, lsn);
        <span style="color: #a020f0;">if</span> (sqlcode !=0) {
            <span style="color: #a020f0;">break</span>;
        }
        resume_transaction(trid);
        <span style="color: #a020f0;">if</span> (rmid == TMID) {
            TMID.redo(lsn);
        } <span style="color: #a020f0;">else</span> {
            join_work(rmid, trid);
        }

        log_transaction(lsn);
    }

    close_cursor_the_log();
    <span style="color: #a0522d;">TM_checkpoint</span>();
    <span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">tx</span>: completing_transaction) {
        <span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">ses</span>: outgoing_session) {
            session_failure(&amp;ses);
        }
    }

    <span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">ses</span>: double_transaction) {
        coordinator_failure(&amp;ses);
    }
}
</pre>
</div>

<p>
资源管理器重启逻辑。
在系统重启时，TP监控器调用rm_startup()回调来通知资源管理器重启。资源管理器执行一些内部的初始化工作。当准备好进行恢复时，资源管理器通过事务管理器的identifiy()发出通知。identify()调用事务管理器内部的信号量，等待事务管理器完成重启。对于简单资源管理器，identify()将其标记为up并返回。对于复杂资源管理器，事务管理器通过一系列回调来完成资源管理器的恢复。首先使用资源管理器的最近检查点LSN为参数，调用rm_restart()，并为资源管理器的每个日志调用rmid.REDO()。REDO扫描完成后，事务管理器找到资源管理器参与的活跃事务列表，为每个正在提交的事务调用rmid.commit()。对正在中止的事务进行UNDO扫描。这些工作完成后，将资源管理器标记为up，并返回资源管理器。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b22222;">// </span><span style="color: #b22222;">&#24674;&#22797;&#19968;&#20010;down&#36164;&#28304;&#31649;&#29702;&#22120;</span>
<span style="color: #0000ff;">REDO_recovery</span>(<span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">rmid</span>, <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">rmid_low_water_lsn</span>) {
    declare_cursor_rm_recovery(<span style="color: #8b2252;">"select lsn,trid from log where rmid=:rmid and lsn&gt;=:rmid_low_water_lsn order by lsn ascending;"</span>);
    <span style="color: #a020f0;">do</span> {
        exec_sql_fetch_rm_recovery_into(lsn, trid);
        <span style="color: #a020f0;">if</span> (sqlcode != 0) {
            <span style="color: #a020f0;">break</span>;
        }
        resume_transaction(trid);
        rmid.REDO(lsn);
    } <span style="color: #a020f0;">while</span> (<span style="color: #008b8b;">true</span>);
    exec_sql_close_rm_recovery();
}
</pre>
</div>

<p>
对于正在提交的事务，事务管理器调用
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">rm_commit</span>(<span style="color: #228b22;">TransCB</span>* <span style="color: #a0522d;">trans</span>, <span style="color: #228b22;">RMTransCB</span>* <span style="color: #a0522d;">rm</span>) {
    <span style="color: #228b22;">TM_savepoint</span> <span style="color: #a0522d;">save</span>;
    <span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">rmid</span> = rm-&gt;rmid;
    resume_transaction(trans-&gt;trid);
    rmid.commit();

    deallocate_rm_transcb();
    <span style="color: #a020f0;">if</span> (trans-&gt;RM_list == <span style="color: #008b8b;">NULL</span> &amp;&amp;
        trans-&gt;ses_list == <span style="color: #008b8b;">NULL</span>) {
        trans-&gt;status = Committed;
        save.record_type = commit_complete;
        log_insert(save, <span style="color: #a020f0;">sizeof</span>(save));
        dequeue_and_free_transcb();
    }
}
</pre>
</div>

<p>
对于正在中止的事务，执行
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #0000ff;">UNDO_recovery</span>(<span style="color: #228b22;">RMID</span> <span style="color: #a0522d;">rmid</span>, <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">min_lsn</span>) {
    declare_cursor_undo_recovery(<span style="color: #8b2252;">"select lsn,trid from log where rmid=:rmid and lsn &gt;= :min_lsn order by lsn descending"</span>);
    exec_sql_open_undo_recovery();
    <span style="color: #a020f0;">do</span> {
        exec_sql_fetch_undo_recovery_int(lsn, trid);
        <span style="color: #a020f0;">if</span> (sqlcode != 0) {
            <span style="color: #a020f0;">break</span>;
        }
        <span style="color: #a020f0;">if</span> (status_transaction(trid) == Aborting ||
            status_transaction(trid) == Aborted) {
            resume_transaction(trans-&gt;trid);
            rmid.UNDO(lsn);
        } <span style="color: #a020f0;">while</span> (<span style="color: #008b8b;">true</span>);
        exec_sql_close_rm_recovery();
    }
}
</pre>
</div>

<p>
上面提到的设计中，资源管理器使用公共日志。一些系统的设计让资源管理器使用私有日志，这时资源管理器需要自己进行恢复，事务管理器唯一要做的是协调事务提交。
</p>


<p>
在上面的设计中，如果重启要恢复n个资源管理器，事务管理器需要对日志进行2n+1次扫描，恢复事务管理器时扫描一次，恢复一个资源管理器时扫描2次，一次REDO，一次UNDO。这里有一个优化的方法，即采用两次扫描。一次用于恢复事务管理器，一次用于恢复全部资源管理器。
</p>


<p>
如果某个资源管理器发生失败，资源管理器声明自己为down，并要求重启。如果资源管理器对事务的提交请求、UNDO请求或检查点请求没有响应，事务管理器也可以判定资源管理器失败，并标记为down。在恢复之前，失败的资源管理器不能加入任何事务。当资源管理器失败时，其所有参与的事务，除了准备就绪、正在提交和处于持久状态的事务外，其余事务都被中止和回滚。其他的资源管理器完成自己的UNDO逻辑。但是由于down资源管理器没有参与，不能写入中止完成日志。当失败的资源管理器重启时，在调用事务管理器的identify()例程时，事务管理器恢复该资源管理器，对中止事务进行UNDO扫描，。
</p>
</div>
</div>

<div id="outline-container-org91029ef" class="outline-2">
<h2 id="org91029ef">高级事务管理器主题</h2>
<div class="outline-text-2" id="text-org91029ef">
<p>
对于异构型提交协调者，提交协议可以分为开放式提交协议和封闭式提交协议。在开放式提交协议中，资源管理器可以参与提交决定，并且提交消息的格式和提交协议本身是公开的。在封闭式提交协议中，资源管理器不能参与提交，内部细节也是私有的。如果一个事务处理监控器是开放式的，并且遵循两阶段提交协议，可以实现一个事务网关（gateway）完成该协议和一个标准协议之间的转换。对于封闭式事务管理器，编写这样的网关几乎是不可能的。如果系统由一组开放式事务管理器和一个单一的封闭事务管理器组成，可以将封闭事务管理器作为协调者，在每个开放式事务管理器就绪后，要求封闭式事务管理器提交。这样可以实现系统的原子性。
</p>


<p>
到目前为止的讨论主要集中在可靠性上。如何建立一个高可用的事务管理器？即一个处理器或通信连接失败后，事务管理器如何运行？一个直接的解决办法是双工操作。首先要将日志管理器做成高可用的，将日志管理器作为一个进程对运行，每个日志文件是双工的。事务管理器也使用进程对技术对硬件故障和软件故障进行容错。这样的提交协调者叫做非阻塞的，因为它不会由于失败而引发阻塞。分布式系统的容错模型稍有不同。在分布式系统中，进程失败和会话失败都会导致两个进程无法通信。会话失败的情况叫做网络分片失败（network partition failure）。如果发生网络分片失败，分布式事务的非阻塞协议必须允许多数节点宣布少数节点失败。
</p>


<p>
对两阶段提交协议的优化主要从三个方面来平价：
</p>
<ul class="org-ul">
<li>延迟。做出提交决定所话费的时间。</li>
<li>消息代价。必须发送的消息数量。</li>
<li>写代价。磁盘强制写的次数。</li>
</ul>

<p>
对于远程场地的灾难恢复，可以使用系统对。每个客户同两个系统保持会话，当一个系统失败时，另一个系统继续执行该事务，并完成事务的提交和消息发送，或中止未完成的事务。系统对有多种配置方法，比如单系统对，由一个主系统和一个后备系统（也叫热待命系统hot standby system）组成。根据高吞吐量、高可用性和高完整性的要求，系统对可以分为一级安全（1-safe）、二级安全（2-safe）和极其安全（very safe）。在一级安全设计中，主事务管理器执行标准提交逻辑，通过异步方式向后备系统进行假脱机处理（spooled）。这种设计存在丢失事务的风险。二级安全设计在第一阶段结束前将事务日志发送给后备系统，在后备系统响应（或失败）前，主事务管理器不能进行提交。极其安全设计则要求主备两个事务管理器都同意提交时才能提交。
</p>
</div>
</div>


<div id="outline-container-org44a6f69" class="outline-2">
<h2 id="org44a6f69">文件和缓冲区管理</h2>
<div class="outline-text-2" id="text-org44a6f69">
<p>
从抽象的角度，外存可以看成是文件的集合。在主存中存取文件有三种不同的方法：读写映射技术、内存映射文件（memory mapped file）和这两种方法的结合。C语言中的fopen函数使用的就是读写映射技术。这种技术将文件和主存看做具有不同擦欧洲哦特性的外部地址空间，文件中的元素必须显式的复制到内存。内存映射文件技术将文件作为一个整体复制到一块连续的主存区域，在存储文件时和存取主存没有差别。内存映射文件技术需要考虑主存和外存同步的问题。
</p>


<p>
在基本文件系统层，每个文件看成是一个块的阵列，一个块是一个定长字符串。为了简化设计，我们假设基本文件系统的所有文件具有相同的块大小。在文件内部，块从0开始编号。只要磁盘空间允许，文件的块数可以动态的增加或减少。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">EIGHTK</span> 8192
<span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #228b22;">FILENO</span>;
<span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #228b22;">BLOCKID</span>;
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">flip</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20889;&#26816;&#26597;&#27169;&#24335;&#65288;&#21069;&#65289;</span>
    <span style="color: #228b22;">FILENO</span> <span style="color: #a0522d;">fileno</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#22359;&#25152;&#23646;&#30340;&#25991;&#20214;&#21495;</span>
    <span style="color: #228b22;">BLOCKID</span> <span style="color: #a0522d;">blockno</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25991;&#20214;&#20869;&#30456;&#23545;&#22359;&#21495;</span>
} <span style="color: #228b22;">BLOCKHEAD</span>;

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">BLOCKHEAD</span> <span style="color: #a0522d;">header</span>;
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">contents</span>[EIGHTK-<span style="color: #a020f0;">sizeof</span>(header)-2];
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">flop</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20889;&#26816;&#26597;&#27169;&#24335;&#65288;&#21518;&#65289;</span>
} <span style="color: #228b22;">BLOCK</span>, *<span style="color: #228b22;">BLOCKP</span>;
</pre>
</div>
<p>
flip和flop字段用来检查块是否被完成写入。每次写操作完成后，这两个值都取反。在读取时，如果发现flip不等于flop，就知道这个块的写入失败了。另一种方法是计算检查和并存储在块中。基本文件系统的接口如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">enum</span> <span style="color: #228b22;">STATUS</span> = {OK, FAILED};
<span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">char</span>* <span style="color: #228b22;">filename</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25991;&#20214;&#21517;</span>
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span>{} <span style="color: #228b22;">FILE</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25991;&#20214;&#21477;&#26564;</span>
<span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">FILE</span>* <span style="color: #228b22;">FILEID</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">char</span> <span style="color: #228b22;">ACCESSMODE</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#35835;&#65288;R&#65289;&#25110;&#26356;&#26032;&#65288;U&#65289;</span>
<span style="color: #228b22;">int</span> <span style="color: #a0522d;">blockcount</span>;

<span style="color: #228b22;">STATUS</span> <span style="color: #0000ff;">create</span>(<span style="color: #228b22;">filename</span>, allocparam);
STATUS <span style="color: #a020f0;">delete</span>(filename);
<span style="color: #228b22;">STATUS</span> <span style="color: #0000ff;">open</span>(<span style="color: #228b22;">filename</span>, <span style="color: #228b22;">ACCESSMODE</span>, <span style="color: #228b22;">FILEID</span>);
<span style="color: #228b22;">STATUS</span> <span style="color: #0000ff;">close</span>(<span style="color: #228b22;">FILEID</span>);
<span style="color: #228b22;">STATUS</span> <span style="color: #0000ff;">extend</span>(<span style="color: #228b22;">FILEID</span>, allocparam); <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25193;&#23637;&#19968;&#20010;&#24050;&#23384;&#22312;&#30340;&#25991;&#20214;</span>
<span style="color: #228b22;">STATUS</span> <span style="color: #0000ff;">read</span>(<span style="color: #228b22;">FILEID</span>, BLOCKID, BLOCKP);
<span style="color: #228b22;">STATUS</span> <span style="color: #0000ff;">readc</span>(<span style="color: #228b22;">FILEID</span>, BLOCKID, blockcount, BLOCKP); <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36830;&#32493;&#35835;</span>
<span style="color: #228b22;">STATUS</span> <span style="color: #0000ff;">write</span>(FILED, BLOCKID, BLOCKP);
<span style="color: #228b22;">STATUS</span> <span style="color: #0000ff;">writec</span>(FILED, BLOCKID, BLOCKP); <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36830;&#32493;&#20889;</span>
</pre>
</div>

<p>
第一个要考虑的问题是如何将文件的块号转换到物理磁盘和槽地址。磁盘地址由四元素&lt;磁盘标识,柱面号,磁道号,槽号&gt;（&lt;disk-id,cyl-no,track-no,slot-no&gt;）组成。我们假设一个槽容纳一个块。通常磁盘和文件之间存在n:m的关系：一个磁盘可以容纳多个文件，一个文件的各部分可以分布在多个磁盘上。连续的文件号不一定分配在连续的槽上。在暂时忽略块号-槽号映射的情况下，磁盘空间分配包括以下几个问题：
</p>
<ul class="org-ul">
<li>初始分配。创建文件时，给它分配多少个连续的槽？</li>
<li>增量式扩展。如果文件增长超过了已分配的槽数，需要再分配多少个槽？</li>
<li>重组。什么时候合并空闲的槽碎片，以获得最大连续空闲槽组？</li>
</ul>

<p>
这些问题将在下面同地址转换问题一起讨论。在处理地址转换问题时，通常假设磁盘上有一部分用来记录哪些槽是空闲的。主要有两种策略：一是使用链表，从一个目录项开始连接空闲槽（组）。二是使用位图。每个槽用一个比特表示是否已经分配。
</p>

<p>
静态连续分配。这是最简单的分配技术，文件被允许拥有的最大块数在创建文件时一次性的连续分配。在这种方式下，地址转换非常容易。假设槽s[b]存放文件的0号块，那么k号块就保存在s[b+k]号槽中。这种方式有利于直接块存取和随机存取，但是文件不能动态调整大小。
</p>

<p>
基于区段（extent-based）的分配。这种方式适合于允许动态增长和缩小的文件，基本思想是进行多次连续分配。文件获得的一段连续槽空间叫做区段（extent）。在建立文件时获得的区段叫做主分配（primary allocation），后续获得的区段叫做辅助分配（secondary allocation）。这种方式下，文件的目录项包含一个数值，记录文件的分配信息。在创建或扩展文件时，空间分配通常有调用者传入的参数决定。其参数allocparmp通常类似
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">allocparm</span> {
    <span style="color: #228b22;">uint</span> <span style="color: #a0522d;">primary</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21021;&#22987;&#20998;&#37197;&#22823;&#23567;</span>
    <span style="color: #228b22;">uint</span> <span style="color: #a0522d;">secondary</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25193;&#23637;&#20998;&#37197;&#22823;&#23567;</span>
    <span style="color: #228b22;">float</span> <span style="color: #a0522d;">growth</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25193;&#23637;&#20998;&#37197;&#22686;&#38271;&#22240;&#23376;</span>
};
</pre>
</div>

<p>
单槽分配。如果区段的大小正好是一个槽，这种情况下就叫做单槽分配。早期UNIX文件系统采用这种方式，文件目录项中包含一个长度为13的槽指针，前面10个元素各指向一个槽，后面三个元素分别指向长度为n、n^2和n^3的槽组。这样文件就具有了10+n+n^2+n^3的寻址能力。在最初的UNIX系统中，n是128。这种设计适用于系统中存在大量小文件的情况。
</p>

<p>
从上面的讨论可以看出，一，空间分配必须快速的完成块号到磁盘地址的转换，“快速”意味着没有I/O操作。二，空间分配应该尽可能分配物理上相邻的磁盘块，以便支持快速顺序存取。
</p>

<p>
伙伴系统。这里的伙伴指的是相邻的同样大小的区段。这种方式只允许某些预定义的区段大小。如果一个区段包含2^i个连续的槽，就称它是i类型的。同样类型的空闲区段链接在一个链表上。在请求分配空间p时，系统寻找t=ceiling(log2(p))的空闲区段。如果没有这样的空闲区段，系统找到一个t+1类型的区段，分割成两个t类型区段，一个用于分配，另一个加入空闲链表。在删除文件时，文件使用的区段返经过合并后还给链表。伙伴系统的优势在于，首先，回收的时间往往是常数时间，最差情况下也是对数时间。其次，分配的精度可以达到一个块。第三，可以自适应动态增长文件的自动空间分配。伙伴系统的缺点在于容易受到碎片的影响。如果分配了太多不是伙伴的小区段，则难以合并或分配大区段。因此需要周期性的进行磁盘压缩，使小区段邻接。
</p>

<p>
地址空间映射和空闲区段信息需要数据结构来维护，它们必须存储在持久存储器中，是系统目录的一部分。系统目录是名字绑定和地址转换都需要的。
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">maxextents</span> 1000
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">basic_file_descriptor</span> {
    <span style="color: #228b22;">FILEID</span> <span style="color: #a0522d;">fileno</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25991;&#20214;&#21495;</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">filename</span>[];
    <span style="color: #228b22;">uint</span> <span style="color: #a0522d;">partition_no</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25991;&#20214;&#20998;&#29255;&#32534;&#21495;</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">version_no</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#29256;&#26412;&#21495;</span>
    <span style="color: #228b22;">allocparm</span> <span style="color: #a0522d;">space_request</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20027;&#21306;&#27573;&#21644;&#36741;&#21161;&#21306;&#27573;</span>
    <span style="color: #228b22;">uint</span> <span style="color: #a0522d;">curr_no_extends</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#24050;&#20998;&#37197;&#21306;&#27573;&#25968;</span>
    <span style="color: #a020f0;">struct</span> {
        <span style="color: #228b22;">char</span> <span style="color: #a0522d;">diskid</span>[]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#30913;&#30424;&#26631;&#35782;</span>
        <span style="color: #228b22;">uint</span> <span style="color: #a0522d;">ext_no</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21306;&#27573;&#34920;&#32034;&#24341;</span>
        <span style="color: #228b22;">uint</span> <span style="color: #a0522d;">accum_length</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20174;&#20197;&#21069;&#21306;&#27573;&#30340;&#32047;&#35745;&#38271;&#24230;</span>
    } <span style="color: #a0522d;">curr_alloc</span>[maxextents];
};

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">xt_per_disk</span> BIG
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">extent_entry</span> {
    <span style="color: #228b22;">long</span> <span style="color: #a0522d;">first_slot</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21306;&#27573;&#36215;&#22987;&#27133;&#21495;</span>
    <span style="color: #228b22;">uint</span> <span style="color: #a0522d;">xt_length</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21306;&#27573;&#25317;&#26377;&#30340;&#27133;&#25968;</span>
};
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">extent_entry</span> <span style="color: #a0522d;">extent_table</span>[xt_per_disk];
</pre>
</div>

<p>
数据库缓冲区是基本文件系统和面向元素的文件系统之间的调解器（mediator）。缓冲区管理器的主要目的是使得页面在主存中可以寻址，并且同日志管理程序和恢复管理器协调一致的向磁盘写页面。每个元组由存储它的页面标识符和页面内偏移量定位。页面标识符结构如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">FILENO</span> <span style="color: #a0522d;">fileno</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#39029;&#38754;&#25152;&#23646;&#30340;&#25991;&#20214;&#21495;</span>
    <span style="color: #228b22;">uint</span> <span style="color: #a0522d;">pageno</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25991;&#20214;&#20013;&#30340;&#39029;&#38754;&#21495;</span>
} <span style="color: #228b22;">PAGEID</span>, *<span style="color: #228b22;">PAGEIDP</span>;
</pre>
</div>
<p>
在每个文件中，页面号从0开始增长。数据库存取模块通过&lt;page-id,offset&gt;的二元素引用它们的对象。为了在对象上执行指令，对象必须被加载的主存中，这个工作由缓冲区管理器完成。缓冲区管理器管理虚拟内存中的一个分段，分段被分割成相同大小的部分，每个部分叫做一个框架（frame？），一个框架正好可以容纳一个页面。数据库缓冲区可以定义为一个简单的数据结构：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">buffersize</span> MANY
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">hashsize</span> PRIME

<span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">PAGE_HEADER</span> <span style="color: #a0522d;">page_header</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25991;&#20214;&#20013;&#19968;&#20010;&#39029;&#38754;&#30340;&#22836;&#37096;</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">page_body</span>[]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#39029;&#38754;&#30340;&#26377;&#25928;&#20869;&#23481;</span>
} <span style="color: #a0522d;">bufferpool</span>[buffersize];
</pre>
</div>

<p>
如果一个高层模块需要存取页面P上偏移量O处的数据，它会以P为参数调用缓冲区管理器，然后缓冲区管理器执行以下操作：
</p>
<ul class="org-ul">
<li>在缓冲区中搜索。如果找到页面，返回包含它的框架地址F给调用者。</li>
<li>寻找空闲框架，即不包含有效页面的框架。</li>
<li>决定被替换的框架。把一个页面移出缓冲区。如果找不到这样的页面，进行错误处理。</li>
<li>刷写磁盘。如果即将被替换的页面在缓冲区中修改过了，采用先写日志协议（WAL）写回磁盘。</li>
<li>建立框架地址。确定使用哪个框架来容纳所请求的页面，将其地址记为F。</li>
<li>确定块的地址。利用文件目录和基本文件描述符，把请求的page-id p转换为FILEID和一个块号，检查文件是否打开，把块读取到框架中。</li>
<li>返回。把框架地址F返回给调用者。</li>
</ul>

<p>
为了避免发生更新失败，缓冲区管理器自己管理页面，而不会将数据副本发送给调用者的地址空间。缓冲区管理器可以提供共享、寻址能力、信号量保护和永久存储。我们假定所有对缓冲区管理器的服务请求都引用缓冲区存取控制块（buffer access control block），它的结构如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">PAGEID</span> <span style="color: #a0522d;">pageid</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25991;&#20214;&#20013;&#30340;&#39029;&#38754;&#32534;&#21495;</span>
    <span style="color: #228b22;">PAGEPTR</span> <span style="color: #a0522d;">pageaddr</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#32531;&#20914;&#21306;&#20013;&#30340;&#39029;&#38754;&#22320;&#22336;</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">index</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#39029;&#38754;&#20869;&#30340;&#35760;&#24405;</span>
    <span style="color: #228b22;">semaphore</span>* <span style="color: #a0522d;">pagesem</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20449;&#21495;&#37327;</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">modified</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26159;&#21542;&#20462;&#25913;</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">invalid</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26159;&#21542;&#21487;&#29992;</span>
} <span style="color: #228b22;">BUFFER_ACC_CB</span>, *<span style="color: #228b22;">BUFFER_ACC_CBP</span>;

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">bufferfix</span>(<span style="color: #228b22;">PAGEID</span> <span style="color: #a0522d;">pageid</span>, <span style="color: #228b22;">LOCK_MODE</span> <span style="color: #a0522d;">mode</span>, <span style="color: #228b22;">BUFFER_ACC_CBP</span> *<span style="color: #a0522d;">address</span>);
</pre>
</div>

<p>
如果缓冲区管理器决定将重新分配一个框架，那么可能存在两个进程，一个进程认为页面P存储在这个框架，另一个认为页面Q存储在这个框架。这个问题通常使用FIX-USE-UNFIX协议解决：
</p>
<ul class="org-ul">
<li>固定。客户使用bufferfix接口请求存储一个页面，这个页面被固定在缓冲区中，不能被替换。</li>
<li>使用。客户使用页面。这时指向页面的框架的指针有效。</li>
<li>取消固定。客户告诉缓冲区管理器取消固定，页面可以被替换。</li>
</ul>

<p>
取消固定的接口如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">bool</span> <span style="color: #0000ff;">bufferunfix</span>(BUFFER_ACC_CBP);
</pre>
</div>

<p>
几个事务可以对一个缓冲区页面进程并发的读，这时，每个事务都会固定这个页面，页面直到所有事务都调用了bufferunfix()后，才可以被替换。bufferfix和bufferunfix时数据库系统中最频繁使用的两个原语，也是缓冲区管理器提供的基本接口，此外，缓冲区管理器还提供另外两个接口：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b22222;">// </span><span style="color: #b22222;">&#36820;&#22238;&#19968;&#20010;&#31354;&#39029;&#38754;</span>
<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">emptyfix</span>(<span style="color: #228b22;">PAGEID</span> <span style="color: #a0522d;">pageid</span>, <span style="color: #228b22;">LOCK_MODE</span> <span style="color: #a0522d;">mode</span>, <span style="color: #228b22;">BUFFER_ACC_CBP</span> <span style="color: #a0522d;">address</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">&#21047;&#20889;&#39029;&#38754;</span>
<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">flush</span>(BUFFER_ACC_CB);
</pre>
</div>


<p>
数据库缓冲区实际上是一个框架的阵列，每个框架容纳一个页面。这个阵列上必须提供如下的接口：
</p>
<ul class="org-ul">
<li>快速存取。对给定的PAGEID，必须快速的定位其在缓冲区中的合适入口，或确定其不再缓冲区中。</li>
<li>正确的控制信息。必须透明的维护提供给客户的控制块，包括信号量和空闲空间计数器。</li>
<li>局部性。必须收集足够的信息以便找到一个用于替换的“好”框架。</li>
<li>与恢复管理器协作。必须提供事务管理器所需要的信息（检查点数据、最小页LSN等）。</li>
<li>有效的文件存取。必须驱动底层（面向块）的文件系统。</li>
</ul>

<p>
缓冲区使用的数据结构如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">buffersize</span> MANY
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">delta</span> SMALL
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">hashsize</span> PRIME
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">MAXLSN</span> VERY_LARGE_VALUE

<span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">PAGE_HEADER</span> <span style="color: #a0522d;">page_header</span>;
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">page_body</span>[];
} <span style="color: #a0522d;">bufferpool</span>[buffersize]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#32531;&#20914;&#21306;</span>

<span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">uint</span> <span style="color: #a0522d;">free_index</span>;
} <span style="color: #a0522d;">free_frames</span>[buffersize];

<span style="color: #228b22;">ulong</span> <span style="color: #a0522d;">no_free_frames</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#24403;&#21069;&#31354;&#38386;&#26694;&#26550;&#25968;</span>
<span style="color: #228b22;">semaphore</span> <span style="color: #a0522d;">free_frame_sem</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20445;&#25252;&#31354;&#38386;&#26694;&#26550;&#32034;&#24341;&#30340;&#20449;&#21495;&#37327;</span>

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">PAGEID</span> <span style="color: #a0522d;">pageid</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#32531;&#20914;&#21306;&#20013;&#30340;&#39029;&#38754;&#21495;&#65292;0&#34920;&#31034;&#27809;&#26377;&#39029;&#38754;</span>
    <span style="color: #228b22;">FILEID</span>* <span style="color: #a0522d;">in_file</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25991;&#20214;&#21477;&#26564;</span>
    <span style="color: #228b22;">uint</span> <span style="color: #a0522d;">frame_index</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#22312;&#32531;&#20914;&#21306;&#20013;&#30340;&#32034;&#24341;</span>
    <span style="color: #228b22;">semaphore</span> <span style="color: #a0522d;">pagesem</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20445;&#25252;&#39029;&#38754;&#30340;&#20449;&#21495;&#37327;</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">modified</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26159;&#21542;&#20462;&#25913;&#36807;&#12290;</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">fixcount</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#24403;&#21069;&#35831;&#27714;&#22266;&#23450;&#30340;&#27169;&#22359;&#25968;</span>
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">forminlsn</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31532;&#19968;&#20010;&#20026;&#26356;&#26032;&#32780;&#22266;&#23450;&#30340;LSN</span>
    <span style="color: #228b22;">BUFFER_CBP</span> <span style="color: #a0522d;">prev_in_LRU</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">LRU&#38142;&#20013;&#30340;&#21069;&#19968;&#20010;&#39029;&#38754;</span>
    <span style="color: #228b22;">BUFFER_CBP</span> <span style="color: #a0522d;">next_in_LRU</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">LRU&#38142;&#20013;&#30340;&#19979;&#19968;&#20010;&#39029;&#38754;</span>
    <span style="color: #228b22;">BUFFER_CBP</span> <span style="color: #a0522d;">next_in_hclass</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25955;&#21015;&#28322;&#20986;&#38142;&#30340;&#27491;&#21521;&#25351;&#38024;</span>
} <span style="color: #228b22;">BUFFER_CB</span>, *<span style="color: #228b22;">BUFFER_CBP</span>;

<span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">semaphore</span> <span style="color: #a0522d;">class_sem</span>;
    <span style="color: #228b22;">BUFFER_CBP</span> <span style="color: #a0522d;">first_bcb</span>;
} <span style="color: #a0522d;">buffer_hash</span>[hashsize];

<span style="color: #228b22;">BUFFER_CBP</span> <span style="color: #a0522d;">mru_page</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26368;&#36817;&#20351;&#29992;&#30340;&#39029;&#38754;</span>
<span style="color: #228b22;">BUFFER_CPB</span> <span style="color: #a0522d;">lru_page</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26368;&#20037;&#26410;&#20351;&#29992;&#30340;&#39029;&#38754;</span>
<span style="color: #228b22;">semaphore</span> <span style="color: #a0522d;">LRU_sem</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20445;&#25252;LRU&#38142;&#30340;&#20449;&#21495;&#37327;</span>
<span style="color: #228b22;">BUFFER_CBP</span> <span style="color: #a0522d;">free_cb_list</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31354;&#38386;&#32531;&#20914;&#21306;</span>
<span style="color: #228b22;">uint</span> <span style="color: #a0522d;">no_free_cbs</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31354;&#38386;&#32531;&#20914;&#21306;&#25968;&#37327;</span>
<span style="color: #228b22;">semaphore</span> <span style="color: #a0522d;">free_cb_sem</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20445;&#25252;&#31354;&#38386;&#32531;&#20914;&#21306;&#38142;&#34920;&#30340;&#20449;&#21495;&#37327;</span>

<span style="color: #228b22;">BUFFER_ACC_CBP</span> <span style="color: #a0522d;">free_acc_cb_list</span>;
<span style="color: #228b22;">uint</span> <span style="color: #a0522d;">no_free_acc_cbs</span>;
<span style="color: #228b22;">semaphore</span> <span style="color: #a0522d;">free_acb_sem</span>;
</pre>
</div>


<p>
缓冲区的初始化步骤如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">uint</span> <span style="color: #a0522d;">i</span>;
<span style="color: #a020f0;">for</span> (i = 0; i &lt; buffersize; i++) {
    free_frames[i].free_index = i;
 }

no_free_frames = buffersize;

initsem(free_frame_sem);
mru_page = <span style="color: #008b8b;">NULL</span>;
lru_page = <span style="color: #008b8b;">NULL</span>;

initsem(&amp;LRU_sem);

<span style="color: #228b22;">BUFFER_CBP</span> <span style="color: #a0522d;">new_cb</span>;
<span style="color: #a020f0;">for</span> (i = 0; i &lt; hashsize; i++) {
    buffer_hash[i].first_bcb  = <span style="color: #008b8b;">NULL</span>;
    xsem_init(&amp;buffer_hash[i].xsemaphore);
 }

new_cb = alloc(<span style="color: #a020f0;">sizeof</span>(BUFFER_CB));
free_cb_list = new_cb;
i = 0;
<span style="color: #a020f0;">while</span> (i &lt;buffersize + delta) {
    new_cb -&gt; pageid = 0;
    new_cb -&gt; frame_index = -1;
    sem_init(&amp;(new_cb-&gt;pagesme));
    new_cb-&gt;prev_in_LRU = <span style="color: #008b8b;">NULL</span>;
    new_cb-&gt;next_in_LRU = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #a020f0;">if</span> (i == (buffersize - 1)) {
        new_cb-&gt;next_in_hclass = <span style="color: #008b8b;">NULL</span>;
    } <span style="color: #a020f0;">else</span> {
        new_cb-&gt;new_in_hclass = alloc(<span style="color: #a020f0;">sizeof</span>(BUFFER_CB));
        new_cb = new_cb-&gt;next_in_hclass;
    }
    i++;
 }

no_free_cbs = buffersize + delta;
sem_init(&amp;free_cb_sem);
</pre>
</div>

<p>
由于分配/释放的频率很高，缓冲区控制块不应该在需要时才分配/释放。缓冲区预先分配一定数目（通常是3*buffersize）的控制块，然后在空闲链表上工作。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">BUFFER_CBP</span> <span style="color: #0000ff;">get_bcb</span>();
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">give_bcb</span>(<span style="color: #228b22;">BUFFER_CBP</span>);
<span style="color: #228b22;">BUFFER_ACC_CBP</span> <span style="color: #0000ff;">get_acb</span>();
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">give_acb</span>(<span style="color: #228b22;">BUFFER_ACC_CBP</span>);
<span style="color: #228b22;">uint</span> <span style="color: #0000ff;">hashpage</span>(PAGEID);
<span style="color: #228b22;">HANDLE</span> <span style="color: #0000ff;">find_filecb</span>(PAGEID);
<span style="color: #228b22;">LSN</span> <span style="color: #0000ff;">log_max_lsn</span>();


<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">bufferfix</span>(<span style="color: #228b22;">PAGEID</span> <span style="color: #a0522d;">pagein</span>, <span style="color: #228b22;">LOCK_MODE</span> <span style="color: #a0522d;">mode</span>, <span style="color: #228b22;">BUFFER_ACC_CBP</span> <span style="color: #a0522d;">address</span>) {
    <span style="color: #228b22;">uint</span> <span style="color: #a0522d;">hash_index</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#30001;pageid&#35745;&#31639;&#20986;&#30340;&#25955;&#21015;&#30721;</span>
    <span style="color: #228b22;">BUFFER_CBP</span> <span style="color: #a0522d;">next_bcb</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#32531;&#20914;&#27424;&#27454;&#25511;&#21046;&#22359;&#25351;&#38024;</span>
    <span style="color: #228b22;">FILEID</span> <span style="color: #a0522d;">file_handler</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#38754;&#21521;&#22359;&#30340;&#25991;&#20214;</span>
    <span style="color: #228b22;">BLOCKID</span> <span style="color: #a0522d;">blockno</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21253;&#21547;&#39029;&#38754;&#30340;&#22359;</span>

 <span style="color: #008b8b;">retry</span>:
    hash_index = hashpage(pagein);
    sem_get(&amp;(buffer_hash[hash_index].class_sem), LOCK_S);
    next_bcb = buffer_hash[hash_index].first_bcb;
    <span style="color: #a020f0;">while</span> (next_bcb != <span style="color: #008b8b;">NULL</span>) {
        <span style="color: #a020f0;">if</span> (next_bcb-&gt;pageid == pagein) {
            <span style="color: #a020f0;">if</span> (!sem_get_bounce(&amp;(next_bcb-&gt;pagesem), LOCK_S)) {
                <span style="color: #a020f0;">if</span> (next_bcb -&gt; frame_index == -1) {
                    sem_give(&amp;(buffer_hash[hash_index].class_sem));
                    <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">retry</span>;
                }
            } <span style="color: #a020f0;">else</span> {
                sem_give(&amp;next_bcb-&gt;pagesem);
            }
            <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">p_found</span>:
        } <span style="color: #a020f0;">else</span> {
            next_cb = next_cb-&gt;next_in_hclass;
        }
    }

    next_cb = localte_page(pagein, hash_index);
 <span style="color: #008b8b;">p_found</span>:
    <span style="color: #a020f0;">if</span> (mode != LOCK_FREE) {
        <span style="color: #a020f0;">if</span> (mode == LOCK_S) {
            sem_get(&amp;next_bcb-&gt;pagesem, LOCK_S);
        } <span style="color: #a020f0;">else</span> {
            sem_get(&amp;next_bcb-&gt;pagesme, LOCK_X);
            next_bcb-&gt;fixcount = 1;
            <span style="color: #a020f0;">if</span> (next_bcb-&gt;forminlsn == MAXLSN) {
                next_bcb-&gt;forminlsn = log_max_lsn(MYLOG);
            }
        }
    }

    <span style="color: #a020f0;">if</span> (mode == LOCK_FREE || mode == LOCK_S) {
        next_bcb-&gt;fixcount++;
    }

    address = get_acb();
    address-&gt;pageid = next_bcb-&gt;pageid;
    address-&gt;pageaddr = &amp;(buffer_pool[next_bcb-&gt;frame_index].page_header);
    address-&gt;pagesem = &amp;(next_bcb-&gt;pagesem);
    address-&gt;index = -1;
    address-&gt;modified = <span style="color: #008b8b;">false</span>;
    address-&gt;invalid = <span style="color: #008b8b;">false</span>;
    sem_give(&amp;buffer_hash[hash_index].class_sem);
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}

<span style="color: #228b22;">BUFFER_CBP</span> <span style="color: #0000ff;">locate_page</span>(<span style="color: #228b22;">PAGEID</span> <span style="color: #a0522d;">this_page</span>, <span style="color: #228b22;">uint</span> <span style="color: #a0522d;">hash_index</span>) {

    <span style="color: #228b22;">BUFFER_CBP</span> <span style="color: #a0522d;">next_bcb</span>;
    <span style="color: #228b22;">RETCODE</span> <span style="color: #a0522d;">retcode</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">frame_no</span>;

    sem_get(&amp;free_cb_sem, LOCK_X);
    next_bcb = free_cb_list;
    no_free_cbs--;
    sem_give(&amp;free_cb_sem);
    file_handle = find_filecb(this_page);
    blockno = this_page.pageno;
    sem_get(&amp;next_bcb-&gt;pagesme, LOCK_X);
    next_bcb-&gt;frame_index = -1;
    next_bcb-&gt;pageid = this_page;
    next_bcb-&gt;in_file = file_handle;
    next_bcb-&gt;modified = <span style="color: #008b8b;">false</span>;
    next_bcb-&gt;fixcount = 0;
    next_bcb-&gt;forminlsn = MAXLSN;

    hash_index = hashpage(this_page);
    sem_get(&amp;buffer_hash[hash_index].class_sem, LOCK_X);
    <span style="color: #a020f0;">if</span> (buffer_hash[hash_index].first_bcb == <span style="color: #008b8b;">NULL</span>) {
        buffer_hash[hash_index].first_bcb = next_bcb;
        next_bcb-&gt;next_in_hclass = <span style="color: #008b8b;">NULL</span>;
    } <span style="color: #a020f0;">else</span> {
        next_bcb-&gt;next_in_hclass = buffer_hash[hash_index].first_bcb;
        buffer_hash[hash_index].first_bcb = next_bcb;
    }

    sem_give(&amp;buffer_hash[hash_indx].class_sem);

    frame_no = get_frame();
    retcode = read(file_handle, blockno, &amp;bufferpool[frame_no], page_header);
    next_bcb-&gt;frame_index = frame_no;
    sem_get(&amp;buffer_hash[hash_index].class_sem);
    sem_give(&amp;next_bcb-&gt;pagesem);
    <span style="color: #a020f0;">return</span> next_bcb;
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">get_frame</span>() {
    <span style="color: #228b22;">BUFFER_CBP</span> <span style="color: #a0522d;">next_bcb</span>, <span style="color: #a0522d;">temp_bcb</span>;
    <span style="color: #228b22;">uint</span> <span style="color: #a0522d;">frame_no</span>, <span style="color: #a0522d;">hash_index</span>;
    <span style="color: #228b22;">PAGEPTR</span> <span style="color: #a0522d;">pageaddr</span>;
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">fromlog</span>;
    <span style="color: #228b22;">PAGEID</span> <span style="color: #a0522d;">pageid</span>;

    sem_get(&amp;free_frame_sem, LOCK_X);
    <span style="color: #a020f0;">if</span> (no_free_frames &gt; 0) {
        frame_no = free_frames[no_free_frames-1].free_index;
        no_free_frames--;
        sem_give(&amp;free_frame_sem);
        <span style="color: #a020f0;">return</span> frame_no;
    }

    sem_give(&amp;free_frame_sem);
    sem_get(&amp;LRU_sem, LOCK_X);
    next_bcb = lru_page;
    <span style="color: #a020f0;">while</span> (next_bcb != <span style="color: #008b8b;">NULL</span>) {
        pageid = next_bcb-&gt;pageid;
        hash_index = hashpage(pageid);
        sem_get(&amp;buffer_hash[hash_index].class_sem, LOCK_X);
        <span style="color: #a020f0;">if</span> (next_bcb-&gt;pageid != pageid) {
            sem_give(&amp;buffer_hash[hash_index].class_sem);
            <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">next_younger</span>;
        }

        <span style="color: #a020f0;">if</span> (!sem_get_bounce(&amp;next_bcb-&gt;pagesem, LOCK_X) || next_bcb-&gt;fixcount &gt; 0) {
            sem_give(&amp;buffer_hash[hash_index].class_sem);
            <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">next_younger</span>;
        }

        sem_give(&amp;LRU_sem);
        sem_give(&amp;buffer_hash[hash_index].class_sem);
        <span style="color: #a020f0;">if</span> (modified) {
            pageaddr = &amp;buffer_pool[next_bcb-&gt;frame_index].page_header;
            fromlog = log_flush(pageaddr-&gt;safe_up_to, <span style="color: #008b8b;">false</span>);
            write_block_back_to_file();
        }

        frame_no = next_bcb-&gt;frame_index;
        sem_give(&amp;next_bcb-&gt;page_sem);
        <span style="color: #a020f0;">return</span> frame_no;
    <span style="color: #008b8b;">next_younger</span>:
        next_bcb = next_bcb-&gt;prev_in_LRU;
    }
}

</pre>
</div>

<p>
bufferunfix例程负责改变一个页面在LRU链中的位置。一个页面取消固定后，立即成为最近使用过的页面，被移动到LRU链首部，并将mru_page指向这个页面。
</p>


<p>
如果一个事务更改了页面并且进行提交，意味着它的结果是永久的。但是如果缓冲区管理器尚未将页面写入磁盘，而同时系统崩溃，文件系统将包含一块老（不合法）的页面状态。如果缓冲区管理器决定刷写未完成事务所修改的页面信息，将会违背原子性，如果缓冲区管理器没有刷写已提交事务的更改信息，永久性就会存在隐患。处理这种情况的一个方法是暴力强制写（brute force）：无论何时页面将被修改（发出一个带有互斥信号量的bufferfix请求），它的旧内容将被写入日志（旧值或前像）。当页面被取消固定时，将它的当前内容写到日志中（新值或后像）。为了保证再次重启时能正确的执行恢复动作，在运行时，缓冲区管理器和日志管理程序必须相互交换信息，这些信息表明一个给定的日志项是否应该应用到数据库的页面上。解决这个问题的最简单方法是为每个页面分配一个状态标识符或版本号。在恢复的时候，磁盘上的页面状态和记录在日志项中的状态进行比较，以确认日志项指向的是当前状态、旧状态还是新状态？所有的日志记录都分配有LSN，并在页面头部存储为该页面生成的最新的LSN，这个LSN用来和日志进行关联。在恢复时，可以使用简单的方法来确定哪些日志需要应用到磁盘上：
</p>
<ul class="org-ul">
<li>回滚UNDO。对于LSN小于页面LSN的日志记录，需要反向扫描日志，取消事务更新。</li>
<li>提交REDO。对LSN大于页面LSN的日志记录，正向扫描日志，重复执行操作。</li>
</ul>

<p>
一个页面，由谁在何时刷写到磁盘上呢？有两种思路：
</p>
<ul class="org-ul">
<li>强制写策略。在事务提交的第一阶段，缓冲区管理器查找由该事物更改的所有页面，刷写磁盘。</li>
<li>非强制写策略。只有页面被替换时才刷写磁盘。</li>
</ul>
</div>
</div>

<div id="outline-container-orgff82906" class="outline-2">
<h2 id="orgff82906">面向元组的文件系统</h2>
<div class="outline-text-2" id="text-orgff82906">
<p>
面向元组的文件系统需要提供一下六种基本功能：
</p>
<ul class="org-ul">
<li>存储分配。将元组保存在面向块的基本文件系统中，面向块的文件系统负责分配空间。</li>
<li>元组寻址。为每个元组分配一个稳定的标识符，并建立高效的存储路径。</li>
<li>枚举。提供从关系的一个元组到另一个元组的快捷存取路径，能够枚举关系的所有元组。</li>
<li>内容寻址。可以通过元组属性的内容存储元组。</li>
<li>维护。可以删除已有元组，并切断数据库其他部分与该元组的所有联接。</li>
<li>保护。提供对安全性的基本支持，例如，以加密形式保存元组，或进行内容敏感的存取控制。</li>
</ul>

<p>
一个页面包含大量的记录，每个记录可以是一个元组的物理表示，或其中一项的物理表示，也可以是由面向元组的文件系统维护的其他对象的物理表示。面向元组的文件系统是基于面向块的文件系统的。假设页面都有一个标准的头：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">FILENO</span> <span style="color: #a0522d;">fileno</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#39029;&#38754;&#25152;&#23646;&#30340;&#25991;&#20214;&#21495;</span>
    <span style="color: #228b22;">uint</span> <span style="color: #a0522d;">pageno</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25991;&#20214;&#20013;&#30340;&#39029;&#21495;</span>
} <span style="color: #228b22;">PAGEID</span>, *<span style="color: #228b22;">PAGEIDP</span>;
<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">PAGE_TYPE</span> {
                <span style="color: #a0522d;">DATA</span>, <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25968;&#25454;</span>
                <span style="color: #a0522d;">INDEX</span>, <span style="color: #b22222;">// </span><span style="color: #b22222;">&#32034;&#24341;</span>
                <span style="color: #a0522d;">FREESPACE</span>, <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31354;&#38386;</span>
                <span style="color: #a0522d;">DIRECTORY</span>, <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26412;&#25991;&#20214;&#25110;&#20854;&#20182;&#25991;&#20214;&#30340;&#20803;&#25968;&#25454;</span>
                <span style="color: #a0522d;">CLUSTER</span>, <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21253;&#21547;&#22810;&#20010;&#20851;&#31995;&#30340;&#20803;&#32452;</span>
                <span style="color: #a0522d;">TABLE</span> <span style="color: #b22222;">// </span><span style="color: #b22222;">&#31649;&#29702;&#22411;&#25968;&#25454;</span>
};

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">PAGE_STATE</span> {
                 <span style="color: #a0522d;">VALID</span>, 
                 <span style="color: #a0522d;">INVALID</span>,
                 <span style="color: #a0522d;">INDOUBT</span>,
                 <span style="color: #a0522d;">SHADOW</span>
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">PAGEID</span> <span style="color: #a0522d;">thatsme</span>;
    <span style="color: #228b22;">PAGE_TYPE</span> <span style="color: #a0522d;">page_type</span>;
    <span style="color: #228b22;">OBJID</span> <span style="color: #a0522d;">object_id</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20851;&#31995;&#12289;&#32034;&#24341;&#31561;&#23545;&#35937;&#30340;&#20869;&#37096;&#32534;&#21495;</span>
    <span style="color: #228b22;">LSN</span> <span style="color: #a0522d;">safe_up_to</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">WAL&#21327;&#35758;&#30340;&#39029;&#38754;LSN</span>
    <span style="color: #228b22;">PAGEID</span> <span style="color: #a0522d;">previous</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21452;&#21521;&#38142;&#34920;&#25351;&#38024;</span>
    <span style="color: #228b22;">PAGEID</span> <span style="color: #a0522d;">next</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21452;&#21521;&#38142;&#34920;&#25351;&#38024;</span>
    <span style="color: #228b22;">PAGE_STATE</span> <span style="color: #a0522d;">status</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26377;&#25928;&#30340;&#12289;&#19981;&#30830;&#23450;&#30340;&#8230;&#8230;</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">no_entries</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#39029;&#38754;&#30446;&#24405;&#25214;&#20013;&#20837;&#21475;&#25968;&#37327;</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">unused</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26410;&#20351;&#29992;&#30340;&#38750;&#36830;&#32493;&#23383;&#33410;&#25968;</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">freespace</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#36830;&#32493;&#31354;&#38386;&#23383;&#33410;&#25968;</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">stuff</span>[]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25968;&#25454;</span>
} <span style="color: #228b22;">PAGE_HEADER</span>, *<span style="color: #228b22;">PAGE_PTR</span>;

</pre>
</div>

<p>
一个页面中可以容纳不同类型（page_type）的项，而每种类型项的长度又不同。因此需要一个局部的页面目录来管理各项的存储和检索。最简单的方法是使用数组。那么，需要为数组分配多少空间呢？通常将这个数组放在页面的尾部，倒序增长，而记录则顺序的排列在页面头部之后。
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">not_needed</span>[<span style="color: #008b8b;">PAGESIZE</span>]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#35206;&#30422;&#25972;&#20010;&#39029;&#38754;</span>
    <span style="color: #228b22;">uint</span> <span style="color: #a0522d;">offset_in_page</span>[]; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20803;&#32452;&#22312;&#39029;&#38754;&#20013;&#30340;&#20559;&#31227;&#37327;&#12290;</span>
} <span style="color: #a0522d;">PAGE_DIR</span>, *<span style="color: #a0522d;">PPAGE_DIR</span>;
</pre>
</div>

<p>
上面的数据结构采用了一种叫做“负寻址”的技术，第i个元组的偏移量保存在offset_in_page[-i]中。除了定位数据项外，页面管理还需要记录哪些部分是空闲的。有四种情况可能影响页面的空闲区间：
</p>
<ul class="org-ul">
<li>插入元组。</li>
<li>删除元组。</li>
<li>更新元组。</li>
<li>重组。调整元组的位置，避免碎片。</li>
</ul>

<p>
当一个页面长度缩短时，它仍然保存在原来的位置，而unused字节数增加。如果元组长度增加，并且空闲区（freespace）可以容纳，将元组插入当前最后元组的后面，并释放它之前占用的空间。如果空闲区的容量不够，检查未使用空间是否可以容纳元组，并查找碎片之间是否存在最够大空洞。如果没有这样的空洞，对页面进行重组后重新插入元组。如果页面重组也无法得到足够的空间，这就需要将元组（或一部分，叫做分段）保存在另外一个页面中。再删除一个元组时，它的长度会加到unused字节中。如果unused/freespace超过预定的阈值，内部的垃圾回收过程将启动。空闲区的管理由两种典型的方法：空闲区表（free space table）和空闲区游标（free space cursor）。空闲区表是位于预定位置的一个数组，文件中的每个页面在其中占一项。空闲区游标则在文件目录中定义两个指针，一个指向当前插入点页面，另一个指向空页面链表。如果页面已满，选择一个空页面作为当前插入点页面。如果某个页面通过重组成为空页面，将其插入空页面链表。
</p>


<p>
元组标识符的结构如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">NODEID</span> <span style="color: #a0522d;">at_node</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20803;&#32452;&#25152;&#23646;&#30340;&#33410;&#28857;&#21495;&#12290;</span>
    <span style="color: #228b22;">FILEID</span> <span style="color: #a0522d;">in_file</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20803;&#32452;&#23646;&#20110;&#21738;&#20010;&#25991;&#20214;&#12290;</span>
    <span style="color: #228b22;">TUPLENAME</span> <span style="color: #a0522d;">local_id</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20803;&#32452;&#30340;&#26412;&#22320;&#26631;&#35782;&#12290;</span>
} <span style="color: #228b22;">TUPLEID</span>, *<span style="color: #228b22;">TUPLEIDP</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org2ad9a48" class="outline-2">
<h2 id="org2ad9a48">存取路径</h2>
<div class="outline-text-2" id="text-org2ad9a48">
<p>
关联存取也叫做内容寻址能力，有三种技术可以支持它：主码存取、辅助码存取和多表存取。对于单个联系的关联存取，有两类方法：散列法（码转换）和码比较法。
</p>

<p>
实用散列算法可以分为6类：
</p>
<ul class="org-ul">
<li>同余散列。</li>
<li>N次幂。</li>
<li>换底。</li>
<li>多项式除法。</li>
<li>数值分析。</li>
<li>加密。</li>
</ul>

<p>
B树是一个多路树，它的关键性质在于，每条查找路径长度相同。B树的每个节点是一个页面，B树有两种类型的节点：叶子节点包含要查找的数据（如元组），索引节点不包含数据，但包含查找使用的路由信息。B树索引节点的结构如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #228b22;">uint</span> <span style="color: #a0522d;">F</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#19968;&#20010;&#32034;&#24341;&#33410;&#28857;&#20013;&#30340;&#26368;&#22823;&#20837;&#21475;&#39033;&#20010;&#25968;&#12290;</span>
<span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">K</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#30721;&#20540;</span>
    <span style="color: #228b22;">PAGEID</span> <span style="color: #a0522d;">P</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25351;&#21521;&#33410;&#28857;&#25110;&#39029;&#38754;</span>
} <span style="color: #a0522d;">index_node_structure</span>[]; 
</pre>
</div>
<p>
每个索引节点包含一个有序的码值序列K[1]，K[2]，&#x2026;，K[F]。每个码值K[i]后面都跟着一个指针P[i]，P[i]指向一个节点，这个节点记录了码值位于K[i]和K[i+1]的数据的信息。F叫做索引节点的扇出系数。叶子节点也使用类似的结构，区别在于没有指针，而是包含实际数据。叶子节点是由&lt;码值,数据&gt;对组成的数组，按码值圣墟排列存储。
</p>


<p>
在B树中搜索数据的步骤如下：假设要搜索的码值是s，首先从根节点开始搜索。首先找到当前节点中最大的码值K[m]（m&lt;=F）。如果s&gt;=K[m]，则跳转到P[m]指向的节点继续搜索。否则找到下标j，使得K[j]&lt;=s&lt;K[j+1]，跳转到P[j]节点继续搜索。对于范围查询[s,t]，首先找到s的位置，然后从s开始遍历叶节点，直到码值超过t。这种方法利用了B树叶节点构成一个有序链表的特性。在B数中插入数据的步骤如下：首先搜索到一个覆盖数据码值的叶子节点，如果叶子节点入口项中拥有足够的空间，直接将数据排序后插入叶子节点。如果叶子节点入口项已满，分配一个新的叶子节点，将原节点后半部分入口项移到新节点，然后插入数据项。这个过程叫做叶子节点分裂。随着叶子节点数量的增加，索引节点也会出现入口项填满的情况。这时采用同样的方法，对索引节点进行分裂。索引节点的分裂会一直向上传导到根节点，根节点不能直接分裂。根节点分裂是会分配两个节点，分别作为跟的两个新子节点。删除操作和插入类似：首先找到叶子节点，删除码值的入口项，并将后续入口项向前移动。为了维持平衡，当删除后入口项占有率低于阈值（通常设置为50%）时，需要将叶子节点和其右侧兄弟节点进行合并，使得所有叶子节点的占用率不低于阈值。
</p>



<p>
删除过程中不会修改索引节点。
</p>





<p>
begin:551
end:623
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2019-09-23 周一 18:45</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-09-23 周一 18:45 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>事务处理笔记</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">事务处理笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgdb626b3">中文版序</a></li>
<li><a href="#org810af38">序</a></li>
<li><a href="#org45c3534">前言</a></li>
<li><a href="#org032d32f">第一章 概述</a></li>
</ul>
</div>
</div>


<div id="outline-container-orgdb626b3" class="outline-2">
<h2 id="orgdb626b3">中文版序</h2>
<div class="outline-text-2" id="text-orgdb626b3">
<p>
事务是分布式计算中的一个概念。如果在某一层次上实现了事务，那么在更高的层次上就具有了一个简单的失败语义（all or nothing），使错误处理变得容易。
</p>
</div>
</div>

<div id="outline-container-org810af38" class="outline-2">
<h2 id="org810af38">序</h2>
<div class="outline-text-2" id="text-org810af38">
<p>
保证数据一致性的关键是要明确数据访问和更新的序列。这一序列称为事务。 事务处理技术就是要确保一个事务要么完整的执行，要么根本不执行，并保证并发执行的事务彼此互不干扰，如同在隔离执行一样。 这一技术的意义尤其在于，在一些复杂情况下上述保证仍能得到支持，如计算机部件发生故障、数据分布在不同计算机上或不同事务的交叉或并行执行。 事务保证了数据的一致性，或者说，数据的某种不变性，这才使得构建可靠系统成为可能。
</p>
</div>
</div>

<div id="outline-container-org45c3534" class="outline-2">
<h2 id="org45c3534">前言</h2>
<div class="outline-text-2" id="text-org45c3534">
<p>
要使一个大型的系统正常运行，必须采用一种真正的“一条龙”的观点，即从一个请求开始，通过系统的各个层次和构建，直到结果被安全的输出位置。 这其中涉及终端上的表示管理、通信子系统、操作系统、数据库、程序设计语言的执行系统以及应用开发环境等。 设计一个集成度如此之高的系统，所需要的一套设计方案将完全有别于功能有限的算法设计。
</p>
</div>
</div>

<div id="outline-container-org032d32f" class="outline-2">
<h2 id="org032d32f">第一章 概述</h2>
<div class="outline-text-2" id="text-org032d32f">
<p>
事务处理系统简称为TP系统。一个完整的TP系统包括应用生成器（如存储过程编译器）、操作工具（如SQL Server Management Studio）、一个或多个数据库（如SQL Server）、实用工具（如osql.exe），以及网络和操作系统软件。 在TP系统中，有一个核心服务集，称为TP监控器，它负责管理和协调通过系统的事件流。 在TP系统中，服务器通常称为资源管理器（resource manager，RM）。
</p>


<p>
事务是对应用状态的操作的集合。应用状态可以是物理的（如磁盘）或抽象的（如内存数据）。 发起操作的请求和收到的应答分别叫做事务请求和事务应答，执行操作的程序叫做事务程序。 在构建事务处理系统的过程中，发展出了很多分布式计算和容错计算方面的概念。 为了提供可靠性、可用性和性能发展出了分布式数据；为了提供可用性，发展出了容错存储和容错处理； 针对分布式计算，发展出了客户-服务器模型和远程过程调用。更重要的是提出了事务的ACID特性，即：
</p>


<ul class="org-ul">
<li>Atomicity 原子性。事务对状态的改变是原子的、不可分割的。操作中的步骤要么全都执行，要么全都不执行。</li>

<li>Consistency 一致性。事务对状态的改变是正确的，不会违反系统对状态的完整性约束。</li>

<li>Isolation 隔离性。事务是相互隔离的。对于事务T和U，要么T在U之前执行，要么U在T之前执行。</li>

<li>Durability 持久性。当事务成功完成（提交）后，状态的改变是持久的，不会受到其他失败的影响。</li>
</ul>


<p>
我们以一个银行贷款事务来直观的认识ACID特性。如果它同时完成了支出和账户更改，它就是原子的。 如果支出金额等于账户收入，它就是一致性的。 如果它不会受到同时运行的其他事务程序的影响，它就是隔离的。 如果一旦事务成功完成，账户余额反映了取款后的情况，它就是永久的。
</p>


<p>
从应用开发者的角度来看，事务是一个以BeginWork()开始，以CommitWork()结束的程序。 一旦CommitWork()执行完毕，事务的影响就是持久的。如果执行中出现错误，可以调用RollbackWork()撤销从BeginWork()开始的全部操作。 BeginWork/CommitWork/RollbackWork的语义虽然简单，却提供了一个完整的故障处理逻辑。 并且，基于这个方案构造的子模块，可以很容易的组织成更大的，满足同样故障处理逻辑的大模块。
</p>


<p>
构造分布式系统就可以采用这样的方式。每个模块是一个事务或子事务，如果一切顺利，事务最终提交。 所有模块转变为永久的新状态。如果发生错误，事务的所有模块设置成事务开始时的状态。 这种思想叫做2阶段提交协议（2-phase commit protocol）：首先进行投票（vote）阶段，所有参与者准备提交，接着是提交阶段，所有参与者执行提交。一个进程负责协调提交，保证所有参与者要么同意改变状态，要么同意维持原状。
</p>


<p>
使用和关注TP系统的人不仅仅有应用开发者，还有用户、管理员、TP系统开发者等等。 这些角色对事务和TP系统有着不同的视角。下面用一个面向表单的电子邮件系统的例子来介绍不同视角下的TP系统。
</p>


<p>
用户视角。用户看到的邮件系统是信箱和消息。用户向系统认证自己的身份。当这个事务完成后，系统把消息列表展示给用户，用户可以阅读消息、回复消息、删除消息、发送消息或取消发送消息。每个操作都是满足ACID的事务。如果一个消息没有被对方用户阅读，召回消息事务可以撤销发送消息事务产生的影响，这样的事务叫做补偿事务。
</p>


<p>
管理员视角。管理员的基本职责是添加和删除用户、为用户提供文档和培训、管理系统的安全性（如更改密码或检查安全日志等）。这些操作叫做管理事务。管理员看到的系统是一组包含硬件和软件模块的物理节点。如果系统中的组件过多，需要一个专门的数据库来跟踪组件，这个库叫做中心库（repository）。
</p>


<p>
应用开发者。应用开发者是基于TP系统，开发应用功能的开发者。在他们眼中，TP系统是一个分布式计算环境，客户通过事务型远程过程调用机制获得服务。客户程序作为进程在用户的电脑上执行，给用户提供一个图形和响应界面。这部分叫做表示服务。用户的操作会产生一条消息，发送给服务器上的TP监控器。TP监控器维护一个服务列表。比如在邮件系统中，这些服务可能是登录邮件系统、阅读消息、删除消息、发送消息等功能。在收到请求后，TP监控从中心库中查找对应的服务，检查用户权限，然后创建一个进程执行这个服务。如果一个事务完成后，用户往往会继续执行其他事务（比如连续阅读消息），这时服务器会为用户分配一个上下文，以便后续的调用可以快速找到用户状态。
</p>


<p>
事务型远程过程调用。远程过程调用（RPC）指在不同地址空间中的调用。“远程”表明失败是异步的。事务型远程过程调用（TRPC）将多个客户和服务器的工作结合到一个单独的ACID执行单元中。应用通过BeginWork()开始新事务，并分配唯一的TRID。之后用户的所有操作都使用这个TRID标记。TRID和服务请求一起发送给服务器。在事务提交时，所有参与的服务也将事务中自己执行的部分进行提交。提交逻辑由每个参与节点的TP监控器实现，并由一个可信进程协调。协调采用两阶段提交协议（two-phase commit protocol）：首先是投票（voting）阶段，每个参与者进行提交前的准备工作；接着是提交阶段，每个参数着执行提交。一个独立的进程对提交进行协调。对提交进行协调的目的在于处理失败的情况。
</p>


<p>
在事务型系统中，服务器被称为资源管理器（resource manager）。资源管理器就是数据、代码和对一些共享数据提供存取的进程。
</p>


<p>
在事务执行的过程中可能发生系统或模块失败的情况，比如用户按下取消键，或者服务器判断输入错误，或者电源或服务器故障等。如果失败发生的时候，事务已经完成，由于持久性要求，系统应当恢复到事务结束时的状态。如果失败发生时事务尚未完成，由于原子性要求，系统应当恢复到事务开始前的状态。协调提交就是为了应对这种情况，这个职责由TP监控器承担。
</p>


<p>
一些TP系统支持更复杂的事务，比如嵌套事务（nested transaction)或回滚到保存的（savepoint）等。这些事务都可以从上面介绍的BeginWork/CommitWork/RollbackWork模型发展出来。BeginWork/CommitWork/RollbackWork模型叫做扁平事务（flat transaction），它是更复杂事务模型的基础。
</p>


<p>
事务处理系统给应用开发人员提供了以下计算模型：
</p>

<ul class="org-ul">
<li>资源管理器。</li>
<li>持久状态。</li>
<li>事务型远程调用。</li>
<li>事务程序。</li>
</ul>


<p>
一个事务的执行是分布在应用程序（客户和服务器）及资源管理器之间的。TP监控器除了管理进程的建立和相互通信执行事务以外，都有一套提供给资源管理器的核心服务。这些服务帮助资源管理器实施ACID操作，并对单个资源管理器的应用程序提供全局执行控制。动词BeginWork()开始一个事务，在事务管理（TM）器中注册该事务，并产生一个唯一的TRID。当资源管理器得到该事务的第一个请求时，这个资源管理器就加入到事务之中。一个事务往往有多个资源管理器参与其中，每个资源管理器都把自己为对象所做的修改记录下来。资源管理器会记录对象的原始值和更新值。TP系统提供一个日志服务记录这些变更。日志管理器维护了一个顺序文件，记录了事务中对象的所有更新。这些更新由资源管理器告知日志管理器。
</p>


<p>
当多个事务并发执行的时候，为了保证状态的一致性和隔离性，资源管理器会封锁事务存取对象，以避免其他事务访问到未提交的值。为此，TP系统会提供一个封锁管理器。当事务发出CommitWork()命令时，事务管理器开始执行两阶段提交。首先会询问所有参与该事务的资源管理器，是否认为事务中的操作室一致和完整的。在全部资源管理器都赞成的情况下，事务管理器将提交结果记录到日志中，并通知每个资源管理器。资源管理器可以释放锁，执行一些其他的完成该事务的所需操作。
</p>


<p>
如果事务执行中出错，或者在提交的第一个阶段，某个资源管理器提出否决，事务管理器就要回滚事务。事务管理器读取事务日志，对事务中的每个操作，通知相应的资源管理器撤销操作。当全部操作撤销后，事务管理器通知每个资源管理器事务终止。
</p>


<p>
如果某个对象、资源管理器或整个场地出现故障，事务管理器仍然需要完成事务的恢复。如果场地出现故障，TP系统重启所有的资源管理器。资源管理器在重启后向事务管理器询问重启前的事务状态，根据得到的结果恢复事务已提交的状态。这个步骤也可以由事务管理器主导，根据日志执行重做或撤销来完成。如果一个资源管理器出现故障，而TP系统的其他部分还可以正常工作，事务管理器会中止涉及该资源管理器的未提交事务。在这个资源管理器恢复后，事务管理器会告知其这些事务的状态。如果一个对象出现故障而资源管理器仍然可以运行，资源管理器可以继续为其他事务提供服务。这个失败的对象可以从存档的副本中恢复，或者根据日志重新构造。
</p>


<p>
每一个场地通常都有一个单独的事务管理器。这使得每一个场地都能独立于其他场地操作，提供本地自治。当事务在多个场地分布执行时，它也在多个事务管理器之间分布。这时，两阶段提交协议很容易推广到多个事务管理器。
</p>


<p>
X/Open假设每个资源管理器都有私有的日志管理器和封锁管理器，资源管理器在事务中止时根据事务管理器的调用执行自己单独的回滚。在分布式场景下，当应用或代表应用的资源管理器发出远程请求时，通信管理器CM把输入和输出的结果通知本地事务管理器。
</p>


<p>
根据上面的分析可以看到，事务处理监控器的核心服务有：
</p>

<ul class="org-ul">
<li>事务型远程调用。</li>
<li>事务管理器。</li>
<li>日志管理器。</li>
<li>封锁管理器。</li>
</ul>

<p>
资源管理器通过使用这些核心服务来扩展事务处理系统。
</p>


<p>
TP系统最明显的特征是围绕中心库构造应用设计和生成工具。中心库记录了系统中对象的描述信息和对象之间的关系。中心库也叫做字典或目录。SQL数据库系统的目录就是一个中心库，记录了数据库表、索引、视图和程序。
</p>



<p>
操作问题是一个经典的库存和材料单问题。更改一个系统和构造一套复杂的新机制类似。制造业很早就知道计算机可以实现大部分的材料单逻辑的自动化。参考Unix系统的make程序。一个目标文件和一组依赖文件关联，构成一个材料单。为了构造目标文件，必须先构造依赖文件。因此产生了中心库的概念。中心库需要记录：
</p>

<ul class="org-ul">
<li>设计。数据库记录所有的应用设计决策。</li>
<li>依赖。数据库记录所有的应用设计和模块的依赖。</li>
<li>变更。将过程变更表达为数据库事务。</li>
</ul>

<p>
一个好的中心库应该描述系统的所有方面，叫做完备性。同时，记录的对象信息应该和对象的实际状态一致，这叫做主动性。
</p>


<p>
如果应用分布在自治的场地上，那么中心库也必须分布以提供本地自治——即使一个场地和其他场地断开连接时也有能力操纵本地对象。如果中心库是真正主动的，那个没有中心库的场地是不可操作的。例如，在无法获取中心库的情况下，不能创建、修改或删除文件。因此，一个场地中所有对象及其依赖关系必须也存储在同一个场地内。如果一个对象依赖于其他场地中的对象，两个场地必须都记录这个依赖关系。
</p>


<p>
TP监控器为资源管理器为资源管理器和应用提供了一个执行环境。当请求到达后，TP监控器发起一个服务执行请求。这就涉及了服务调度。TP监控器可以预先分配一组服务实例。这样的进程池叫做服务类（server class）。
</p>


<p>
一些TP系统支持保存点（savepoint），保存点是操作序列中的一个点，事务可以回退到这个点的状态重新执行。
</p>


<p>
在讨论数据通信时必须考虑哑终端和客户-服务器这2中情况。哑终端是没有应用逻辑的，客户则不同。
</p>

<p>
bookmark p21
</p>

<p>
数据通信系统负责进行可靠安全的通信。为了防止协议，通常会对消息进行加密。为了避免消息丢失，会在持久存储中记录每条输出的消息，并在对方应答前重复发送。为了避免消息重复，每个消息具有一个序列号。对于序列号重复的消息，对方需要应答，但是不需要处理。
</p>


<p>
应用要求的是对抽象记录或对象上的操作，数据库就是实现这种抽象操作到具体硬件的映射。
</p>


<p>
将数据放在不同的地方叫做数据分片。将相同的数据放在不同的地方叫做复制。为了实现本地自治，中心库的一部分被复制到每个场地上。为复制和分片数据提供透明存储的数据库叫做分布式数据库。
</p>


<p>
SQL提供了一套标准的院子类型，如数字、字符串等。用户定义的类型叫做域，由院子类型和其他的域来定义。域具有自己的名字和取值约束，记录在中心库中。SQL表示记录的集合，每个记录是值的序列。在关系型数据库中，每条记录具有相同的格式。面向集合的操作（如排序、投影、选择）可以应用到这些记录上，并且其结果集合仍然构成一个表。这样的表叫做视图（View）。视图可以将具体的表和应用程序解耦。如果具体的表发生变动，不需要修改应用程序，只要修改视图就可以了。表中的列继承了域的取值约束，比如要求某个值在表中是唯一的（唯一性），或者要求值在其他的表中存在（参照完整性）等等。这些约束保证了数据的一致性。试图破坏这些约束的操作请求将被拒绝。当记录被读写时，会调用一个过程检查约束是否得到满足，根据结果拒绝或接受更新。这个过程也可以更新相关的其他记录。这个过程通常叫做触发器（trigger）。
</p>

<p>
SQL数据定义操作的语法是::
</p>

<p>
{CREATE,ALTER,DROP} {DOMAIN,TABLE,INDEX,CONSTRAINT,VIEW,TRIGGER}
</p>

<p>
例如::
</p>

<p>
CREATE TABLE accounts(acct<sub>id</sub> integer PRIMARY KEY,
                      cust<sub>id</sub> integer FOREIGN KEY REFERENCES customer,
                      balance decimal(9,2) CHECK balance&gt;=0);
</p>

<p>
除了从逻辑上定义数据的类型和依赖关系，SQL也支持设定这些数据的一些物理属性，比如存放位置（分片）、存储结构（顺序、散列）等::
</p>

<p>
CREATE TABLE \node1.$data.accounts(acct<sub>id</sub> integer PRIMARY KEY,
                                   cust<sub>id</sub> integer FOREIGN KEY REFERENCES customer,
                                   balance decimal(9,2) CHECK balance&gt;=0)
             \node2.$data FIRST KEY 10000,
                          BLOCKSIZE 4096,
                          EXTENT 100;
</p>

<p>
SQL的关键观念是关系。关系是若干集合的笛卡尔积集合，一个表就是一个关系。数据操作请求的目的就是定义、修改关系，或者基于已有关系，构造出一个新关系。这些操作的核心是SELECT操作。SELECT操作包括3个部分：根据PROJECT抛弃一些列，根据SELECT谓词抛弃一些行，根据JOIN将两个关系连接起来。关系数据库的基本定理是这些操作都是哥德尔完备的（Godel complete），等价于一阶谓词演算。但它不是图灵完备的（Turing complete），不能描述所有的可计算功能。因此SQL通常需要和其他编程语言结合使用，这时编程语言称为主语言。由于主语言操作的是单个记录，而SQL操作的是集合，这就产生了阻抗适配（impendance mismatch）。解决方法和处理文件时使用的技术一样：主程序一次处理一条记录，主程序通过SQL语言构造一个集合，并定义一个游标标记当前记录的位置。在主程序处理完成，更新游标指向的记录，并移动游标到下一条记录。
</p>

<p>
数据控制包括安全性动词（GRANT、REVOKE）、并发控制动词（LOCK、SET TRANSACTION）和事务动词（BEGIN WORK、COMMIT WORK）。SQL的基本安全模型是用户拥有表，程序作为用户的代理，通过用户授权得到访问权限。
</p>

<p>
事务是一个满足ACID特性的低层次操作。原子性为上层的容错提供了支持。一致性和隔离性保证了操作的正确性。持久性是为了在系统故障时可以保证原子性。
</p>

<p>
涉及到保存数据时，通常有两种策略。一是将一份数据保存在不同的地方，叫做分片。一种是将一份数据保存到不同的地方，叫做复制。这些相同的数据叫做副本。分片可以提高关联查询时的数据访问速度，复制可以提高可靠性，也可以提高数据访问速度。如果系统支持分片和复制，同时又向上层系统屏蔽了分片和复制的细节，这个系统就是分布式数据系统。
</p>

<p>
SQL表是记录的集合。每个记录是一个序列。SQL要求记录的结构是相同的。将数据保存到不同表的目的是避免数据膨胀。使用约束的目的是维护数据在逻辑上的一致性。SQL语句就是在维护一个集合：SELECT是构造子集的投影，JOIN是构造笛卡尔积，INSERT是向集合添加元素，DELETE是从集合删除元素，CREATE TABLE是建立集合，DROP TABLE是删除集合。索引是为了提高访问性能而构造的集合的投影，并且这个投影要满足一定的逻辑顺序关系。
</p>

<p>
对于事务处理系统（TP），用户、程序员、管理员和系统的实现者拥有不同的视角。对（终端）用户来说，事务处理系统是抽象对象的一组操作。比如在邮箱系统中，邮件和邮箱就是抽象对象。从管理员的角度，事务处理系统是一组包含硬件和软件的物理节点。从程序员（应用开发者）的角度，事务处理系统提供了一个分布式计算环境和一组快速加快开发效率的工具。
</p>

<p>
在处理交互事务时，用户等待着应答，因此必须快速响应。批处理事务则可以在提交之后过一会在处理。
</p>

<p>
当一个资源管理器得到该事务的第一个请求时，它就加入到事务中，告知事务管理器它需要参与该事务的提交或者回滚。为了在回滚时恢复到初始状态，资源管理器必须自己实施在对象上的操作。事务处理系统提供了日志管理器记录这些操作。为了提供隔离，资源管理器需要封锁事务使用的对象，以免其他事务观察到本事务未提交的更新，或者修改本事务读取的数据。事务处理系统提供一个封锁管理器完成这个功能。
</p>

<p>
当事务执行提交时，事务管理器开始执行两阶段提交。事务管理器询问事务中的每个资源管理器，是否认为当前事务对状态的修改是一致和完整的。如果得到肯定回复，事务管理器将使用日志记录这一点，并通知资源管理器。资源管理器释放锁。
</p>

<p>
如果事务执行失败，或者某个资源管理器对第一阶段的确认提出否定，事务管理器需要执行事务回滚。事务管理器读取日志，对每个日志记录的调用，通知其资源管理器撤销操作。当每个操作都撤销后，事务管理器通知资源管理器，事务中止。
</p>

<p>
如果场地（？）出现故障，事务处理系统重启全部的管理器。如果一个事务正在提交，必须对其进行恢复。这时，作为重启逻辑的一部分，事务管理器询问每个资源管理器。资源管理器可以独立地恢复已经提交的状态，也可以参与事务管理器对日志的重做。
</p>

<p>
如果一个资源管理器出现故障，其他模块正常，事务管理器会中止这个资源管理器涉及的事务。当资源管理器从故障中恢复后，事务管理器通知其相关各事务的结构。资源管理器根据这些信息和日志重建状态。
</p>

<p>
如果一个特定的对象出现故障，而资源管理器可以正常运行。资源管理器可以继续对其他对象服务，而这个对象将使用存档的副本和日志中记录的对该副本操作进行恢复。
</p>

<p>
从应用的角度看，事务是包围在Begin-Commit对或Begin-Rollback对中的一组操作序列。Begin分配一个事务标识符trid，后续的每个操作，都是由资源管理器执行。这些操作在可恢复的数据上生成允许回滚或永久改变状态的信息（日志）。此外，为了隔离性，资源管理器会对事务访问的对象进行封锁。
</p>

<p>
数据通信的安全性是通过加密实现的。为了实现数据通信的可靠性，需要在持久化介质上记录每一个消息，并在收到对方应答前重复发送。为了避免消息重复，每个消息要分配一个唯一编号。
</p>

<p>
应用要求的是对抽象记录或抽象对象上的操作，数据库负责实现这种抽象到具体硬件的映射。
</p>

<p>
SQL表是记录的集合。表列集成了列的约束。表可以要求某一列的值是唯一的（唯一性），或必须在另外某个表中存在（参照完整性）。
</p>

<p>
SQL定义数据操作的基本语法为::
</p>

<p>
{CREATE,ALTER,DROP}{DOMAIN,TABLE,INDEX,CONSTRAINT,VIEW,TRIGGER}
</p>

<p>
下面的示例展示了列约束、唯一性约束、参照完整性约束的使用方法::
</p>

<p>
CREATE TABLE accounts( acct<sub>id</sub> integer PRIMARY KEY,
                       cust<sub>id</sub> integer FOREIGN KEY REFERENCES customer,
                       balance decimal(9,2) CHECK balance &gt;= 0
                      );
</p>

<p>
SQL有3中基本的关系操作符：投影（project）、选择（select）和连接（join）。每个关系操作符在一个或多个输入表的基础上生成一个新表。
</p>

<p>
SQL的基本风格可以刻画如下::
</p>

<p>
#. 使用SELECT定义记录的集合。
#. 实施面向集合的INSERT、UPDATE和DELETE。
#. 当数据库语言能力不够的时候使用常规编程语言（称为主语言）操纵集合。
</p>

<p>
主语言和SQL的连接关系称为阻抗失配（impendence mismatch），因为SQL操纵记录集，而主语言操纵单条记录。并且SQL记录和主语言的数据类型不能精确匹配。解决的方法是使用游标。
</p>

<p>
数据控制包括安全性动词（GRANT、REVOKE）、并发控制动词（LOCK、SET TRANSACTION）和事务动词（BEGIN WORK、COMMIT WORK）。SQL的基本安全模型是表被用户所有，程序作为用户的代理运行。
</p>

<p>
系统提供安全、恢复和控制变化的机制，但是操作员和管理员必须设计策略，确定如何使用这些机制。一旦策略制定，操作员和管理员必须反复进行应急训练和审计，以确保策略有效并被正确遵循。
</p>

<p>
事务处理系统有两个关键的资源管理器：数据库（DB）和数据库通信（DC）。因此，事务处理系统也被称为DB-DC系统。数据库是具有数据定义、数据控制、数据操纵动词的SQL数据库系统。
</p>

<p>
关系演算是哥德尔完备的（Godel complete），但不是图灵完备的（Turing complete），不能描述所有的可计算功能，因此常和其他编程语言（称为主语言）一起使用。主语言操作单个记录，SQL操作记录集合，这种连接关系叫做阻抗失配（impedance mismatch）。
</p>



<p>
第二章 计算机系统基本术语
<code>======</code>
</p>

<p>
在描述数量时，通常用k表示1000，用K表示1024。b表示位（bit），B表示字节（Byte）。
</p>

<p>
在Bell和Newell的基本分类法中，硬件有3个模块组成：处理器、存储器和通信系统。处理器执行程序命令，读取和写入存储器，通过通信线路传输数据。
</p>

<p>
处理正在向数据的生产者（只能传感器）和消费者（PC、手机）转移。
</p>

<p>
为了实现可编程和可管理的分布式计算，它需要满足ACID事务特性。
</p>

<p>
存储器按地址存储数据，处理器可以读、写这些数据。给定存储器地址和某些数据，存储器写操作就可以将数据拷贝到该地址。存储器读操作可以将最近写入该地址的数据读取出来。在较低的抽象层次上来看，存储器对于处理器就像字节数组。在处理器指令层面看，存在一个地址转换机制，将逻辑地址（虚拟地址）转换成物理地址。这个转换通常有操作系统完成。处理器执行来自虚拟存储器的指令，读取并修改虚拟存储器中的值。
</p>

<p>
选择存储器时要考虑两个方面：这个存储器可以写入多少数据？这个存储器的读写速度是多少？后者用于衡量存储器的性能。存储器的性能按照访问时间来衡量。给定一个地址，存储器在一段时间后返回数据，这段时间叫做存储器访问时间（memory access time）。访问时间可以细分为延迟（latency）和传输时间（transfer time）。延迟是从发出读请求到开始传递第一个字节的时间。传输时间是传输数据所需的时间。传输时间又由传输量（transfer size）和传输速率（transfer rate）决定。因此，存储器的访问时间由下面的公式决定：
</p>

<p>
访问时间 = 延迟 + 传输量 / 传输速率
</p>

<p>
存储器通常使用两个指标来衡量：容量和访问时间。因此在衡量存储器性价比时就存在两种方法：
</p>

<p>
成本/字节（cost/byte） 存储一个字节的成本
成本/访问时间（cost/access） 读取一个字节的成本
</p>

<p>
通常，容量越大的存储器，访问时间越长。反之，访问时间越短的存储器，容量越小。  这里并没有假定存储器的具体细节。无论是磁带、磁盘、还是RAM，都可以使用这个公式。衡量存储器的性价比通常使用成本/字节（cost/byte）和成本/访问时间（cost/access）两个指标。常见的存储器有磁存储器和电存储器。磁存储器在切断电源后不会丢失数据，因此叫非易失（non-volatile）的。
</p>

<p>
可设定字节地址的电子存储器通常称为主存。可设定块地址的电子存储器通常叫做二级存储器（secondary storage）、扩展存储器（extended memory）或随机存取存储器（RAM disk）。处理器处理速度的增长远远快过存储器访问速度的增长，因此处理器往往需要大量时间等待来自存储器的指令和数据。为了处理这个问题，每个处理器都有自己的私有缓存（cache），保存处理器最近访问的数据和程序。
</p>

<p>
磁盘由盘片（platter）和读写头组成。盘片可以有多个，每个盘片都有自己的读写头。多个盘片组合在一个轴上一起旋转。类似的，多个读写头也是组合在一个叫做磁盘臂的结构上一起运动。磁盘臂的运动轨迹是直线，从磁盘的圆心到边缘。磁盘臂的运动叫做查找。磁盘臂连接了多个读写头，需要执行读写操作的那个，其对应的盘片叫做柱面（cylinder），读写头的位置在柱面上构成的圆环叫做磁道（disk track），磁道被划分为固定的大小，叫做扇区（sector）。扇区是磁盘的最小读写单位，通常是1024字节或512字节。由此可以看出，磁盘有着3维的地址空间：柱面、磁道、扇区。同时，根据磁盘的物理结构，磁盘的访问时间由下列公式决定：
</p>

<p>
磁盘访问时间 = 查找时间 + 转动延迟 + 传输量/传输速度
</p>

<p>
高的磁盘传输速度来自于磁盘分块（disk striping），它将一个大的对象分成几块存储到n个磁盘上去。当对象被读写时，n个磁盘上的数据库可以并行的读取和写入，从而获得比单一磁盘高n倍的传输速度。
</p>

<p>
假设一个磁盘的查找时间是10ms，旋转时间也是10ms，传输速度10MBps，每个扇区1KB大小。我们要从磁盘中读取1MB的数据。如果是随机访问，每次读取1个扇区的数据，那么每次读取需要的时间为
</p>

<p>
10ms（查找）+ 5ms（旋转盘片半周）+ 0.1ms（传输1KB）= 15.1ms
</p>

<p>
读取1000次就是15.1秒。如果使用顺序访问，只需要一次读取，消耗的时间为
</p>

<p>
10ms（查找）+ 5ms（旋转盘片半周）+ 100ms（传输1MB）= 115ms
</p>

<p>
由此可以看出，在磁盘上顺序访问比随机访问快上百倍。这个规律对所有磁介质存储器都有效。在使用这类存储器时，为了提升性能，需要做到：
</p>

<p>
#. 使用大数据块，提高 传输时间/访问时间 比值。
#. 数据聚集，是大数据库包含更多有效数据。
</p>

<p>
磁盘的传输速率由比特通过读写头的快慢决定。如果旋转速度增加到原来的2倍，传输数量也会增加到2倍，同时延迟减少一半，但不影响寻找时间。如果磁面密度增加到原来的4倍，线性密度会增加到原来的2倍，传输率也会增加到原来的2倍。寻找和延迟时间不变。
</p>

<p>
存储器的层次
</p>
<hr />

<p>
由于存储器的容量和访问速度不能兼顾，从系统整体角度出发，通常会采用多层次存储的结构，以满足容量和性能两方面的要求。
</p>

<p>
按照访问速度，存储器分为寄存器、高速缓存、主存、磁盘、脱机存储。一个完美的存储器应该知道处理器下一步需要什么数据，并将数据放入高速缓存中，这样存储器可以和高速缓存一样快。存储器无法预见未来，但是可以根据局部性原理（principle of locality）做成推测，将最近使用的数据及临近的数据缓存起来。这个策略的有效性可以通过命中率（hit ratio）衡量：
</p>

<p>
命中率=直接由高速缓存满足的引用数/所有对高速缓存的引用数
</p>

<p>
当一个引用在高速缓存中缺失，处理器必须访问下一层次的存储器。假设高速缓存的访问时间是C，命中率是H，缺失是访问低层存储器的时间是S。假设C约等于0.01S，那么：
</p>

<p>
有效高速缓存访问时间 = H*C + (1-H)*S 约等于 (1-H)*S
</p>

<p>
如果H很小，访问速度更接近于S。当命中率为90%时，访问速度比高速缓存慢11倍。如果想要达到高速缓存访问速度的10%，需要命中率在99.98%以上。为了提高命中率，有两个方法，一是数据聚集，提高局部性；二是使用巨大的缓存，让更多数据放在缓存中。采用巨大的缓存可以提高效率，同时也增加了成本。如何找到平衡点呢？可以使用五分钟法则（five-minute rule）可以解决这个问题。五分钟法则是指：
</p>

<p>
如果一个数据访问频率高于5分钟一次，应当把这个数据放入内存中，否则放入磁盘。
</p>

<p>
为什么是五分钟呢？为了提升系统性能，需要将频繁使用的数据放入缓存。那么频繁的标准如何选择呢？假定系统没有特定的响应时间（实时性）要求，这时主要的考虑因素就是成本。因此通过计算收支平衡点，可以找到频繁的定义
</p>

<p>
频率 = (每字节高速缓存费用-每字节二级缓存费用)*对象字节数/每秒访问对象的费用
</p>

<p>
频率以a/s（每秒访问）为单位。超过这一频率的数据，应当放到高速缓存中。五分钟法则就是按照这个公式，根据当年（约1990年）存储设备费用计算出来的。假设数据块大小为10KB。在1990年，10KB主存价格为1美元，10KB磁盘的价格是0.1美元。磁盘数据被访问时必须放到主存中。一个磁盘和支持磁盘的硬件大概是3000美元，并且每秒钟处理30次访问，因此磁盘的访问费用是每秒100美元。如果一个数据每秒钟被访问一次，就需要100.1美元（存储费用和访问费用）将它保存在磁盘中。因此当一个数据每100秒（约2分钟）访问一次时，保存在主存中或磁盘上，二者费用大致相等。如果访问频率更高，磁盘存储费用更贵。
</p>

<p>
处理器速度通过每秒指令（ips）衡量，通常以百万为技术单位（mips）。
</p>

<p>
处理器和存储器通过线路（网络）连接。从某方面看，计算机完全就是线路。一些线路组合成成芯片，一些线路传输信号。线路的基本属性是一个信号在一段输入，最终会到达另一端。通过线路传输数据所消耗的时间由线路的带宽（每秒线路可以传输多少位数据）和线路长度（通常以米为单位）。带宽决定了传输速率，长度决定了延迟。光纤的传输速度大于是Cm=2亿米/秒（1990年水平）。因此，传输时间可以表示为消息体积的函数：
</p>

<p>
传输时间(消息体积) = (距离/Cm + 消息体积/带宽) 秒
</p>

<p>
集群和局域网的传输时间主要取决于带宽，广域网的传输时间取决于延迟。并行连接和新技术可以改善带宽，但是没有很好的方法改善延迟。
</p>

<p>
处理器-存储器结构
</p>
<hr />

<p>
处理器需要从存储器中获取指令和数据。处理器和存储器有三种互联方法：非共享、共享内存和全局共享。在非共享（shared nothing）设计中，每个存储器只服务于一个处理器。所有对存储器的访问都要经过这个处理器。处理器之间通过通信网络传递消息。在共享存储器（shared memory）设置中，处理器可以访问全部的存储器。如果多个处理器同时访问某个数据，底层硬件提供并发控制。全局共享（shared global）设计是上述两种方案的折中。每个处理器都有自己的私有存储器，同时还有一些存储器由全部处理器共享。无论在硬件层面还是软件架构层面，全局共享的设计被采用得最多。这是基于以下几点权衡的结果：
</p>

<p>
#. 处理器的计算速度远远高于存储器的访问速度。
#. 存储器的访问速度越快，容量越小。
#. 多个处理器之间进行同步时需要通信，会消耗通信线路。
</p>

<p>
在全局共享设计中，如果让处理器需要的数据落在私有存储器中，并且各处理器的私有存储器没有冲突（没有互斥和等待），可以极大的提高处理性能。考虑到存储器的局部性原理，最好将数据连续存放，并按照私有存储器大小对齐。同时不同处理器使用的数据要分开。要注意，这里的数据不仅仅值系统处理数据（比如输入），也包括为了协调各处理器而使用的辅助数据（比如锁、信号量）等。
</p>

<p>
处理器-处理器结构
</p>
<hr />

<p>
在共享存储器设计中，底层硬件提供协调和并发控制，处理器对存储器的访问是透明，一个处理器不需要知道其他处理器是否存在。但是在非共享设计中，如果处理器要访问非私有存储器，必须和其他处理器通信。在全局共享设计中，为了避免各处理器对数据的读写出现冲突，需要进行协调，也需要处理器间的通信。这就要求对处理器-处理器结构进行设计。通常称非共享和全局共享设计中的各处理器组成一个集群（cluster）。集群有两个特点：
</p>

<p>
#. 高通信带宽。在集群内可以一次传递大块数据。
#. 低通信延迟。在集群内消息传递速度快。
</p>

<p>
在一个集群中构建计算时需要考虑：应该将程序移动到数据吗？如果数据量大，而计算逻辑简单，应当把程序移动到数据。否则应当把数据移动到程序
。
</p>


<p>
软件知识
</p>
<hr />

<p>
出于性能和安全角度考虑，现代计算机系统通常会提供存储器、处理器和通信线路的抽象软件实体。这些软件实体分别叫做地址空间、进程和会话。
</p>

<p>
地址空间是一个字节数组。进程从自己的地址空间获取指令，并通过处理器指令读写地址空间内的字节。地址空间是虚拟地址，需要进行转换才能确定其对应的物理地址。地址空间由内存段（segment）组成。段是内存共享、保护和分配的单元，同一个段内的字节具有相同的访问权限。段通常被分割为虚拟内存页（virtual memory page）。虚拟内存页是主存和辅存之间的传输单元。虚拟内存页的地址实际上是三元组&lt;段序号, 页, 字节&gt;。分页和分段对程序来说是不可见的。
</p>

<p>
进程是计算的执行者，是对硬件处理器的模拟。进程执行程序，发送消息，读写数据。进程是一个虚拟的处理器，包含进程所执行程序的地址空间，以及进程读写的存储器。进程提供了并行执行程序的能力。
</p>

<p>
进程执行时会向其他子系统发出请求，这些子系统为了保护自己，不会讲进程直接访问自己内部的数据，而是提供一个封装的环境。这样的环境叫做保护域。通常有两个方式来提供保护域：进程作为保护域和地址空间作为保护域。在第一个方案中，每个子系统作为一个独立的进程执行，拥有私有的地址空间，应用程序通过进程切换来执行子系统请求。在第二个方案中，一个进程拥有多个地址空间，应用程序和各子系统分别分配一个地址空间，应用程序通过切换地址空间执行子系统请求。第二个方案在性能上有较大优势，地址空间的切换，速度比通信往返（round-trip）和进程切换更快。切换进程需要多个内涵调用和进程分配，还要进程权限检查。
</p>


<p>
将地址空间作为保护域的方案引入了一个新的术语：线程（thread）。线程可以简单的理解为一个的创建和分配成本很低的进程。线程共享地址空间，因此线程具有相同的权限。
</p>


<p>
很多系统允许进程可以向其他进程发送消息，最简单的消息叫做数据报。数据报通过网络分发，接收进程可以询问网络是否有需要接收的数据报。如果对通信的安全性或其他方面有要求，通常使用会话来完成通信。会话（session）是模拟通信线路的软件实体，消息模拟了线路中的信号。会话是一个双向的消息管道。基本的会话操作有：建立会话（open<sub>session</sub>()）、关闭会话（close<sub>session</sub>()）、读取消息（receive<sub>msg</sub>()）、写入消息（send<sub>msg</sub>()）。会话的优点有：
</p>

<p>
#. 共享状态。会话可以在客户和服务之间共享状态。
#. 授权加密。在建立会话过程中可以进行检验，保证通信的安全性。
#. 错误发现和更正。会话可以保证消息按照顺序完整的传递，避免丢失和篡改。
#. 性能和资源调度。会话建立后，不再需要服务地址解析、权限校验等操作，减少了资源消耗。
</p>


<p>
系统结构
</p>
<hr />

<p>
有了上述概念，我们可以开始讨论客户-服务器协作问题了，包括通信结构、命名、认证、授权和调度等方面。简单计算被封装成进程。对于需要多个计算相互交互的复杂计算要如何构造呢？最基本的问题是，使用什么结构把两个进程组织起来呢？这就要在下面两个结构中作出选择：对等结构和客户-服务器结构。
</p>

<p>
在对等结构中，两个进程是独立对等的。每个进程执行自己的计算，不时和另外的进程交换数据。在客户-服务器结构中，两个进程采用请求-应答的方式交互。一个进程叫做客户，另一个进程是服务器。客户向服务器发出请求，服务器执行请求并作出应答。实际上，客户-服务器结构是对等结构的特例，但是由于对等结构需要协调进程状态，实现起来较为复杂。加上客户-服务器结构可以很好的完成大部分任务。大部分情况会选择客户-服务器结构。
</p>

<p>
如果调用服务器的过程对客户是透明的，这样的调用叫做远程过程调用（RPC）。从客户的角度来看，远程过程调用和本地调用是一样的。要做到这一点，首先把调用的方法和参数打包发送给服务器，服务器解包并执行调用，将结果打包发送给客户，客户函数解包并返回。
</p>

<p>
客户-服务器结构也有不足之处：
#. 一个请求产生多个应答。
#. 多个请求产生一个应答。
#. 并行。
</p>

<p>
对等结构和客户-服务器结构可以通过下面的方法来处理：在对等结构上建立消息和会话的底层机制，把大多数接口建立在客户-服务器模式上，同时提供底层的点对点的接口。
</p>

<p>
在客户-服务结构中有一个问题值得考虑：客户如何找到服务器呢？有两个方案：推送（push）方案和拉取（pull）方案。在推送方案中，系统主动为客户分配服务器。比如在事务系统中，当TP监控器收到客户请求后，为客户分配一个服务器。在拉取方案中，客户需要从一个公共目录中检索服务，然后客户和服务直接通信。比如DNS服务就是是拉取模式。
</p>

<p>
每个对象都有名字、地址和位置。名字一个抽象的标识符用来将不同的对象区分开。地址是访问对象的路径，比如门牌号或电话号，位置则是数据的具体地点。比如一个移动电话，电话号码就是它的地址。移动电话的位置可能会变化，但是号码不会改变。地址是对象的一个抽象的位置，地址到位置的映射由网络完成。一个对象可以拥有多个名字，叫做别名。这些名字、地址和位置必须放在一个叫做目录的上下文中解释。名字按照名字空间层次来分组。在计算机系统中使用的名字空间，有一个叫做X.500的国际标准进行规范。在这个规范中，名字空间存在层次，每个次级节点是一个目录。在位置（路径）中，各层级用点（.）分隔。
</p>

<p>
用户通过名字服务器检索到服务器地址，通过网络把请求传递到服务器的位置，把请求交给服务器（当服务器需要时）。这就是会话建立和远程过程调用执行时的情景。在启动时，客户必须找到本地名字服务器的名字和地址。为了便于使用，本地名字服务器通常使用众所周知的名字和地址。客户端向这个地址发送一个消息，或者向本地网络中这个名字发送广播。一旦名字服务器回应客户，客户就直到本地名字服务器的地址了。然后通过本地名字服务器，客户可以直到更多全局名字服务器地址。
</p>

<p>
当客户首次和服务器连接时，双方都想证实对方身份。比如在电脑上电子银行账户，银行想证实使用电脑的是你本人，你也想证实你在和银行而不是黑客软件通信。用计算机术语来说，每个进程都想认证其他进程：即确认其他进程的授权标志（authid）。每个进程都在某个授权标志下执行，而这个授权标志通常可以还原为某个人，因此也叫用户标志（userid）。
</p>

<p>
客户和服务器互相认证的方式有两种：双方使用共同的密码或都信任更高一级的授权机构。口令是最简单的加密方法。找一个只有客户和服务器知道的字符串。客户将字符串发送给服务器来完成认证。如果需要双向认证，则需要两个口令。质询-应答（challenge-response）协议比口令更为复杂。在这种模式下，客户和服务器共享一个密钥。服务器生成一个随机数N，使用密钥加密为EN，发送给客户。客户对EN进行解密，将结果回复给服务器。第三种方法根本不需要加密。每个授权标志（authid）都有一对钥匙：公钥EK和私钥DK，满足DK(EK(X))=X，但是知道EK和EK(X)很难破解X。在质询时，质询者产生一个随机数X，并用公钥加密，看对方是否能从EK(X)中得到X。这几种方法都需要使用钥匙（key）。钥匙从哪里来呢？客户和服务如何安全的得到钥匙呢？这个问题叫做钥匙分发（key distribution），这就需要有安全级别更高的授权机构，让它来产生钥匙并安全的分发给客户和服务器。这样的机构叫做认证服务器（authentication server）。有一个种简单的方法可以构建认证服务器：将网络划分为认证域，认证标志服对域来说是本地的，因此一个认证标志符由两部分组成：认证域和域内标识符。比如Gov.Sam就是Sam在Gov域中的认证标识。认证服务器之间通过可信通信连接。在执行远程认证时，服务器从自己本地认证服务器请求客户的公钥，本地认证服务器根据客户的域，向客户所在的认证服务器查找客户公钥，发送给服务器。接下来继续执行质询-应答协议。
</p>

<p>
在确认了客户之后，服务器需要检查客户是否被允许执行对对象的操作，这个决定叫做授权（authorize），用谓词来表示就是::
</p>

<p>
boolean = Authorize(object, authid, operation)
</p>

<p>
谓词Authorize可以看成是一个三维矩阵，称为存取控制矩阵。这是一个稀疏矩阵，只存真值。通常的方法是为每个对象保存一组&lt;authid,operation&gt;对，叫做对象的存取控制列表。也可以使用SQL表记录权限，以&lt;object,authid&gt;为索引。有一些系统会提供组（group）的概念，组可以减少存取控制矩阵的大小。当客户请求对对象操作时，会检查客户所在的组是否有访问权限。
</p>

<p>
一旦授权完成后，用户就具有了操作对象的能力。这种能力通常是存储在服务器上和客户关联的控制块内。例如客户打开一个文件，服务器分配一个文件控制块来记录客户的读写权限。客户通过标记引用控制块，服务器通过控制块避免在同一个请求时重复认证客户身份。有时客户需要直接得到操作对象的能力，这时服务器对控制块加密后发送给客户，客户后续使用时，服务器解密控制块并判断控制块是否仍然有效。
</p>

<p>
在客户调用一个服务器时，服务器可能需要调用另外一个服务器来执行客户的请求。比如客户要求邮件服务发送一份带有附件的邮件时，邮件服务需要调用文件服务获取附件。这就引入了授权扩大的概念。
</p>

<p>
当服务器开始执行客户请求，服务器的性能就成了一个重要的问题。从用户角度来看，服务器的性能可以用响应时间，即提交请求到收到响应之间的时间来衡量。响应时间由等待时间（等待服务器服务的时间，或服务器执行时等待资源的时间）和服务时间（在无需等待情况下处理请求需要的时间）组成。在m/m/l的情况下（泊松到达，负指数服务时间），平均响应时间可以用下面的公式来估计::
</p>

<p>
平均响应时间(p) = (1/(1-p))*服务时间
</p>

<p>
其中的p是系统利用率。在这种情况下，当系统利用率小于50%时，请求时间接近于服务时间。当系统利用率达到75%时，请求时间是服务时间的4倍。90%时是10倍。
</p>

<p>
文件
</p>
<hr />

<p>
文件把数据以一种设备独立的方式记录在外存储器上。文件通过create()和delete()创建和删除::
</p>

<p>
enum STATUS {OK, FAILED};
typedef char* filename;
STATUS create(filename);
STATUS delete(filename);
</p>

<p>
文件建立后，有两种方式来读写文件。一是将文件映射到地址空间，这样通过读写内存就可以操作文件。文件映射的操作大致是::
</p>

<p>
STATUS map<sub>file</sub>(filename, address<sub>space</sub>, slot);
STATUS unmap<sub>file</sub>(address<sub>space</sub>, slot);
</p>

<p>
第二中方法是显式的在内存和文件之间拷贝数据。这么做首先要打开文件，然后显式地将文件内容读取到内存中。操作类似::
</p>

<p>
typedef struct{} FILE;
STATUS open(filename, *FILE);
STATUS close(*FILE);
</p>

<p>
当客户触发open()例程后，例程根据文件名字找到文件的地址，然后检查授权，接着创建一个控制块返回给客户。通过这个控制块，客户可以从文件中读写数据::
</p>

<p>
STATUS read(FILE, file<sub>address</sub>, memory<sub>address</sub>, length);
STATUS write(FILE, file<sub>address</sub>, memory<sub>address</sub>, length);
</p>

<p>
文件系统的主要任务是存储具名文件的内容并提供读写存取操作。文件系统维护其他关于文件控制和直接存取的描述信息。文件系统为每个文件关联一个描述符，记录了文件的名字、创建者的授权标识、存取控制列表、创建时间、修改时间和访问时间等。
</p>

<p>
文件根据其内容的组织形式可以分为非结构文件和结构文件。结构文件是一个有着相似结构的记录的集合。结构文件可以分为直接的和关联存取的。直接结构可以分为输入顺序的和相关的。顺序文件每次插入的记录都放在文件尾部。相关文件是一个记录数组，记录按照数组索引写入文件。关联存取文件通过记录码来存取记录。记录码由记录的若干子域构成。根据记录码可以迅速找到记录。关联存取文件根据记录的存放策略，分为散列（hashed）文件和码顺序（key-sequenced）文件。散列文件被分成一组桶，对于给定码值，按照散列算法找到桶的序号，然后从桶中查找记录。码顺序文件按照码的顺序排列记录。在插入新记录时，计算记录的码值，将记录保存在相关码值记录的附近。有时需要多个使用码值来存取记录。比如员工记录按员工号（empno）为码值保存在关联文件中。另一个关联文件以雇员名（empname）为码值，存储记录&lt;empname,empno&gt;。后一个文件叫做辅助索引文件。
</p>

<p>
文件的各部分可以分布在一个计算机网络的几个服务器上。这种分布可以有两种形式：分割文件（文件的各个部分保存在不同的节点上）或复制文件（整个文件复制到多个节点上）。分割文件的方法很简单，把一定的码值范围作为一个分片。这些分片可以保存到不同的节点上。每个片段的描述符包括文件的完整描述。当客户打开文件，文件系统查看描述符就可以得到全部片段的情况。客户发出一个按码值读取记录的请求时，请求被发送到保存对应记录的服务器上。相关的辅助索引文件的操作也是这样。
</p>

<p>
面向记录的文件系统比非结构化文件系统更先进，但是任然没有解除客户对文件结构的依赖。提高文件系统抽象程序的一个方法是SQL语言。SQL提供了面向集合的、非过程化的数据定义、操作和控制方法。SQL是一个软件层，
</p>


<p>
标准的定义有两个目标：可移植型和互操作性。可移植性指使用标准语言编写的程序可以在不同的计算机系统上运行或提供相应的接口。互操作性指用标准的方法定义和实现数据交换，以便不同的计算机系统交换数据。大部分通信标准是按照互操作性定义的。在讨论标准时，有两个相似的术语要注意区分。API（Application Programming Interface）是应用程序编程接口。FAR（Formats And Protocols）是格式和协议。API是语法。FAR是语义。在通信中，FAR包含两个部分，一个是消息结构，一个是什么时候传递这些消息（协议）。消息格式是FAR中的最简单的部分，比如::
</p>

<p>
struct message {
    int address;
    int length;
    char buffer[length];
    int checksum;
};
</p>

<p>
协议是FAR的主要部分，协议定义了消息应该在什么时候发送，应该如何处理。其中主要的部分是解决异常的规则。协议规则通常被描述为一个状态机和每个状态转化的一个操作。状态机常被表示为一个决策表，每个状态状态有一个语义操作。通常应用开发者不是直接接触FAR，而是使用一组驱动状态机的子程序。这些子程序都是API。
</p>

<p>
API有不同形式，一些是库函数，一些是子程序。很多操作系统是根据按调用层接口（Call-Level Interface, CLI）标准来定义的。ABI（Application-Binary Interface二进制应用接口）也是一种CLI标准。
</p>

<p>
API和FAR是相辅相成的。API使得程序具有可移植性，FAR使得系统具有互操作性。
</p>

<p>
习题
</p>
<hr />
<p>
假设客户和服务器以广域网连接。单向时延是50ms，传输速率是0.1MBps。假设消息包为1KB。忽略消息广播和检查计算的成本，忽略客户和服务器的CPU时间，使用RPC方式传输文件的最短时间是多少？使用对等结构传输文件的最短时间是多少？在RPC模式下需要1MB/1KB=1000次调用，每次调用需要50ms*2=100ms时间轮休，加上1KB/0.1MBps=10ms的传输时间，一共需要1000*110ms=110s。在对等结构下，客户发送包，服务器能够确认最后一个包，一共需要1MB/0.1MBps=10s。
</p>

<p>
假设一个事务有5ms服务时间并且没有瓶颈（资源100%被利用，这限制了系统吞吐量）。假设平均事务响应时间是100ms或更少。计算满足这个响应时间要求的最大吞吐量是多少？对于一个慢10倍的处理器，吞吐量是多少？平均响应时间是100ms，事务处理时间是20ms，根据公式
</p>

<p>
平均响应时间=(1/(1-p))*服务时间
</p>

<p>
可以得到机器的利用率p=0.95。每个事务需要5ms，占系统利用率的0.5%（5ms/1s），因此系统每秒可以运行0.95/0.005=190个事务。如果处理器慢10倍，服务时间变成50ms，p变成0.5，系统可以运行0.5/0.05=10个事务。处理能力提高10倍可以让吞吐量提高20倍，这个现象叫做事务加速。这个情况只有在p&lt;0.9是才会显著。其他情况系，每秒处理的事务数几乎和服务时间成线性关系。
</p>


<p>
第三章 容错
<code>======</code>
</p>

<p>
本章讨论容错的三个方面：硬件、软件和整体。
</p>

<p>
事件A发生的可能性叫做事件A发生的概率，记为P(A)。P(A)是一个介于0和1之间的值，0表示事件A不会发生，1表示事件A一定会发生。事件A要么发生，要么不发生。因此，1-P(A)是事件A不发生的概率。对于两个事件，如果一个事件是否发生不会影响另一个事件发生的概率，就说这两个事件是独立的（independent）。AB表示事件A和B同时发生，P(AB)=P(A)*P(B)。A和B至少有一个事件发生的概率是P(A)+(1-P(A))*P(B)。如果P(A)和P(B)都很小，这个值约等于P(A)-P(B)。电子系统的失败率通常很小，并且是无记忆（memoryless）的。假设系统由三个模块A、B和C，它们的失败率分别是P(A)、P(B)和P(C)，那么系统的失败率是P(A)+P(B)+P(C)。无记忆是指一个事件发生的概率，和以前这个事件是否发生无关。如果一个事件发生的概率很小，同事又是无记忆的，就可以为这个事件定义平均发生时间。平均发生时间是概率的倒数::
</p>

<p>
MT(A) = 1 / P(A)
</p>

<p>
如果一个系统G有三个模块A、B和C，三个模块的故障平均发生时间分别为MT(A)、MT(B)和MT(C)，则系统的故障平均发生时间约等于::
</p>

<p>
1 / (1/MT(A) + 1/MT(B) + 1/MT(C))
</p>

<p>
如果一个系统G由N个相同的模块A组成，这个系统的故障平均发生时间是::
</p>

<p>
MT(G) = MT(A) / N
</p>

<p>
系统会发生故障，当系统发生故障时，就无法为用户提供服务。为了衡量系统为用户提供服务的可能性，引入了系统可用性的概念。系统可用性用百分数表示，是按可接受的响应时间内被处理的负载值。假设一个ATM平均每100天出现一次预期外的中断期，并且平均需要1天时间修复。这个ATM的可用性就是99%，故障率是1%，故障平均发生时间是100天。如果有两台ATM，系统的可用性就是99.99%，故障平均发生时间是10000天。系统按照可用性高低可以分为若干个不同的可用性等级，如：
</p>

<p>
级别 可用性     不可用性（分钟/年） 系统类型
1   90%        52560            无管理
2   99%        5256             有管理
3   99.9%      526              管理良好
4   99.99%     53               容错
5   99.999%    5                高可用
6   99.9999%   0.5              超高可用
7   99.99999%  0.05             极高可用
</p>

<p>
可用性等级有一个更正式化的定义：如果系统的可用性是A，系统的可用性等级就是floor(log10(1/(1-A)))。
</p>

<p>
下面介绍一些和容错相关的术语。一个系统由一个或多个模块组成。每个模块有自己理想的指定行为（specified behaviour）和观察行为（observed behaviour）。指定行为是我们希望这个模块所具有的行为，观察行为是我们观察到的这个模块的实际行为。如果观察行为和指定行为不一致，就说明发生了失败（failure，或失效）。失败是因为模块中存在错误（error）或缺陷（defect）。导致失败的原因叫故障（fault）。如果一个错误引发了失败，从发生错误到失败（观察到观察行为和指定行为不一致）的时间叫做错误延迟。失败使得错误变成有效的。在失败之前，错误是延迟的。比如在宇宙飞船上，宇宙射线（故障）可能破坏一个存储单元，引起存储错误。当读取这个存储单元时，产生错误结果（读取失败），使错误变得有效。
</p>

<p>
如果一个模块的观察行为和指定行为相匹配，它就处于服务可完成状态，否则它处于服务中断状态。如果一个模块长时间处于服务可完成状态，说明它的可靠性高，用平均无故障时间（MTTF）来衡量。如果一个模块处于服务中断的时间短，说明这个模块修复速度快，用平均修复时间（MTTR）衡量。模块的可用性就是处于可完成状态的时间和总时间的比：
</p>

<p>
MTTF / (MTTF + MTTR)
</p>

<p>
模块的可靠性可以通过减少故障来改进，故障可以通过有效构造和纠错来避免。有效确认可以在构造模块的过程中排除错误。纠错是通过冗余容错来减少失败。纠错有两种方法，延迟纠错是在错误变得有效之前探测并更正潜在错误。生效纠错是在失败发生之后更正错误。生效纠错可以屏蔽错误或从错误中恢复。错误屏蔽使用冗余信息提供正确的服务并建立一个正确的新状态。错误恢复拒绝被请求的服务，并将模块设置为无错误状态。错误恢复有两种形式：反向错误恢复指恢复到之前的正确状态（如检查点），正向错误恢复是建立一个新的正确状态（如使用冗余副本恢复）。有一些情况下，正确的行为可以完成，但是会延迟很久。这种情况叫做计时失败。故障可以分为硬故障和软故障。一个具有硬故障的模块无法正确运行，它会继续保持较高的故障率，直到故障被修复。软故障也叫瞬时故障或间歇故障。
</p>

<p>
如果一个模块的故障延迟很小，这个模块叫做失败即停（fastfail或faststop）的。失败即停特性可以避免潜在的单一错误变成级联的错误。
</p>


<p>
系统由一个或多个模块构成。模块有一个理想的预期行为（specified behaviour）和实际表现出来的观察行为（observed behaviour）。如果观察行为违背了预期行为，失败（failure）就会发生。失败是因为模块中存在错误（error）或缺陷（defect）。导致错误的原因是故障（fault）。错误和失败不一定是同时发生的。发生错误到导致失败之间的时间叫做错误延迟。只有在导致失败时，错误才被称为有效的。下面用一个例子解释故障、错误和失败的关系。一个宇宙射线（故障）破坏了一个存储单元，引起了一个存取错误。但是只有当系统需要从这个存储单元中读取数据时，才会发生失败，这时错误变成有效的。
</p>

<p>
模块的可观察状态由两个：服务可完成和服务中断。模块的可靠性使用平均无故障时间（MTTF，从初始状态到下一个发生失败事件的时间）衡量。一个和MTTF紧密联系的指标是平均修复时间（MTTR，服务中断时间）。这两个指标可以用来衡量模块的可用性：
</p>

<p>
模块可用性 = MTTF/(MTTF+MTTR)
</p>

<p>
模块的可靠性可以通过减少故障来改进。故障可以通过有效构造和纠错来避免。有效确认可以在构造模块的过程中排查错误。纠错可以通过冗余来减少失败。纠错有两种类型：延迟纠错和生效纠错。延迟纠错是在错误变成有效（失败）之前进行纠错。生效纠错是在错误变成有效之后更正错误。有效错误处理能屏蔽错误或从错误中恢复。错误屏蔽是使用冗余信息建立一个正确的新状态。错误恢复拒绝请求并将模块设置为无错状态。反向错误恢复是指恢复到之前的正确状态。正向错误恢复是指建立一个新的正确状态。如果一个失败是让正确的行为延迟，这个叫做计时失败。
</p>

<p>
故障分为软故障和硬故障。有硬故障的模块不能正确运行，会继续保持较高的故障率，直到被修复。软故障也叫瞬时故障或间歇故障。
</p>

<p>
一个模块如果在检测到故障后立即停止，并且有一个较小的故障延迟，这个模块就叫做失败即停（failfast或failstop）。失败即停使故障延迟和潜在故障最小化。
</p>


<p>
服务不可获得的情况叫做断供（outage）。断供可以分为以下几类原因：
</p>

<p>
环境。如机房、电源、数据线路等。
操作。系统配置、系统操作。
维护。为维护和修复硬件所执行的操作（不包括软件维护）。
硬件。物理设备。不包括环境支持（如空调）。
软件。系统中的程序，和为维护软件所执行的操作。
过程。如罢工、行政决策（交易所熔断）。
</p>

<p>
操作错误有两类：配置和过程。配置错误包括那些有启动文件的东西，比如使用旧版本配置文件，或者混合使用不同版本软件。过程错误是类似文件过大导致没有磁盘空间这样的错误。改善操作错误的方法是消除操作过程或使操作过程自动化，即用软件代替操作。
</p>

<p>
模块的失败率常常遵从浴缸曲线。刚开始失败率较高，这个阶段叫做burn-in。之后失败率长时间维持在一个较低的水平。之后失败率会迅速升高。
</p>

<p>
失败即停的模块可以很容易的从普通硬件上构造。最简单的叫做双工设计，将两个模块的输入和输出连到一个比较器，当二者不一致时停止工作。更一般的，可以使用n个模块。这时比较器也叫做表决器。如果有超过半数的模块输出了同一个结果，表决器选择这个结果作为输出。否则叫做表决失败（failvote），模块停止运行。最常用的是n=2和n=3的情况，分别叫做双模冗余和三模冗余（Triple Module Redundancy，TMR）。表决器也可以首先检测哪些模块可用，根据可用模块中大大多数进行表决。表决器忽略故障模块直到其被修复。如果全部模块不可用，直接停止。这种优化方式叫做失败即停表决（fastfail voting）。这种方式的可靠性更高，在达不到多数模块可用时仍然可以进行表决。考虑n=10的情况，对于表决失败策略，当其中5个模块损坏时，n工模块不可用。而对于失败即停表决，当第9个模块损坏时，n工模块才变成不可用。
</p>

<p>
假设一个模块的MTTF是10年，采用三模冗余的方式构造，MTTF变成10年/3+10年/2=8.3年。看上去n工模块降低了MTTF，提高的故障发生的可能性，不过n工模块提供了失败即停特性。失败即停使得模块的行为更容易推导，提供了建立容错系统的可能。另一方面，如果故障中的软故障占大多数，假设硬故障占全部故障的1%，并且如果TMR屏蔽全部软故障，模块的MTTF可以提升为原来的100倍，TMR故障表决的MTTF会提升为83333年。
</p>

<p>
使用故障表决的n工模块称为一个超级模块。如果没有模块可用，超级模块就会出现故障。一个模块不可用的概率是MTTR/(MTTF+MTTR)，约等于MTTR/MTTF。n-1个模块不可用的概率约等于(MTTR/MTTF)<sup>(n-1)</sup>。一个模块出故障的概率是1/MTTF，因此某个模块故障而导致全部模块都不可用的概率是(1/MTTF)*(MTTR/MTTF)<sup>(n-1)</sup>。n工模块中一共有n个这样的模块，因此超级模块故障的概率是n*(1/MTTF)*(MTTR/MTTF)<sup>(n-1)</sup>。因此，n工模块的MTTF是：
</p>

<p>
MTTF(n) 约等于 (MTTF/n)*(MTTF/MTTR)<sup>(n-1)</sup>
</p>

<p>
修复是可靠性的关键。有了足够的修复，工作最终可以完成。立即修复是高可用性的关键，它可以屏蔽所有故障，模块故障不会导致拒绝服务。立即修复是的模块的故障看上去都是软故障。
</p>

<p>
软件容错技术主要有两种：N版本程序设计和事务。N版本程序设计是把程序写n次，仔细测试每个程序，然后并行的运行所有n个版本的程序，选择占大多数的结果。事务是把程序当做一个具有一致性检查的ACID状态转换来写。在事务的最后，如果一致性检查不满足，终止事务并重新开始。N版本程序设计方法主要的问题在于模块修复。由于每个模块的内部状态不一致，无法通过复制状态的方法修复模块。
</p>

<p>
有人把软件缺陷（bug）分为Heisenbug和Bohrbug。Heisenbug是难以复现的、偶发的，通常和时刻及负载有关。Bohrbug是确定的，按照一定步骤可以稳定复现。在发生失败时，Heisenbug只会影响一个用户，因此也被称为良性的。一些分析报告显示，系统中大部分错误是Heisenbug。
</p>

<p>
事务的ACID特性允许系统崩溃，然后自然的重启。唯一的损失是系统崩溃并重启的时间。事务可能只撤销一个事务而不是重启整个系统，这样就限制了故障的范围。但是分布式计算的核心问题在于整个系统不能重启，只有部分能重启。因此分布式系统重启就需要增加一个技术来清除任何分布式状态。
</p>

<p>
失败即停的程序设计风格叫做防御式编程。无论什么时候模块调用一个子程序，被调用者检查参与以保证健全，调用者则检查例行程序的结果。一旦发现错误，一个异常处理程序被调用。异常处理程序要么屏蔽异常，要么将异常返回给调用者（如果是调用者的错误）。在极端的情况下，异常处理程序不能屏蔽错误，因此就把错误当成一个事务中止、子系统重启或是恢复的另一个普通形式返回。
</p>

<p>
失败即停产生了对立刻崩溃然后重启的需求。一个方案是进程对或系统对。系统对是两个位于不同地点的相同的系统。第二个系统拥有第一个系统的全部数据，随时接受来自第一个系统的所有更新。如果一个系统崩溃，另外的系统立即接管工作。
</p>

<p>
设计容错程序需要一个模型，这个模型必须能够定义正确的行为。模型包含进程、消息和存储三种类型的实体，每个实体有期望行为集合和故障行为集合。故障行为可以分为预期故障（设计中可容错的故障）和非预期故障（设计中不可容错的故障）。非预期故障可以分为稠密故障和拜占庭（Byzantine fault）故障。稠密故障：算法是n容错的。如果在修复期间超过n个故障，将中断服务。拜占庭错误：假定程序是失败即停的，使系统不符合模型行为的故障称为拜占庭故障。
</p>

<p>
模型模拟了实体的行为，揭示其失败的特征。比如存储器可能把数据写入错误的地址、无效的页或破坏了整个存储器。对于出现这些错误的存储模块，可以采用故障屏蔽程序，采用失败表决双工，并使用一个后台程序修复故障。
</p>

<p>
消息可能复制、丢失、延迟、破坏、乱序，通过实现会话、设定超时、消息序号，所有错误的消息转化为丢失的消息。加上消息确认、发送超时和消息重传，可以使消息系统具有高可用性。
</p>

<p>
下面的情况会引起进程失败：修复时间被延迟、进程数据重置为空，丢弃进程的输入和输出消息。这里使用模型表明如何建立进程对。一个进程（叫做主进程）执行工作直到失败。然后另一个进程（叫做后备进程）接管主进程的工作继续计算。在正常的处理中，主进程周期的发送“I'm Alive”消息给后备进程。如果后备进程在两个消息周期内没有从主进程接收到消息，它就认为主进程失败了，开始接替主进程。接管有三种形式：
</p>

<p>
检查点重启。主进程记录自己的状态到双工存储模块。接管时，后备进程通过读双工存储页开始启动。
检查点消息。主进程把自身状态的改变作为消息发给后备进程。接管时，后备进程从最新的消息中获得当前的状态。
持久进程。后备进程从空状态开始，让食物机制清除（撤销）最近还没有提交的状态变化。
</p>

<p>
进程对通过快速修复是的进程具有很高的可用性。某些程序不能满足抽象事务级，因此必须使用检查点这种形式以获得高可用的程序执行。这种原始程序的例子有事务机制本身、操作系统核心、控制物理设备的程序。任何一种检查点都是难以理解的。可以用事务性持久进程取代它。用进程对屏蔽硬件故障（如处理器故障）和暂时的软件故障效果一样好。n
</p>

<p>
建立高可用的存储
</p>
<hr />

<p>
建立高可用存储的步骤如下：首先，定义基本的存储操作和失败行为。然后定义更高级的操作，这些操作可以用很高的概率通过n工设备屏蔽故障行为。下面是一个简单的存储模型。存储模块包含一个页面数组和一个状态标志。如果模块的状态标志为FALSE，那么它已经失败，所有在这个页上的操作返回FALSE。每个页有地址、值和状态。地址是有上限的正数。状态是TRUE或FALSE。如果状态是FALSE，页的值是无效的。存储模块定义了两种操作：写页的值和读页的值。重写一个页会将页的状态修复为TRUE。这些定义很直观的对磁盘和RAM进行建模。
</p>

<p>
一段模拟存储器的代码::
</p>

<p>
namespace storage 
{
        int const Many = 10000;
        int const MaxStores = Many;
        int const MaxStore = Many;
        int const VSize = 8192;
</p>

<p>
typedef char* avalue;
typedef unsigned long address;
</p>

<p>
typedef struct 
{
        bool status;
        char value[VSize];
} apage;
</p>

<p>
typedef struct
{
        bool status;
        apage page[MaxStore];
} astore;
astore stores[MaxStores];
</p>

<p>
int double pwf = 1e-6; <i>/ 无效写概率
int double prf = 1e-8; /</i> 无效读概率
</p>

<p>
// 写页的值
bool store<sub>write</sub>(astore store, address addr, avalue value)
{
        if (addr &gt;= MaxStore)  // 地址错误
        {
                return false;
        }
        if (!store.status) // 模块状态错误
        {
                return false;
        }
        if (pwf &gt; rand())  // 模拟写失败
        {
                return true;
        }
        store.page[addr].status = true;
        copy(store.page[addr].value, value, VSize); // 实际写入
        return true;
}
</p>

<p>
        bool store<sub>read</sub>(astore store, address addr, avalue value)
        {
                if (addr &gt;= MaxStore) // 地址错误
                {
                        return false;
                }
                if (!store.status)  // 模块状态错误
                {
                        reurn false;
                }
                if (!store.page[addr].status) // 页错误
                {
                        return false;
                }
                if (prf &gt; rand())  // 模拟读失败
                {
                        return true;
                }
                copy(value, store.page[addr].value, VSize);
                return true;
        }
}
</p>

<p>
为了避免读写到错误的页，可以把页的地址作为页值的一部分。在读页时如果发现地址不匹配，将页标记为无效。为了避免读取到错误的内容，可以为页的值增加检验和。在读取时重新计算检验和并比较。如果校验失败，将页标记为无效。
</p>

<p>
存储页可用由于不正确的store<sub>write出错</sub>，也可能因为其他原因，比如震动、辐射等自然出错。这个现象可以通过存储的衰减进程来模拟。在基础的操作上，衰减进程偶尔使一个页，甚至整个存储变成无效。假设存储和页的错误是独立的，这些错误的频率遵守负指数分布::
</p>

<p>
namespace storeage
{
        int const mttvf = 7e5; <i>/ 页错误平均时间（天）
        int const mttsf = 1e8; /</i> 磁盘错误平均时间（年）
</p>

<p>
void store<sub>decay</sub>(astore store)
{
        unsigned long addr;
        unsigned long page<sub>fail</sub> = time() - log(mttvf*rand());
        unsigned long store<sub>fail</sub> = time() - log(mttsf*rand());
</p>

<p>
while (true) 
{
        wait(min(page<sub>fail</sub>, store<sub>fail</sub>) - time()); // 等待下一个事件
        if (time() &gt;= page<sub>fail</sub>)
        {
                addr = rand()*MaxStore;
                store.page[addr].status = false;
                page<sub>fail</sub> = time() - log(rand())*mttvf;
        }
</p>

<p>
                        if (time() &gt;= store<sub>fail</sub>)
                        {
                                store.status = false;
                                for (addr = 0; addr &lt; MaxStore; addr++)
                                {
                                        store.page[addr].status = false;
                                }
                                store<sub>fail</sub> = time() - log(rand())*mttsf;
                        }
                }
        }
}
</p>

<p>
修复对可用性非常重要。有了修复就可以在不可靠的模块上构建出可靠模块。一个不可靠的存储可以分成n个组，每个组是一个
大小为MaxStores/n的存储，这样就构建了一个大小为MaxStores/n的n工存储。可靠写操作会写这个组中的每个页，这样在可靠写返回成功后，至少有一个页是正确的::
</p>

<p>
namespace storage
{
        int const NPlex = 2;
        bool reliable<sub>write</sub>(unsigned long group, address addr, avalue value)
        {
                unsigned long i;
                bool status = false;
                if (group &gt;= MaxStores / NPlex)
                {
                        return false;
                }
                for (i = 0; i &lt; NPlex; i++)
                {
                        status = status || store<sub>write</sub>(stores[group * NPlex + i],
                                                       addr, value);
                }
                return status;
        }
}
</p>

<p>
可靠读函数会读取组中的每一个页。这时会出现两种情况，一是每个页都失效。通常这种情况很少发生。如果这种情况频繁发生，要增加n的值。第二种情况是部分页可读，但这些可读的页具有不同的值。一个解决歧义的方法是取多数集。但多数集未必是最新写入的数据。因此有产生了第二种方法，为每个值增加版本，只读取最新的版本。如果一个n工的读程序发现版本不一致的情况，它读取最新版本，并把这个值写入同组的其他页。如果一个页失效，读程序也会重写这个页::
</p>

<p>
namespace storage
{
        unsigned long version(avalue);
</p>

<p>
bool reliable<sub>read</sub>(unsigned long group, address addr, avalue value)
{
        unsigned long i = 0;
        bool gotone = false;
        bool bad = false;
        avalue next;
        bool status;
</p>

<p>
if (group &gt;= MaxStores / NPlex)
{
        return false;
}
</p>

<p>
for (i = 0; i &lt; NPlex; i++)
{
        status = store<sub>read</sub>(stores[group * NPlex + i], addr, next);
        if (!status)
        {
                bad = true;
        }
        else if (!gotone)
        {
                copy(value, next, VSize);
                gotone = true;
        }
        else if(version(next) != version(value))
        {
                bad = true;
                if (version(next) &gt; version(value))
                {
                        copy(value, next, VSize);
                }
        }
}
</p>

<p>
if (!gotone)
{
        return false;
}
</p>

<p>
                if (bad)
                {
                        reliable<sub>write</sub>(group, addr, value);
                }
                return true;
        }
}
</p>

<p>
如果一个n工的页很多年没有读到，它的n个副本可能会自然衰减。为了防止这个情况，需要运行存储修复程序。修复程序定期读取存储，如果发现不一致或失效，就进行修复::
</p>

<p>
namespace storage
{
        void store<sub>repair</sub>(unsigned long group)
        {
                int i;
                avalue value;
                while (true)
                {
                        for (i = 0; i &lt; MaxStore; i++)
                        {
                                wait(1);
                                reliable<sub>read</sub>(group, i, value);
                        }
                }
        }
}
</p>

<p>
对n工组有一种乐观读方式，首先执行不可靠读，只有在失败时才执行可靠读。乐观读减少了读的通信量，但是有可能读到脏数据::
</p>

<p>
bool optimistic<sub>read</sub>(unsigned long group, address addr, avalue value)
{
        if (group &gt;= MaxStores / NPlex)
        {
                return false;
        }
        if (addr &gt;= MaxStore)
        {
                return false;
        }
        if (store<sub>read</sub>(stores[group * NPlex], addr, value))
        {
                return true;
        }
        else
        {
                return reliable<sub>read</sub>(group, addr, value);
        }
}  
</p>

<p>
进程通过消息进行交互。在讨论进程时，首先要定义消息::
</p>

<p>
double const pmf = 1e-5; <i>/ 消息失败（丢失或损坏）的概率
double const pmd = 1e-5; /</i> 消息复制的概率
typedef struct Message *amessagep;
typedef struct Message
{
        bool status;
        amessagep next;
        avalue value;
} amessage;
</p>

<p>
bool message<sub>send</sub>(processId him, avalue value); <i>/ 发送消息给一个进程。如果进程存在，返回true。
bool message<sub>get</sub>(avalue *valuep, bool *msg<sub>status</sub>); /</i> 获得进程的下一个消息。如果消息则存在返回true。msg<sub>status保存消息状态</sub>。
</p>

<p>
下面的示例展示了消息例程的用法::
</p>

<p>
bool get<sub>msg</sub>(avalue *valuep)
{
        bool msg<sub>status</sub> = false;
        bool msg<sub>exists</sub> = false;
        while (msg<sub>status</sub> = false)
        {
                msg<sub>exists</sub> = message<sub>get</sub>(&amp;valuep, &amp;msg<sub>status</sub>);
                if (!msg<sub>exists</sub>)
                {
                        break;
                }
                return msg<sub>exists</sub>;
        }
}
</p>


<p>
进程执行一个程序，转换该进程的状态，显示执行的动作。进程的外部行为是store<sub>read</sub>()、store<sub>write</sub>()、message<sub>send</sub>()、message<sub>get</sub>()操作的一个序列。进程有两个状态：初始状态固定不变，当前状态在程序的每一步都会改变。进程还有一个输入队列，记录了其他进程发送过来的无序消息::
</p>


<p>
const unsigned long MaxProcess = Many;
typedef unsigned long processid;
typedef struct
{
        char program[Many/2];
        char data[Many/2];
} state;
struct 
{
        state initial;
        state current;
        amessagep messages;
} process [MaxProcess];
</p>

<p>
一个进程由于停止了一段时间（比如一个小时）而失败并需要修复，然后重置为初始状态，抛弃未处理的输入消息。设想每个进程由一个低水平的自动操作实现，它通常是执行进程的下一步，但是在修复期间会停止进程的执行，抛弃进程的所有消息，把进程重置为初始状态。然后从初始状态继续执行。此外，进程可以由防御性程序设计测试。如果测试结果是假，就调用panic()使进程立即失败。这样一个自动操作定义如下::
</p>


<p>
const double mttpf = 1e7; <i>/ 进程的平均失败时间
const double mttpr = 1e4; /</i> 平均修复时间
</p>

<p>
void process<sub>execution</sub>(processid pid)
{
        unsigned long proc<sub>fail</sub>;
        unsigned long proc<sub>repair</sub>;
        amessagep msg, next;
        while (true)
        {
                proc<sub>fail</sub> = time() - log(rand()) * mttpf; <i>/ 下一个失败时刻
                proc<sub>repair</sub> = -log(rand()) * mttpr;       /</i> 下一个进程修复延迟
                while (time() &lt; proc<sub>fail</sub>)                // 执行进程
                {
                        execute(process[pid].current);
                }
                wait(proc<sub>repair</sub>);                         <i>/ 因修复而中断
                copy(process[pid].current, process[pid].initial, Many);  /</i> 重置为初始状态
                while (message<sub>get</sub>(msg, status))
                {
                        // 抛弃消息
                }
        }
</p>

<p>
}
</p>

<p>
上面介绍的进程模型是失败即停的，但不是可靠的。因为失败后进程无法修复自身状态。因此需要另外的修复机制。为了减低起见，假设进程的状态可以只用一个页存储。对于每个客户请求，进程分配一个唯一的序列号，叫做标签。最简单的方法是检查点重启。进程在可靠存储中记录状态的两个副本。当状态改变时，进程覆盖副本中较旧的状态。在重启时，进程读取两个副本，从最新的值开始重新执行。下面是一个可靠检查点重启的示例::
</p>

<p>
void checkpoint<sub>restart</sub><sub>process</sub>()
{
        unsigned long disk = 0;
        unsigned long address[2] = {0,1};
        unsigned long old;
        struct
        {
                unsigned long ticketno;
                char filler[VSize];
        } value [2];
        struct msg
        {
                processid him;
                char filler[VSize];
        } msg;
</p>

<p>
for (old = 0; old &lt;= 1; old++)
{
        if (!reliable<sub>read</sub>(disk, address[old], value[old]))
        {
                panic();
        }
}
</p>

<p>
if (value[1].ticketno &lt; value[0].ticketno)
{
        old = 1;
}
else
{
        old = 0;
        copy(value[0], value[1], VSize);
}
while (true)
{
        while (!get<sub>msg</sub>(&amp;msg)) // 取下一个请求
        {
                NULL;
        }
</p>

<p>
                value[0].ticketno = value[0].ticketno + 1;
                if (!reliable<sub>write</sub>(disk, address[old], value[0]))
                {
                        panic();
                }
                old = (old + 1) % 2;
                message<sub>send</sub>(msg.him, value[0]);
        }
}   
</p>

<p>
检查点重启可以提供可靠性，但是可用性较差。原因是进程修复的时间较长。进程对方案可以提供高可用。进程与n工存储类似，存在n个进程。在任何时间都有一个主进程。主进程发送服务。如果主进程失败，备份进程继续服务。客户向主进程发送请求，如果主进程失败，新的主进程会通知客户。进程接管涉及两个方面：探测（知道主进程失败）和连续性（知道主进程的最近状态）。主进程在正常时向备份进程发送I'm Alive消息。如果消息在一段时间内没有到达，说明消息延迟或丢失。如果连续几个消息都没有到达，后备进程就可以认为主进程失败。后备进程要知道主进程的状态，通常的做法是主进程将I'm Alive消息和状态变更消息一起发送给后备进程。这个消息叫做检查点消息。在接管时，后备进程和应该和主进程在发送检查点消息后的状态一样。可能出现这样的情况，主进程失败了，同时检查点消息也丢失了。这时后备进程会处于不确定的状态。这种失败的平均时间大约是MTTPF/pmf。如果这种失败不可容忍，主进程必须在确认后备进程同步状态后才能应答客户。
</p>

<p>
如果一个程序能够可靠的表明一个操作是否完成，这个操作就叫做可测的。写磁盘页是可测的，可以通过读磁盘页判断操作是否完成。移动到位置X是可测的，只要判断移动后的位置是否是X。但是相对性的操作是不可测的，比如移动1厘米。如果重复执行一个操作，和执行这个操作一次的效果相同，这个操作就叫做可重复的，或幂等的。写磁盘页是可重复的，移动1厘米不可重复。在接管时，新的主进程无法确定客户是否收到应当，因此会重复发送应答。客户收到重复应答后忽略。这个操作是不可测的而可重复的。
</p>

<p>
进程对中有一类最简单的形式叫做持久进程对。持久进程对没有状态或上下文、检查点或I'm Alive消息，在处理完请求后立即恢复到初始状态。持久进程对以事务形式保存状态。如果主进程失败，事务机制中断主进程的事务，后备进程从一致的状态开始。如果主进程作出改变后调用CommitWork()提交结果，事务机制把服务器的消息可靠的发给客户::
</p>

<p>
void persistent<sub>process</sub>()
{
        wait<sub>to</sub><sub>be</sub><sub>primary</sub>();  // 等待成为主进程
        while (true)
        {
                BeginWork();
                read<sub>request</sub>();
                doit();
                CommitWork();
                reply();
        }
}
</p>

<p>
下面的代码将检查点重启服务器重写为一个事务型服务器::
</p>

<p>
void persistent<sub>ticket</sub><sub>server</sub>()
{
        int ticketno;
        struct msg
        {
                processid him;
                char filler[VSize];
        } msg;
        wait<sub>to</sub><sub>be</sub><sub>primary</sub>();
        while (true)
        {
                BeginWork();
                while (!get<sub>msg</sub>(&amp;msg)) 
                {
                        // NULL
                }
                exec<sub>sql</sub>("update ticket set ticketno=ticketno+1");
                ticketno = exec<sub>sql</sub>("select max(ticketno) from ticker");
                CommitWork();
                message<sub>send</sub>(msg.him, value);
        }
}
</p>

<p>
事务提供了高可靠。进程对提供了高可用，但是接管工作非常繁琐。事务加上持久进程对，使得简单的程序可以提供高可靠和高可用。很多应用级的容错进程对都使用事务机制和持久进程对。低级别的进程对（如设备驱动、TP监视器）编写为原始进程对，因为它们位于事务的抽象级别以下。
</p>

<p>
下面讨论如何构建可靠消息。进程调用message<sub>send</sub>()把消息发送给另一个进程。这个函数指定了进程的标识符和消息数据，它把发送者地址空间中的消息数据拷贝到接收者的输入队列，接收者然后调用message<sub>get</sub>()把消息从输入队列拷贝到自己的地址空间。下面是message<sub>send</sub>()和message<sub>get</sub>()的代码::
</p>

<p>
bool message<sub>send</sub>(processid him, avalue value)
{
        amessagep it;
        amessagep queue;
        if (him &gt; MaxProcess)
        {
                return false;
        }
loop:
        it = malloc(sizeof(amessage));
        it-&gt;status = true;
        it-&gt;next = NULL;
        copy(it-&gt;value, value, VSize);
        queue = process[him].messages;
        if (queue == NULL)
        {
                process[him].messages = it;
        }
        else
        {
                while (queue-&gt;next != NULL)
                {
                        queue = queue-&gt;next;
                        queue-&gt;next = it;
                }
        }
</p>

<p>
        if (rand() &lt; pmf)
        {
                it-&gt;status = false;
        }
        if (rand() &lt; pmd)
        {
                goto loop;
        }
        return true;
}
</p>

<p>
bool message<sub>get</sub>(avalue *valuep, bool *msg<sub>status</sub>)
{
        processid me = MyPID();
        amessagep it;
        it = process[me].messages;
        if (it == NULL)
        {
                return false;
        }
        process[me].messages = it=&gt;next;
        *msg<sub>status</sub> = it-&gt;status();
        copy(valuep, it-&gt;value, VSize);
        free(it);
        return true;
}
</p>

<p>
消息的故障模型很简单，一部分是自然的衰减（状态为FALSE），一部分由于重复。这个模型模拟了通信线路、缓冲区溢出和其他方面的错误。也模拟了偶尔会重复消息和输入队列中的消息可以被改变顺序。
</p>

<p>
使消息可靠的第一步是确定简单的失败语义：失败即停语义。为了做到这一点，出错的消息被转换为丢失的消息。消息的语义如下：消息依次发送，一些消息会丢失。在这里，消息失败的唯一形式是消息丢失。首先把破坏的消息转换为丢失的消息。对消息内容计算校验和，并将校验和作为消息的一部分发送。接收者重新计算校验和，如果校验失败，丢弃消息。
</p>

<p>
处理消息丢失、重复或乱序的方法是使用会话和消息序列号机制。会话是双向的消息通道，它的语义如下：消息按照顺序发送到目的地，消息不会重复和丢失，但是可能延迟。会话通过两个端点实现了这些语义。会话中的每个端点包括3个序号：输出序号（端点向会话输出的最后一个消息序号）、输入序号（端点从会话中读取的最后一个消息序号）、确认序号。会话端点在发送消息时，将输出序号加1。在接收消息时，将输入序号加1，然后发送一个无次序的确认序号给发送方。序列号可以发现重复的延迟的消息。如果一个消息重复了，它的序列号也会重复。接收方通过检查已经接收到的序列号，就可以知道发生了消息重复。这时接收方忽略这个消息，并发送一个确认消息给发送方。如果消息因为丢失或延迟而没有按顺序到达，接收方会发现收到的序列号不是连续的，存在空洞。接收方可以不发送确认消息，让发送方重新发送丢失的消息。如果一个消息失败，发送方不会收到确认消息。因此发送方需要设定一个超时时间，如果在这期间没有收到确认消息，发送方重新发送消息来进行修复。会话和重传让消息变得可靠。
</p>

<p>
上面讨论了消息失败的情况。消息是一个进程发给另一个进程的。如果进程失败了，消息仍然无法被收到。一个显而易见的方法是把会话的端点做成进程对，在发送消息或确认之前，首先改变进程状态并建立检查点。如果主进程失败，后备进程立即接管，重发主进程发送但没有收到确认的消息。会话和进程对使消息变得可用。
</p>

<p>
下面是会话相关的代码示例::
</p>

<p>
typedef struct Session *asessionp;
typedef struct Session
{
        processid source;
        processid target;
        unsigned long in;
        unsigned long out;
        unsigned long ack;
} asession;
</p>

<p>
enum MSG<sub>TYPE</sub> 
{
        MSG<sub>NEW</sub>,
        MSG<sub>ACK</sub>,
        MSG<sub>TAKEOVER</sub>
};
</p>

<p>
typedef struct Session<sub>message</sub> *a<sub>session</sub><sub>messagep</sub>;
typedef struct Session<sub>message</sub>
{
        asession session;
        MSG<sub>TYPE</sub> type;
        avalue value;
} a<sub>session</sub><sub>message</sub>;
</p>

<p>
asession my<sub>session</sub>[MaxProcess];
amessagep in<sub>msg</sub><sub>queue</sub>[MaxProcess];
void initialize<sub>sessions</sub>(void)
{
        int him;
        for (him = 0; him &lt; MaxProcess; him++)
        {
                my<sub>session</sub>[him].source = MyPD();
                my<sub>session</sub>[him].target = him;
                my<sub>session</sub>[him].in = my<sub>session</sub>[him].ack = my<sub>session</sub>[him].out = 0;
                in<sub>msg</sub><sub>queue</sub>[him] = NULL;
        }
}
</p>

<p>
bool session<sub>get</sub>(asession *session, MSG<sub>TYPE</sub> *type, avalue *value);
bool session<sub>send</sub>(asession *session, MSG<sub>TYPE</sub> *type, avalue *value);
</p>

<p>
const unsigned long timeout = 1;
void reliable<sub>send</sub><sub>message</sub>(processid pid, avalue value)
{
        asessionp sessionp = &amp;my<sub>session</sub>[pid];
        sessionp-&gt;out = sessionp-&gt;out + 1;
        checkpoint(*sessionp, value);
        do 
        {
                session<sub>send</sub>(*sessionp, MSG<sub>NEW</sub>, value);
                wait(timeout);
        }
        while (sessionp-&gt;out != sessionp-&gt;ack);
}
</p>

<p>
等等接收者的确认可能产生消息死锁——每个进程都在等待下一个进程的确认。为了避免这种情况，加速消息流动，接收者应该快速异步确认消息。这意味着进程要轮训它的输入消息。
</p>

<p>
很多操作系统会提供一种轻量级进程，叫做线程。线程可以共享地址空间。每个地址空间有一个监听进程，它完成消息的确认，并增加消息的序列号。监听程序轮训应用进程的会话。当消息到达时，监听进程执行有关序列号的操作。如果消息是一个输入消息，监听进程确认这个消息，并把消息放入应用程序进程的会话消息队列。如果消息是一个确认消息，监听程序执行这个确认序列号的操作。::
</p>


<p>
void listen(void)
{
        asession session;
        processid him;
        MSG<sub>TYPE</sub> type;
        unsigned long seqno;
        avalue value;
        amessagep it;
        amessagep queue;
        initialize<sub>sessions</sub>();
</p>

<p>
while (true)
{
        while (session<sub>get</sub>(&amp;session, &amp;type, &amp;value))
        {
                him = session.source;
                seqno = session.out;
                switch (type)
                {
                case MSG<sub>NEW</sub>:
                        if (my<sub>session</sub>[him].in == (seqno - 1)) 
                        {
                                it = malloc(sizeof(amessage));
                                copy(it-&gt;value, value, VSize);
                                it-&gt;next = NULL;
                                if (in<sub>msg</sub><sub>queue</sub>[him] == NULL)
                                {
                                        in<sub>msg</sub><sub>queue</sub>[him] = it;
                                }
                                else
                                {
                                        for (queue = in<sub>msg</sub><sub>queue</sub>[him]; queue-&gt;next != NULL; )
                                        {
                                                NULL;
                                        }
                                        queue-&gt;next = it;
                                }
                                my<sub>session</sub>[him].in++;
                                checkpoint(my<sub>session</sub>[him], value);
                        }
                        session<sub>send</sub>(session, MSG<sub>ACK</sub>, value);
                        break;
                case MSG<sub>ACK</sub>:
                        if (session.out == my<sub>session</sub>[him].out)
                        {
                                my<sub>session</sub>[him].ack++;
                        }
                        break;
                case MSG<sub>TAKEOVER</sub>:
                        break;
                default:
                        break;
                }
        }
</p>

<p>
                wait(1);
        }
}
</p>

<p>
bool reliable<sub>get</sub><sub>message</sub>(processid him, avalue value)
{
        amessagep msg = in<sub>msg</sub><sub>queue</sub>[him];
        if (msg == NULL)
        {
                return false;
        }
        in<sub>msg</sub><sub>queue</sub>[him] = msg-&gt;next;
        copy(value, msg-&gt;value, VSize);
        free(msg);
        return true;
}
</p>

<p>
reliable<sub>get</sub><sub>message</sub>()、reliable<sub>send</sub><sub>message</sub>()和监听程序一起，把普通的消息转变为失败即停的消息。它们抛弃了破坏的、重复的和序列改变的消息。发送者的超时和重传确认机制把失败即停消息转换为可靠消息。进程对让会话端点可用，因而把消息转换为可靠可用的。
</p>

<p>
习题
</p>
<hr />
<ol class="org-ol">
<li><p>
故障的到达率是lambda=1/MTTF。故障通常服从指数分布::
</p>

<p>
f(t) = lambda * e<sup>-lambda*t</sup>
</p>

<p>
从现在到时间T之间出现故障的概率是::
</p>

<p>
F(t) = sum<sub>0</sub><sup>T</sup> lambda*e<sup>-lambdat</sup> = 1 - e<sup>-lambdaT</sup>
</p>

<p>
假设一个模块的MTTF是1年。在半年内、1年内、2年内和10年内模块失败的可能性分别是0.39、0.63、0.83和0.99995。
</p></li>

<li>故障表决的双工模块的MTTF是单个模块MTTF的50%，双工失败即停模块的MTTF是单个模块MTTF的150%。</li>
<li>假设一个n版本程序在没有修复的情况下以故障表决方式运行。要让程序的MTTF翻版，n最少是多少？如果n=50，采用失败即停表决器运行，MTTF是多少？
n工模块第一个模块发生故障的时间是MTTF/n，一下模块发生故障的时间是MTTF/(n-1)。故障表决要求至少有3个模块。因此需要找到一个n，满足1/2+1/(n-1)+&#x2026;+1/3&gt;2。满足条件的最小数是19。使用同样的算法，采用50个副本和失败即停表决器，MTTF可以增加到原来的3倍。</li>
<li>一个软件模块的MTTF是1年，MTTR是1小时。根据研究，99%的软件故障是Heisenbugs。假设采用进程对和事务，可以将MTTR降低到1分钟，并屏蔽Heisenbugs。那么使用进程对和事务前后，系统的可靠性、可用性分别是多少？
采用进程对和事务之前，可靠性是1年，可用性是99.98858%。采用进程对和事务之后，可靠性是100年，可用性是99.99981%。</li>
<li>假设存储包含10万个页。存储衰减进程每7e5秒使得其中的一个页故障。每年有3e7秒。忽略整个存储的故障，一年后有多少个页故障？
单个页的MTTF是7e5*1e5=7e10秒=2.3e3年，错误的到达率lambda=1/(2.3e3年)=4.3e-2错误/年。一年后故障的页一共有1e5*1*lambda=4300个。</li>
</ol>


<p>
第四章 事务模型
<code>======</code>
</p>

<p>
原子性并不意味着在物理层面执行单一指令，而是操作结果只有两种情况，要么返回结果，要么什么都不做。操作的原子性并不是轻而易举就能得到的。下面我们以磁盘写入操作为例，讨论一下如何构建原子操作。
</p>

<p>
写操作有四种类型：简单写、带检验写、双重写和带日志写。简单写无法保证原子性。当磁盘报告错误时，存储槽中的数据是不确定的。即使磁盘报告操作成功，也有可能并未将数据写入。带检验写是在简单写完成后从磁盘读取刚刚写入的值。如果发现写入不成功，重新执行带检验写。这种方法也无法满足原子性，它不能保证写入成功，又无法恢复到初始状态。如果在操作中系统崩溃，磁盘会处于不确定状态。双重写为每个块都设置一个版本号。每次写操作后版本号都会增加。每个块被写入到磁盘的两个位置。双重写操作将数据简单写到磁盘的两个位置。采用双重写时，读取操作也要进行相应的调整：从两个位置分别读取数据，根据版本号选择最新数据作为结果。为了避免磁盘错误，两个写入位置应当位于不同的物理磁盘上。带日志写首先读取存储上的原始内容，用简单写将原始内容保存到另外的磁盘上。然后执行待检验写。如果写成功，将旧值丢弃。如果系统崩溃，只需要将原始数据写回存储位置。很多数据库使用带日志写的方法，实现磁盘操作层面的原子性。在带日志写操作中，被保存下来的原始值叫做前像日志。
</p>

<p>
有三类操作构成了系统每种服务的基础模块，它们是无保护操作、有保护操作和实操作。无保护操作是像简单写那样的操作，不具有原子性，结果是不可靠的，任何错误都可能发生。有保护操作是受控制的，支持ACID的操作。有保护操作在完成之前不会像外界提交结果，并且一旦完成后不能撤销。实操作指的是那些会影响物理世界，很难逆转的操作。比如导弹发射。实操作是一致的、隔离的、持久的，但不是原子的（少数特殊情况除外）。
</p>

<p>
上面说到简单写是无保护操作。有人可能认为简单写改变了磁盘，因此是实操作。要判断一个操作是无保护操作还是实操作，主要看有没有一个相似操作可以逆转它的结果。我们可以使用原始值覆盖的方式逆转简单写的结果，但是无法逆转导弹发射。
</p>

<p>
对于一般的系统设计，无保护操作要么在应用层控制，要么嵌入到更高层受保护操作。否则用户和系统的任何部分都不能依赖这个操作的结果。有保护操作可以构建可靠的分布式应用。实操作需要特别处理，只有在全部有保护操作不需要回滚时，才能执行实操作。
</p>

<p>
这么分类的原因在于错误处理方式的不同。考虑系统崩溃后恢复的情况。如果系统恢复时发现一个事务在崩溃前已经提交，系统需要重新执行这些操作以满足持久性。这要求操作再次执行时必须产生同样的结果。这个性质叫做幂等性。有保护操作可以构造成幂等操作，而大部分实操作不能提供幂等性。幂等是一个很好的性质，但不是必要条件。如果一个操作的结果是可以通过某些方法观察到的，事务系统也可以管理这个操作。这个性质叫做可测试性，它往往比幂等性更容易实现。对于那些即不是幂等的，又不是可测试的操作，无法使用事务管理起来。
</p>

<p>
经过前面的介绍，现在可以开始讨论事务了。首先从最简单的扁平事务（flat transaction）开始。扁平事务是在应用程序中只有一层控制的事务，即由BEGIN WORK和COMMIT WORK包围的部分位于同一层次。扁平事务有3中结果：成功完成、应用程序要求回滚、由于外部原因（如资源不足）要求回滚。扁平事务不能提交会回滚事务的一部分，也不能分成几个部分提交。但是基于扁平事务，可以构造出支持这些复杂特性的事务。
</p>

<p>
下面是一个关于借/贷业务的扁平事务示例::
</p>

<p>
exec sql CREATE TABLE accounts (
     Aid NUMERIC(9),
     Bid NUMERIC(9) FOREIGN KEY REFERENCES branches,
     Abalance NUMERIC(10),
     filter CHAR(48),
     PRIMARY KEY(Aid));
</p>

<p>
exec sql BEGIN DECLARE SECTION;
long Aid, Bid, Tid, delta, Abalance;
exec sql END DECLARE SECTION;
DCApplication() {
    read input message;
    exec sql BEGIN WORK;
    Abalance = DoDebitCredit(Bid, Tid, Aid, delta);
    if ((Abalance &lt; 0) &amp;&amp; (delta &lt; 0)) {
        exec sql ROLLBACK WORK;
    } else {
        send out msg;
        exec sql COMMIT WORK;
    }
}
</p>

<p>
long DoDebitCredit(long Bid, long Tid, long Aid, long delta) {
    exec sql UPDATE accounts
        SET Ablance = Abalance + :delta
        WHERE Aid = :Aid
</p>

<p>
exec sql SELECT Abalance INTO :Abalance
    FROM accounts
    WHERE Aid = :Aid
</p>

<p>
exec sql UPDATE tellers
    SET Tbalance = Tbalance + :delta
    WHERE Tid = :Tid
</p>

<p>
exec sql UPDATE branches
    SET Bbalance = Bbalance + :delta
    WHERE Bid = :Bid
</p>

<p>
exec sql INSERT INTO history(Tid, Bid, Aid, delta, time)
    VALUES (:Tid, :Bid, :Aid, :delta, CURRENT);
</p>

<p>
    return (Abalance);
}
</p>


<p>
扁平事务是一种非常简洁的ACID方案，可以大大简化应用代码。然而扁平事务也有自身的局限。扁平事务的控制结构十分简单，无法支持需要复杂控制结构的应用。考虑下面两个例子：
</p>

<p>
第一个例子是旅行计划例子。假设你要从加州的Bolinas到意大利的Ripa。由于两地之间没有直航班机，你必须要转乘航班或火车。假设你从San Francisco机场出发，用事务动词表示如下::
</p>

<p>
BEGIN WORK
S1 预定从San Francisco到Frankfurt的航班。
S2 预定从Frankfurt到Milan的航班。
S3 预定从Milan到Pisa的航班。
</p>

<p>
假如要在同一天从Pisa出发到达Ripa只能租车，而你又不想开夜车，你会要求代理商修改出行计划，从Milan飞到Florence，然后从Florence乘火车到达Ripa。如果使用扁平事务模型，现在只有两种选择：要么回滚，撤销已经预定的San Francisco到Milan的两张机票重新预定；要么主动取消Milan到Pisa的机票。回滚可能导致后续执行事务时订不到机票（机票卖光了）。而取消机票又可能会产生高昂的费用。
</p>

<p>
第二个例子是大量更新的例子。比如月末银行要计算账户利息。这个业务的逻辑较为简单::
</p>

<p>
ComputeInterest()
{
    real interest<sub>rate</sub>;
    receive(interest<sub>rate</sub>);
    exec sql BEGIN WORK;
    exec sql UPDATE checking<sub>accounts</sub>
             set account<sub>balance</sub> = account<sub>balance</sub> * (1 + interest<sub>rate</sub>);
    send("done");
    exec sql COMMIT WORK;
    return;
}
</p>

<p>
注意到这里的UPDATE没有使用WHERE进行范围限制，因此会应用到全部的记录上。假设一共有100万条记录，在运行了很长一段时间后，系统更新了90万条记录。这时系统发生崩溃并重启。如果使用扁平事务，已经更新的结果必须放弃并重新执行，而这些更新是有意义的，并且重新执行需要很长的时间。
</p>

<p>
不过幸运的是，扁平事务提供了构建复杂事务模型的基础。
</p>

<p>
为了得到关于面向事务的处理的更系统的观点，用一点时间回过来考虑一些细节问题：事务如何相互影响，独立性和恢复能力具体是什么含义。主要的概念是控制区域（sphere of control, SoC）。这个概念引发了事务泛型的发展。
</p>

<p>
控制区域（sphere of control，SoC）的核心思想是在分布的多用户环境下控制计算，它的主要思想是：
</p>

<p>
#. 对可能需要撤销的操作，获取其结果。
#. 检查操作之间的依赖关系，以便发现错误时能够跟着执行历史记录。
</p>

<p>
在使用控制区域时，系统必须构造由抽象数据类型组成的层次结构。控制区域包含以下3个概念：
</p>

<p>
#. 过程控制。过程控制保证原子过程所需的信息不会被其他过程修改，同时包括其他过程对该过程的依赖。
#. 原子过程。原子过程是一个具有标识符的过程，它在控制区域的某个层次上执行，由更底层次的并行或串行的原子操作组成。
#. 过程提交。考虑一个函数作为过程。状态的改变只能由这个函数决定，也只有这个函数知道。这就使得过程可以回到一个旧状态重新执行，也使得过程和错误检测或依赖于该过程的其他过程独立开来。通过控制（保持）结果的使用来防止过程提交，使得系统可以在更高的层次上撤销过程。
</p>

<p>
控制区域有两种情况，一种是过程的静态层次结构，一种是为了共享临时（中间）状态而建立的动态控制区域。考虑下面的例子：
</p>

<p>
假设Andreas和Jim是两个控制区域，Jim希望购买Andreas的房子，Andreas也同意出售。但是存在这样一个问题，Andreas担心遭受欺诈，因此希望首先收到Jim的购房款。Jim也存在同样的担心，他也希望先得到Andreas的房产证。为了解决这个障碍，需要建立一个更高层次的、动态的控制区域。新建的控制区域包含Andreas和Jim两个控制区域，托管他们的房产证和现金。如果交易成功，交换房产证和现金。如果交易失败，托管的房产证和现金分别退回。在交易结束后，动态控制区域撤销。
</p>

<p>
对于创建并运行一段时间后才发现错误的过程，控制区域也可以管理。
</p>


<p>
下面来介绍一种图形表示法，这种方法可以解释事务模型。首先来看看扁平事务状态机。为了便于排版，我把状态机表示为表格形式：
</p>

<p>
源状态 行为           目标状态
<code>==</code> <code>===========</code> <code>==</code>
NULL BEGIN WORK    活动
活动  COMMIT WORK   提交
活动  ROLLBACK WORK 中止
提交  终止           NULL
中止  终止           NULL
</p>

<p>
固定状态机无法表示状态数量变化的情况。因此这里采用控制区域模型。将原子状态事务作为基本的构建块，把不与其他事务相互作用，并且数据对象上没有依赖关系的扁平事务作为基本粒子。在SoC模型下，原子操作的依赖关系有两类：结构依赖是调用层次中已经确定的依赖关系，动态依赖是使用共享数据产生的依赖。在考察事务模型时要注意，原子操作的状态可以通过BEGIN WORK、ROLLBACK WORK和COMMIT WORK主动发生改变，也可能由于所依赖的其他操作的状态变化而改变。下面是一个原子操作的图形表示::
</p>

<hr />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-left">B</td>
<td class="org-left">C</td>
</tr>
</tbody>
</table>
<hr />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">T</td>
</tr>
</tbody>
</table>
<hr />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-left">B</td>
</tr>
</tbody>
</table>
<hr />

<p>
上面一层是原子操作信号项，表示要执行一个状态转变。里面的A、B和C分别表示“中止”、“开始”和“提交”。中间一层的T是原子操作的唯一标识符。下面一层是原子操作状态指示器，A和C分别表示“已中止”和“已提交”。
</p>

<p>
在系统崩溃时，扁平事务需要回滚。为了做到这一点，需要引入一个系统事务。系统事务是一个永久事务，系统已启动，系统事务就处于活跃状态，而且永远不会提交。当系统崩溃重启后，系统事务中止，并引起扁平事务的ROLLBACK WORK信号，如下图所示::
</p>

<hr />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-left">B</td>
<td class="org-left">C</td>
</tr>
</tbody>
</table>
<hr />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">系统</td>
</tr>
</tbody>
</table>
<hr />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-left">B</td>
</tr>
</tbody>
</table>
<hr />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">触发器</td>
</tr>
</tbody>
</table>
<p>
v
</p>
<hr />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-left">B</td>
<td class="org-left">C</td>
</tr>
</tbody>
</table>
<hr />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">T</td>
</tr>
</tbody>
</table>
<hr />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-left">B</td>
</tr>
</tbody>
</table>
<hr />

<p>
基于上面的图形表示法，可以建立一套事务模型规则，每一条代表原子操作可能出现的状态事务。我们用下面的语法定义规则::
</p>

<p>
规则标识符:前置条件 -&gt; 规则修饰符列表,信号列表,状态   # 事件引发的操作
规则修饰符 ::= +(规则标识符|信号)               # 增加引用和信号
规则修饰符 ::= -(规则标识符|信号)               # 取消引用和信号
规则修饰符 ::= DELETE(原子操作标识符)           # 删除附属的规则和引用
</p>

<p>
这些规则的工作方法如下：当一个事件发生时，检查它所标识的规则。如果前置条件不满足，不产生任何动作。如果前置条件满足，执行规则右边的动作。扁平事务没有先决条件，也没有触发新事件。扁平事务有3个动词：BEGIN WORK、ROLLBACK WORK和COMMIT WORK，分别使用S(B,T)、S(A,T)和S(C,T)表示。A(T)和C(T)分布表示原子操作T的中止和提交状态。因此扁平事务的规则如下::
</p>

<p>
S(B,T):NULL -&gt; +(S(A,SYSTEM)|S(A,T)),,BEGIN WORK              # 建立对系统事务的结构依赖，然后执行事务。
S(A,T):NULL -&gt; (DELETE(S(B,T)),DELETE(S(C,T)),,ROLLBACK WORK  # 事务回滚，撤销BEGIN WORK和COMMIT WORK的引用和依赖。
S(C,T):NULL -&gt; (DELETE(S(B,T)),DELETE(S(A,T)),,COMMIT WORK    # 事务提交，撤销BEGIN WORK和ROLLBACK WORK的引用和依赖。
</p>

<p>
现在我们来考察稍微复杂一些的，有保存点事务的规则。保存点是事务处理中的一个中间状态。如果事务上下文是累积的（比如上面的银行计算利息的例子），使用保存点可以减少事务执行时间。保存点使用SAVE WORK函数建立。SAVE WORK函数让系统记录当前状态，并返回一个句柄给应用程序，用来标记保存点。这个句柄通常是一个数字，在事务内单调增加。在执行ROLLBACK时，可以返回到指定的保存点，而不是必须撤销整个事务。事务的BEGIN WORK函数隐含建立了一个保存点，句柄为1。有保存点的扁平事务由一些列原子操作组成，每个保存点对应一个构建块。系统事务和这些构建块根据保存点顺序，通过取消信号连接起来。同时，各个构建块的提交信号按照保存点的逆序关联起来。假设事务本身的标识符是S[1]，构建块S[n+1]是S[n]建立的保存点，R表示要回滚到的保存点句柄，那么有保存点的扁平事务规则如下::
</p>

<p>
S(B,S[1]):NULL -&gt; +(S(A,SYSTEM)|S(A,S[1])),,BEGIN WORK        # 建立将系统事务中止事件和该事务中止信号关联
S(A,R):(R&lt;S[1]) -&gt; ,,ROLLBACK WORK                            # 回滚到指定保存点
S(C,S[1]):NULL -&gt; ,,COMMIT WORK                               # 提交事务
S(S,S[1]):NULL -&gt; +(S(A,S[1])|S(A,S[2])), S(B,S[2]),          # 当保存点信号到达时，新建构建块并关联取消信号。新的构建块调用BEGIN WORK。
S(B,S[n]):NULL -&gt; ,,BEGIN WORK
S(A,R):(R&lt;S[n]) -&gt; ,S(A,S[n-1]),ROLLBACK WORK
S(C,S[n]):NULL -&gt; ,S(C,S[n-1]), COMMIT WORK
S(S,S[n]):NULL -&gt; +(S(A,S[n])|S(A,S[n+1])),S(B,S[n+1]),
</p>

<p>
可以看到，当系统崩溃时，中止信号操作链传递，各个保存点也撤销了。一个想法是建立持久的保存点，在系统恢复时同时对保存点进行恢复。这里的障碍在于常规的编程语言没有持久性。事务系统可以恢复保存点，但编程语言无法重建当时的状态。对于扁平事务，中止事务不会影响程序的状态，因此不存在这个问题。
</p>

<p>
保存点模式存在一个变种，编程语言和事务系统配合起来实现灵活的回滚。这种模式叫做链事务。链事务不使用保存点，而是让应用程序提交已经完成的工作。链事务把BEGIN WORK和COMMIT WORK合并成一个命令，叫做CHAIN WORK。BEGIN WORK建立一个空白上下文，而CHAIN WORK会继承前面的上下文。链事务的规则如下::
</p>

<p>
S(B,C[n]):NULL -&gt; +(S(A,SYSTEM)|S(A,C[n])),,BEGIN WORK
S(A,C[n]):NULL -&gt; ,,ROLLBACK WORK
S(C,S[n]):NULL -&gt; ,S(B,C[n+1]),COMMIT WORK
</p>

<p>
对比链事务模型和保存点事务模型可以发现（链中有一个事务或一个保存点）：
</p>

<p>
工作流结构.两种模式都运行在长期运行的应用程序中使用子结构。数据库下上下文均被保存，游标保持打开。
提交与保存点。链事务的每一步都是不可撤回的完成一个事务，回滚只限于当前活动事务，相当于恢复到上一个保存点，而不是任意保存点。
工作丢失。保存点支持更灵活的状态恢复。
重启处理。链事务重建了最近一次提交的状态，丢失的工作更少。
</p>

<p>
下面介绍嵌套事务。嵌套事务是保存点的一般化，它构成了一个层次结构框架。下面我们给出嵌套事务的一个定义：
</p>

<ol class="org-ol">
<li>嵌套事务是若干事务组成的一棵树，子树可以嵌套事务，也可以是扁平事务。</li>
<li>位于叶子节点的事务是扁平事务。</li>
<li>位于根节点的事务称为顶层事务，其他事务叫做子事务。事务的前驱叫做父事务，后继叫做子事务。</li>
<li>子事务可以提交或回滚。父事务提交后，子事务的提交才生效。任何子事务只有在顶层事务提交后才能最终提交。</li>
<li>树种任意一个事务的回滚会引起它的全部子事务回滚。因此子事务具有原子性、一致性、隔离性，但不具有持久性。</li>
</ol>

<p>
嵌套事务的规则可以归结为以下3点：
</p>

<p>
#. 提交规则。子事务的本地提交结果只有父事务可见。只有在顶层事务提交后，子事务才会最终提交。子事务的结果才会变成外部可见。
#. 回滚规则。如果一个子事务发生回滚。它的后继事务也要进程回滚，无论是否进程过本地提交。
#. 可见规则。父事务对象对子事务是可见的，子事务本地提交后，提交结果对父进程是可见的。子事务的提交结果在兄弟事务之间是不可见的。
</p>

<p>
我们用T[k,n]表示事务T[k]的一个子事务，嵌套事务的规则如下::
</p>

<p>
S(B,T[k,n]):NULL -&gt; +(S(A,T[k])|S(A,T[k,n])),,BEGIN WORK
S(A,T[k,n]):NULL -&gt; ,,ROLLBACK WORK
S(C,T[k,n]):C(T[k]) -&gt; ,,COMMIT WORK
</p>

<p>
对于不支持嵌套事务的系统，可以采用保存点来模拟嵌套事务。在每个子事务开始的时候建立一个保存点。子事务回滚时，回滚到对应的保存点。这种方法的缺点是不支持子事务并行。在嵌套事务中，当子事务本地提交后，子事务使用的锁由父事务反向继承（counter-inherited）。也可以让父事务拥有锁，然后传递给子事务。在使用保存点模拟时，由于无法判断哪些锁需要继承，必须在扁平事务中获取全部的锁。
</p>

<p>
分布式事务用于处理数据位于不同位置的情况，事务通过网络访问所需的数据。假设事务T在节点A上运行。T需要将表X和表Y连接。其中X是本地可达的，Y分布在节点B和节点C上，是网络可达的。这导致T的子事务T1和T2被分布在节点B和C上。这种结构叫做分布式事务的调用结构（invocation structure），这种结构让分布式事务看上去很像嵌套事务。不过二者有一个很重要的区别，
嵌套事务是由应用所要求的控制范围决定，子事务运行在不同的控制层次上。分布式事务的结构是根据网络中的数据分布决定的，子事务运行在相同的控制层次上。
</p>

<p>
多级别事务是嵌套事务的一般化或自由化版本。多级别事务中，子事务的本地提交对后续执行的其他子事务可见。这样可以减少子事务封锁对象的时间，提高系统整体性能。当父事务决定回滚时，调用子事务对应的补偿事务，从语义上撤销子事务的操作。假设N是一个子事务，CN是N的补偿事务，多级别事务的规则如下::
</p>

<p>
S(B,N):NULL -&gt; ,,BEGIN WORK
S(A,N):NULL -&gt; ,,ROLLBACK WORK
S(C,N):NULL -&gt; +(S(A,T)|S(B,CN)),,COMMIT WORK           # 将补偿事务的开始执行和父事务的中止事件关联。
S(B,CN):NULL -&gt; +(S(C,RESTART)|S(B,CN')),,BEGIN WORK    # 建立指向CN自己的链事务，避免系统崩溃导致补偿事务无法完成。
S(A,CN):NULL -&gt; ,S(B,CN'),ROLLBACK WORK
S(C,CN):NULL -&gt; DELETE(CN'),,COMMIT WORK
</p>

<p>
这里的CN'和CN具有同样的代码，但名称不同。将CN'的开始动作和CN中止信号关联的目的在于保证补偿事务一定会完成。在多级别事务中，由于子事务的本地提交结果对其他子事务可见，因此必须建立一个层次化的控制结构：
</p>

<p>
抽象层次。操作分为不同的层次，系统由这些层次构成。
分层抽象。层次n上的对象仅依赖于层次n-1上的操作。
法则。层次n只能访问层次n-1上的对象。
</p>

<p>
多级别事务的“无政府”版本叫做开放嵌套事务。在开放嵌套事务中，无论父事务最终的状态如何，子事务都可以独立的提交或回滚。开放嵌套事务的行为是无保护的。
</p>

<p>
现在来讨论长事务的概念。考虑前面提到的银行利息计算的例子。如果系统出现故障，重头开始计算的代价是不可接受的。当然我们可以把100万条记录的更新分拆为100万个（链）事务，这样在系统恢复时可以最大化的保留计算结果。但是从整体上看，也失去了原子性。在这些事务运行的时候，一部分记录已经更新，而其他记录还是旧的。在长事务中，为了保存中间工作结果，需要引入事务上下文（context）概念。考虑下面一个简单的事务程序::
</p>

<p>
SimpleProgram()
{
     BEGIN WORK;
     read(input<sub>message</sub>);
     <i>* 在输入消息上完成计算 *</i>
     send(output<sub>message</sub>);
     COMMIT WORK;
}
</p>

<p>
这个程序可以看做函数::
</p>

<p>
output<sub>message</sub>=f(input<sub>message</sub>)
</p>

<p>
的一个实现。接着我们考虑下面的SQL语句::
</p>

<p>
exec sql DECLARE CURSOR c AS
         SELECT a,b,c
         FROM rel<sub>a</sub>
         WHERE d=10
         ORDER BY a ASCENDING;
exec sql OPEN CURSOR c;
do
{
    exec sql FETCH NEXT c INTO :a, :b, :c;
    <i>* 完成计算 *</i>
}
while (SQLCODE == 0);
exec sql CLOSE CURSOR c;
</p>

<p>
这个程序声明一个游标，并循环处理满足条件的记录。在通过游标获取下一个记录时，关于下一个记录时什么，应用并没有告诉SQL服务器。这说明一些程序输出的结果不仅依赖于输入，也依赖于一个内部状态，这个状态叫做上下文。在使用上下文时，程序变成::
</p>

<p>
f(input<sub>message</sub>, context) -&gt; { output<sub>message</sub>, context2 }
</p>

<p>
如果在一个函数中，context和context2都是空集，这个函数叫做上下文无关。上下文的拥有者可以是：
</p>

<p>
事务。比如例子中的游标。
程序。程序中最后被提交的事务的信息是程序的上下文。
终端。允许使用该终端的上下文列表。
用户。用户认证状态、用户工作的上一个序号等。
</p>

<p>
上下文的概念是非常普遍的。打开一个文件就建立了应用程序和文件系统双方的上下文，这个上下文包含了用户的授权信息、文件尾指针和其他信息。
</p>

<p>
下面我们来看看上下文的用途。考虑前面的银行利息计算例子::
</p>

<p>
ComputeInterest()
{
    read(interest<sub>rate</sub>);
    for (account<sub>no</sub> = 1; account<sub>no</sub> &lt;= 1000000; account<sub>no</sub>++)
    {
        SingleAccount(interest<sub>rate</sub>, account<sub>no</sub>);
    }
    reply("done");
}
</p>

<p>
SingleAccount(interest<sub>rate</sub>, account<sub>no</sub>)
{
    BEGIN WORK;
    <i>* do account update *</i>
    COMMIT WORK;
    return("OK");
}
</p>

<p>
更新单一账户的事务仍然是上下文无关的，下一个需要被处理的账户的序号通过消息输入。
</p>

<p>
对于长事务，还有一种常用的处理方法，就是分拆为小批量（mini-batch）处理::
</p>

<p>
ComputeInterest(interest<sub>rate</sub>)
{
    long account<sub>no</sub>, last<sub>account</sub><sub>done</sub>, batch<sub>date</sub>;
    double account<sub>total</sub>, interest<sub>rate</sub>;
    int logsize;
</p>

<p>
#define stepsize 1000;
#include &lt;string.h&gt;;
#define max<sub>account</sub><sub>no</sub> 999999;
</p>

<p>
logsize = 0;
exec sql SELECT COUNT(*) INTO :logsize FROM batchcontext;
// 建立或重建上下文
if (SQLCODE != 0 || logsize == 0)
{
    exec sql BEGIN WORK;
    exec sql DROP TABLE batchcontext;
    exec sql CREATE TABLE batchcontext (last<sub>account</sub><sub>done</sub> INTEGER);
    last<sub>account</sub><sub>done</sub> = 0;
    exec sql INSERT INTO batchcontext VALUES (:last<sub>account</sub><sub>done</sub>);
    exec sql COMMIT WORK;
}
else
{
    exec sql SELECT last<sub>account</sub><sub>done</sub>
             INTO :last<sub>account</sub><sub>done</sub>
             FROM batchcontext;
}
</p>

<p>
// 工作
while (last<sub>account</sub><sub>done</sub> &lt; max<sub>account</sub><sub>no</sub>)
{
    exec sql BEGIN WORK;
    exec sql UPDATE accounts
             SET account<sub>total</sub> = account<sub>total</sub>*(1 + :interest<sub>rate</sub>)
             WHERE account<sub>no</sub> BETWEEN :last<sub>account</sub><sub>done</sub> + 1 AND :last<sub>account</sub><sub>done</sub> + stepsize;
    exec sql UPDATE batchcontext
             SET last<sub>account</sub><sub>done</sub>=:last<sub>account</sub><sub>done</sub> + stepsize;
    exec sql COMMIT WORK;
    last<sub>account</sub><sub>done</sub> = last<sub>account</sub><sub>done</sub> + stepsize;
}
</p>

<p>
    // 工作完成，销毁上下文
    exec sql BEGIN WORK;
    exec sql DROP TABLE batchcontext;
    exec sql COMMIT WORK;
    return;
}
</p>

<p>
到现在为止，长事务的需求可以总结如下：
</p>

<p>
#. 最小化工作丢失。在系统崩溃时控制丢失工作的数量。
#. 可恢复计算。可以暂停计算，而不因为程序或系统崩溃提交或回滚。
#. 显式控制流。系统必须可以控制长事务的事务序列。在任何失败的情况下，要么沿着特定路线继续执行，要么将已完成的部分从系统中移开。
</p>

<p>
为了向系统提供类似于事务序列的小批量运行的支持，有人提出了saga概念，对链事务进程扩充：
</p>

<p>
#. 以链事务作为控制单元。
#. 使用补偿事务保证整个事务链的原子性。
</p>

<p>
saga是扁平事务s[1],s[2],&#x2026;,s[n]的集合。每个事务s[i]都有一个补偿事务cs[i]。这些事务按顺序执行。如果在执行某个s[j]时系统出现故障，系统将依次调用cs[j-1],cs[j-2],&#x2026;,cs[1]以撤销已提交事务的影响。
</p>

<p>
习题
</p>
<hr />
<ol class="org-ol">
<li>读写磁盘操作可能会在错误的地址上执行。处理这种情况？
在写入时，将块的地址作为数据的一部分写入块。每个块是自认证（self-identifying）的。在读取时，如果发现数据中包含的地址信息和预期的地址不一致，可以判定块失效，并修复这个块。如果读和写都可能发生地址错误，这时不能使用先写后读（read-after-write）的方式。采用这个方式可能会出现先写是成功的，而后读取读错地址的情况。这种情况无法处理。</li>

<li><p>
一个磁盘有N个块，编号从1到N。每个块有数据部分和前向、后向两个指针。指针可以是NULL。块1是一个特殊块，它和它前向指针的后继块构成一个双向链表，记录了未分配块。它和它后向指针的后继块也构成一个双向链表，记录了已分配块。除了这个特殊块之外，其他的块要么在已分配链表中，要么在未分配链表中。假设一个时刻只有一个程序运行，如何让分配块的操作保持原子性？
假设先写后读可以容错。块1的前向、后向指针分别记为A和F。新分配的块就是F指向的块，记为b[n]。b[n]的后继块记为b[f]，A的前驱块记为b[a]。分配时，块1、b[n]、b[a]、b[f]都需要修改。在块1中保存两个辅助指针A*和F*。分配操作如下
</p>
<ol class="org-ol">
<li>令A*=b[n]，F*=b[f]，写块1。</li>
<li>令b[a]的后向指针指向b[n]，写b[a]。</li>
<li>令b[f]的后向指针指向1，写b[f]。</li>
<li>令b[n]的前向指针指向b[a]，令b[n]的后向指针指向1，写b[n]。</li>
<li>令A*=0，F*=0，写块1。</li>
</ol>
<p>
在系统恢复时，检查A*和F*的值。如果A*和F*不为0，重新执行分配操作。
</p></li>
<li><p>
一个电子转账程序将X元从账户A转到账户B。如果采用两个事务完成，第一个事务更新账户A，第二个更新账户B。这么做怎么样？
这么做原子性很难得到保证。第一个事务提交后，第二个事务无法保证必须提交。解决方法基于持久上下文。对每个没有完成提交的事务记录一个4元组::
</p>

<p>
Money<sub>In</sub><sub>Transit</sub>(Deb<sub>Account</sub>, Cred<sub>Account</sub>, Amount, Time)
</p>

<p>
第一个事务修改贷出账户后，向Money<sub>In</sub><sub>Transit插入一条记录</sub>。第二个事务完成借入后，将记录删除。这样在第一个事务提交后，即使系统崩溃，第二个事务也可以提交。但是这个方法存在一个隐患，就是在第二个事务执行时，借入账户可能不再存在。因此必须有一个补偿事务，将金额返还给贷出账户。
</p></li>

<li>考虑一个ATM参与的借贷事务。ATM作为终端，客户在ATM上的输入作为发送给借贷事务的消息。如果来自程序的消息使ATM崩溃，如何保证事务的ACID特性？考虑以下几种情况：
 a) 系统运行事务程序时发生故障。
 b) ATM出现故障。
 c) 系统和ATM的通信出现故障。
解决方法是（分布的）两阶段提交。ATM参与到协议中。ATM需要一个永久存储以便记录阶段1的决定和阶段2的结果。在a)中，如果在阶段1之前系统崩溃，ATM在等待一段时间后超时，显示一个错误信息，并将卡片吐出。如果在阶段1之后系统崩溃，ATM可以完成事务的部分工作，并在返回后向系统报告相关结果。在b)中，如果在阶段1之前ATM故障，系统将终止事务。如果在阶段1之后ATM故障，这会影响到取款过程。这里需要ATM的取款操作是可测试的。</li>

<li><p>
设计一个规则，当事务中止时，错误消息至少被递送一次。如果事务提交，没有错误消息。
::
</p>

<p>
S(B,T):NULL -&gt; +(S(A,SYSTEM)|S(A,T)),,BEGIN WORK
S(A,T):NULL -&gt; DELETE(S(C,T)),S(B,MESSAGE),ROLLBACK WORK
S(C,T):NULL -&gt; (DELETE(S(A,T)), DELETE(S(B, MESSAGE))),,COMMIT WORK
S(B,MESSAGE):NULL -&gt; +(S(C,RESTART)|S(B,MESSAGE)),,BEGIN WORK
S(A,MESSAGE):NULL -&gt; ,S(B,MESSAGE),ROLLBACK WORK
S(C,MESSAGE):NULL -&gt; (DELETE(S(A,MESSAGE), -(S(C,RESTART)|S(B,MESSAGE))),,COMMIT WORK
</p></li>

<li><p>
为分布事务制定一个规则。
下面的规则适用于只有一个子事务的特殊情况::
</p>

<p>
S(B,T):NULL -&gt; +(S(A,SYSTEM)|S(A,T)),,BEGIN WORK
S(A,T):NULL -&gt; ,,ROLLBACK WORK
S(C,T):NULL -&gt; ,,COMMIT WORK
S(B,T1):NULL -&gt; (+(S(A,T)|S(A,T1)),+(S(C,T)|S(C,T1))),,BEGIN WORK
S(A,T1):NULL -&gt; ,S(A,T),ROLLBACK WORK
S(C,T1):NULL -&gt; ,S(C,T),COMMIT WORK
</p></li>
</ol>


<p>
第五章 事务处理监控器：概述
<code>======</code>
</p>

<p>
TP监控器的主要功能就是集成其他系统组件和管理资源，使得这些软件已面向事务处理（transaction-oriented processing）方式协作。为了介绍面向事务处理方式，我们首先了解一下计算机支持的几种处理方式：
</p>

<p>
批处理。批处理具有以下特点：
</p>
<ol class="org-ol">
<li>大作业单元。作业以大批量的方式按照预定的时间运行。</li>
<li>粗粒度的资源分配方式。资源分配粒度较大，程序可以有效操作私有资源。</li>
<li>顺序访问模式。顺序的执行一系列操作，比如按客户编号顺序执行。</li>
<li>应用程序处理错误恢复。应用程序提供错误恢复，并且通常需要手工处理。</li>
<li>并发作业数量较少。由于作业单元大，批处理需要消耗大量系统资源，因此往往并发作业数较少，通常在数十个作业。批处理系统的主要功能指标是使作业完成时间最少，保证吞吐量。</li>
<li>隔离执行。每个批处理作业在自己的进程中执行，独占文件流和其他资源。</li>
</ol>

<p>
分时处理。分时处理是面向终端版本的批处理。每个终端用户会分配到一个终端会话。分时处理具有以下特点：
</p>
<ol class="org-ol">
<li>每个终端拥有一个进程。和批处理类似，终端会话和一个私有进程关联起来，终端用户拥有内存和其他资源，可以调用操作系统服务，或和其他进程通信。</li>
<li>粗粒度的资源分配方式。终端会话的持续时间较长，资源以较粗的粒度分配给会话，应用程序在私有数据上运行。</li>
<li>随机请求。作业由用户控制，实际的资源分配不可预测。</li>
<li>顺序访问模式。在终端进程中，终端会话的处理以顺序方式进行。</li>
<li>应用程序处理错误恢复。系统崩溃后用户需要重建会话。</li>
<li>数以百计的并发用户。</li>
</ol>

<p>
分时系统的主要特点通过低带宽终端（哑终端）以交互的方式处理计算。
</p>

<p>
实时处理。实时处理是按照类似进程控制的计算模式。系统除了处理用户请求之外，也处理来自传感器和控制器的请求。实时处理具有以下特点：
</p>
<ol class="org-ol">
<li>事件驱动操作。系统需要处理用户和传感器事件，工作负载模式无法预计。</li>
<li>重复性的工作负载。事件不会触发仲裁程序。用户也不会编译和运行新的程序。事件会激活一组预先已经定义好的程序。系统的随机性表现在程序被激活的顺序和频率。当程序激活时，需要比之前多100倍的资源。</li>
<li>设备动态绑定到任务上。传感器和控制器不是绑定在进程上，而是绑定到一组特定的功能上。这个功能将传感器信号转换成一些列控制器信号。每次请求-应答的周期非常短。</li>
<li>隔离执行。大部分功能在私有数据上操作。少部分功能使用全局共享数据。</li>
<li>高可靠性。系统必须保证高度的可靠性，因为控制器在执行操作。但系统往往不保证一致性。如果对一致性有疑问，系统会重新读取传感器数据。传感器是数据来源。</li>
<li>高效性。系统的首要性能是在系统负载高峰要保证系统的最大响应时间，至少对最高优先级的功能要保证最大响应时间。否则可能产生灾难性后果。</li>
</ol>

<p>
客户-服务器处理。客户-服务器处理是分时处理模式的现代版本。区别之处在于客户向指定的服务器发送请求来执行相应服务。执行请求的服务可以运行在同一个机器上，也可以运行在分布式环境中的不同机器上。每台机器事先部署特定的服务程序，永久性数据由数据库服务器封装保存，并被不同用户共享。
</p>

<p>
面向事务处理。面向事务处理具有一下特性：
</p>
<ol class="org-ol">
<li>共享性。面向事务处理在多用户共享的数据库上执行。</li>
<li>可变的请求。用户请求是随机的。用户个人的请求是不可预计的。</li>
<li>重复性的工作负载。用户不会运行仲裁程序，而是请求系统执行其预定的功能。每个功能是一个事务的示例，调用相应的事务程序完成请求。</li>
<li>简化大部分功能。大部分的功能是中等大小的，拥有1e5到1e7条指令，10次左右的磁盘I/O操作。</li>
<li>一些批量事务。一些作业类似批处理作业，但是增加了ACID特性，可恢复输出，并和其他事务共享数据。</li>
<li>多终端。在大型OLTP系统中，终端数量从1e3到1e5不等。</li>
<li>智能客户机。OLTP系统的终端逐渐替换为智能客户机（工作站）。智能客户机用于自己的数据，可以执行处理。</li>
<li>高可用性。由于存在大量用户，系统必须具有高度的可靠性和可用性。</li>
<li>系统执行恢复。由于数据存在共享，系统必须维护数据的一致性。系统崩溃后，必须通知所有用户。具体的恢复策略由事务的ACID特性决定。</li>
<li>自动负载均衡。系统必须在保证大多数请求的响应时间的基础上提高吞吐量。</li>
</ol>


<p>
在事务处理系统中，有3种因素会影响事务调度和执行方式：从调度方式看，事务分为直接事务和队列事务；从输入/输出看，分为简单事务和复杂事务；从资源管理器分配来看，分为本地事务和分布式事务。这些因素相互组合，形成了8种不同类型的事务：
</p>

<hr />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">事务</td>
</tr>
</tbody>
</table>
<hr />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">直接</td>
<td class="org-left">队列</td>
</tr>
</tbody>
</table>
<hr />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">单消息</td>
<td class="org-left">会话</td>
<td class="org-left">短</td>
<td class="org-left">长</td>
</tr>
</tbody>
</table>
<hr />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">本地</td>
<td class="org-left">分布式</td>
<td class="org-left">本地</td>
<td class="org-left">分布式</td>
<td class="org-left">本地</td>
<td class="org-left">分布式</td>
<td class="org-left">本地</td>
<td class="org-left">分布式</td>
</tr>
</tbody>
</table>
<hr />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">直接OLTP事务</td>
<td class="org-left">复杂联机事务</td>
<td class="org-left">队列OLTP事务</td>
<td class="org-left">长的批处理事务</td>
</tr>
</tbody>
</table>
<hr />

<p>
直接事务和队列事务。在直接事务中，终端和服务器程序以直接交互的方式处理请求。而在队列事务中，请求放置在服务器的队列中，按照一定规则调度执行。这个队列是在事务管理系统内部，有TP监控器管理的，对应用程序是透明的。
</p>

<p>
简单事务和复杂事务。简单事务较短，涉及的对象也较少。复杂事务具有较复杂的内部结构（控制流），并涉及大量对象。复杂事务在系统中停留的时间较长，需要较多资源。
</p>

<p>
本地事务和分布式事务。如果事务可以在发出请求的网络节点上执行，就是本地事务。如果需要调用其他节点上的服务器，就是分布式事务。
</p>

<p>
介绍了事务分类之后，我们开始介绍事务处理服务。通常人们提到事务时首先想到的是数据库事务。但是如果需要使用的资源超过数据库的控制范围，修需要事务处理服务来保证ACID特性。
</p>

<p>
管理异构资源。应用需要访问异构数据库或异构子系统。每个子系统自身提供的ACID保证无法支持全局的ACID特性。事务服务必须将这些对象上的操作包含在一个事务中。这样的组件叫做资源管理器（RM）。资源管理器通过TP监控器将资源集成到全局事务中，以提供对资源的保护。
</p>

<p>
通信控制。如果应用需要和远程进程进行通信，通信的状态可以通过事务保护。支持这种方式的通信机制叫做事务型远程过程调用（TRPC）。从处理消息和维护会话的角度看，通信管理器就是一个资源管理器。
</p>

<p>
终端管理。用户可能通过不同的终端来访问程序功能。程序功能通过消息和终端通信。如果用户和程序都要求ACID特性，消息的发送也要作为事务的一部分，由TP监控器控制。
</p>

<p>
表示服务管理。根据终端管理，如果用户使用了一个复杂的表示服务（如X-Windows），在工作站崩溃后，系统需要重建窗口环境。
</p>

<p>
上下文管理。当用户请求的事务执行后，下一个功能往往需要使用前面事务的上下文（比如登录事务执行后用户请求查看邮件）。上下文的保护和恢复由创建和使用这个上下文的事务复制。一些上下文和用户或终端关联。这些上下文由TP监控器维护。
</p>

<p>
开始/重启动。TP监控器在执行失败后重启动作，将子系统恢复到一致性状态。
</p>


<p>
下面考察事务处理系统的进程结构。考虑下面的场景：一个终端（客户机）想在服务器上执行一些功能，这些功能需要存取或操作数据库中的一些数据。必然存在某个东西将终端、应用程序和数据库组织起来，比如有一个进程来接收用户的输入，分析请求，保证请得到执行。请求表达了需要得的服务。服务通常以事务程序名（Transaction Program Name, TPN）或事务代码（Transaction Code, TAC）标识。一个TPN标识一段代码，实现了某个服务，比如前的DebitCredit程序。程序通常会实现多个服务。对每个应用程序，系统提供一个服务器类（server class）。服务器类是一组进程，执行服务对应的代码。当收到服务请求时，系统将请求发送给服务器类中的一个进程处理。这个操作叫做服务请求（service invocation）。服务器类中的进程有时也叫做服务器（进程）。那么请求和进程的映射结构是什么样的呢？
</p>

<p>
每个终端分配一个进程。分时系统为每个终端分配一个服务器进程，进程装载所有的应用程序。这种方式在面向事务系统中性能较差，原因在于：
</p>
<ol class="org-ol">
<li>进程多。大型事务系统通常有1e4到1e5个终端，这意味着系统中进程数量可能超过操作系统支持的上限。</li>
<li>控制块多。每个终端都可能调用任意一个应用程序，所有进程必须打开可能用到的数据库。这会产生大量闲置的控制块。如果一个系统有T个终端，每个终端访问F个文件，每个文件有P个分区，那么系统需要T*F*P个控制块。考虑T=20000，F=1000，P=50的大型系统，将产生1e9个控制块。</li>
<li>进程切换频繁。由于进程数量多，每个进程很少被使用，同时潜在占用了大量控制块。这会导致两个后果：第一，控制块在下次被调用是可能不在内存中；第二，进程切换频繁。</li>
<li>不灵活的负载均衡。难以为不同的应用分配不同的优先级。进程在调用不同应用不得不进行优先级切换优。</li>
<li>每个进程的能力。在面向事务的场景下，进程的能力比终端要强得多。对于一个终端，分配如此多的资源实在浪费。</li>
</ol>

<p>
只有一个终端进程。系统中只有一个终端进程，所有终端都和这个进程交互。这个进程可以是TP监控器，或者表示服务（如X-Windows），它接收请求并发送给对应的程序。这个方案的缺点在于，应用间没有错误隔离，并且TP监控器成为瓶颈。
</p>

<p>
多服务器单调度程序。在这个方案中，所有的终端和调度程序交互，调度程序将请求转发给服务器类。每个进程只需要访问自己需要的那部分数据。应用之间可以隔离。缺点是在高负载下，调度程序成为瓶颈。
</p>

<p>
多服务器多调度程序。这个方案是在多服务器单调度程序的方案上，将调度程序做成服务器类，避免单一的调度程序成为瓶颈。
</p>

<p>
根据前面的讨论可以知道TP监控器，至少要具有以下职责：
调度。将终端发送的请求映射到服务器进程。
服务器类管理。启动服务器类进程，进程负载均衡。
认证和授权。TP监控器需要对每个请求进程授权。
资源管理。TP监控器负责管理终端、数据库、应用程序、用户和事务处理系统中的其他组件。组件的信息保存在系统中心库。应用要访问中心库，必须通过TP监控器的管理接口。
系统操作。TP监控器必须提供足够的信息让操作者来调整系统。比如在普通操作中产生问题（终端断开、服务器类问题等）时通知用户。
恢复。系统崩溃后，TP监控器负责重建事务环境。TP监控器启动进程和服务器类，然后将控制权交给事务管理器。
</p>


<p>
下面介绍一下TP监控器的基本结构。
</p>

<p>
表示服务。定义了应用程序和其要交互的设备间的接口。它减轻了应用程序的工作量。
队列管理。队列管理是TP监控器的一个组件，支持队列事务处理。队列的功能是接收请求并传递给相应的服务器，接收处理结果并返回给客户。通常队列管理器作为TP监控器所拥有的一个资源管理器实现。
服务器类管理。确保对每个应用都有一个服务器类被建立并激活。进程可以在系统启动时激活，也可以在需要时激活。服务器类管理包括创建进程和队列、将代码装载到适当的地址空间、设置进程权限、处理请求域切换、决定服务器类中进程的优先级等。服务器类管理和负载平衡组件一起配合来适应的不同的负载模式。
请求调度。请求调度是TP监控器执行最频繁的服务。它首先找到可以处理请求的服务器。如果服务器是远程的，通过RPC发送过去。如果服务器是本地的，检查是否有空闲的服务器。如果没有，调用负载均衡器来获得服务器。负载均衡器根据负载均衡策略决定新建服务器还是等待某个服务器变为空闲状态。接着，调度器将请求发给服务器。
授权请求。TP监控器需要根据应用的要求检查到来的请求是否有效。策略包括静态授权和根据具体值而进行的动态授权。
上下文管理。上下文管理可以用于所有的事务程序。它包含两个功能，第一个是保存处理上下文。这种上下文可以跨越事务边界，在后续的事务中访问。这种上下文数据库具有ACID特性。实际上，TP监控器可以使用SQL数据库系统来实现它。第二个功能是保存正在运行事务的上下文。一个事务可能会调用多个资源管理器，并将中间处理结果在这些资源管理器之间传递。为了避免程序结构过于复杂，以及消息数量过多，通常会将这些中间结果保存在上下文中，让资源管理器来存取。这样的上下文可以看成是一个不具有持久化的保存点。
</p>

<p>
TP监控器对数据字典（中心库）的依赖较强。为了简化，可以假设只有一个全局中心库，通过分布式SQL数据库实现。所有的元数据都保存在中心库中。对于TP监控器，至少要有：
</p>
<ol class="org-ol">
<li>分布式事务涉及的节点名称和地址等。</li>
<li>事务服务的本地组件，如日志管理程序、事务管理器和通信管理器。</li>
<li>TP监控器必须了解的硬件部分，如终端、控制器和通信管理器使用的物理连接。</li>
<li>本地节点上安装的事务程序和资源管理器。</li>
<li>应用程序和资源管理器的访问控制列表。</li>
<li>和应用程序有关的屏幕格式定义，如菜单、图形、图标等。</li>
<li>服务器类配置数据（有多少个进程，多少个线程，优先级如何）</li>
<li>系统、授权码、安全配置文件和其他用户相关数据。</li>
<li>操作者界面配置。</li>
<li>重启配置和过程（如资源管理器调用顺序）。</li>
</ol>

<p>
TP监控器中一个重要的概念是资源管理器。资源管理器是TP监控器的一个子系统，它提供了对某些状态的有保护操作。资源管理器可以分为3类。第一类包括系统组件，比如目录和表示服务。第二类是实现事务的基本组件，如事务管理器、日志管理器和通信管理器。第三类是被应用调用的，支持事务的子系统，比如SQL数据库、文件系统、排队系统、邮件系统等。要成为资源管理器，组件必须可以参与事务恢复处理。尤其是在对共享数据进行操作时，必须能支持某种同步机制，并在需要时提交或回滚它使用的那部分。TP监控器对本地资源管理器具有以下责任：
系统启动和初始化。资源管理器必须被首先启动。资源管理器和事务管理器负责处理崩溃后的恢复工作。TP监控器必须唤起它们。
新资源管理器的定义。TP监控器必须将新资源管理器的信息写入中心库，更高配置数据。
改变进程配置。如果负载均衡器决定扩充服务器类，TP监控器需要创建新进程，载入代码，或者将进程附加在正确的地址空间。
处理事务型远程过程调用（TRPC）。这是TP监控器的基本任务。TP系统的组件通过服务请求交互。BEGIN WORK、COMMIT WORK和其他的事务调用都是服务请求——对事务管理器的调用。
</p>

<p>
接下来介绍事务型远程调用。每个资源管理器有一个全局唯一的名字，叫做RMNAME。同时，当资源管理器被安装到节点上时，TP监控器会为它分配一个标识符，叫做RMID。由于远程调用是透明的，从应用的角度看，应该和本地调用一样。因此请求不会直接发送给资源管理器，而是发送给一个叫stub的组件。stub根据服务器的位置，决定转发给本地服务器或远程服务器。stub将请求中的RMNAME、NODEI和RMID绑定，将信息保存在中心库上。然后从中心库查找被调用的接口原型，将参数转换为资源管理器要求的格式，并打包成消息。如果服务器在本地，stub将消息发送给进程的输入队列。如果是远程服务器，stub发送消息到节点的stub上执行。这时，处理资源管理器请求的进程被挂起，等待服务器的响应消息。收到消息后，stub将消息解析成客户要求的格式，返回给应用程序。
</p>


<p>
下面介绍一下事务编程风格。TP监控器负责驱动。当TP监控器调度一个请求时，会将请求传递给服务器。从服务器的角度来看，像是一个子程序调用。下面是一个最简单的资源管理器示例。在这个资源管理器中，不需要事务环境::
</p>

<p>
Boolean IgnorantServer(rmParams *InParams, rmParams *OutResults)
{
        work on input parameters;
        CompCode = rmCall("HelpMe", &#x2026;);
        prepare output parameters;
        return TRUE;
}  
</p>

<p>
虽然这个程序不包含事务相关的代码，但如果在事务内部调用，它自然成为ACID的一部分。如果要处理和事务相关的操作，需要将TRID传递给资源管理器。看下面的例子::
</p>

<p>
typedef struct 
{
        Ulong length;
        char data[length];
} context, *contextp;
</p>

<p>
TRID BeginWork(attributes, context);
Boolean CommitWork(Boolean lazy, context);
void Abort<sub>Work</sub>();
</p>

<p>
Boolean SimpleServer(rmParams *InParams, rmParams *OutResults)
{
        TRID NewTRID;
        RETCODE CompCode;
        NewTRID = BeginWork(&#x2026;);
        do work;
        CompCode = rmCall("HelpMe", &#x2026;);
        if (CompCode == BAD)
        {
                Abort<sub>Work</sub>();
                return FALSE;
        }
        do more work;
        if (result<sub>ok</sub>)
        {
                prepare output parameters;
                CommitWork(&#x2026;);
                return TRUE;
        }
        else
        {
                Abort<sub>Work</sub>();
                return FALSE;
        }
}
</p>

<p>
程序SimpleServer通过BeginWork参与到事务中。但是这样做有一个缺点，SimpleServer无法参与到一个已经启动事务中，而是必须启动一个新事务。要解决这个问题，可以增加一个例程返回程序参与的事务::
</p>

<p>
TRID My<sub>TRID</sub>();
if (My<sub>TRID</sub>() == NULL<sub>TRID</sub>)
{
        BeginWork(&#x2026;);
}
</p>

<p>
一些资源管理器可以利用保存点和上下文做到逐步恢复，这一类叫做谨慎资源管理器（cautious resource manager），下面是一个例子::
</p>

<p>
savepoint Save<sub>Work</sub>(Boolean persistent, context);
savepoint RollbackWork(savepoint);
context Read<sub>Context</sub>(savepoint);
TRID Chain<sub>Work</sub>(Boolean persistent, context);
</p>

<p>
Boolean CautiousServer(rmParams *InParams, rmParams *OutResults)
{
        TRID NewTRID;
        savepoint last<sub>ok</sub><sub>state</sub>;
        context trusted<sub>data</sub>;
        int steps<sub>p</sub><sub>savepoint</sub>;
        RETCODE CompCode;
</p>

<p>
initialize trusted<sub>data</sub>;
NewTRID = BeginWork(&#x2026;, trusted<sub>data</sub>, FALSE);
last<sub>ok</sub><sub>state</sub> = 1;
while (more<sub>work</sub>)
{
        for (i = 1; i &lt;= steps<sub>p</sub><sub>save</sub><sub>point</sub>; i++)
        {
                do work;
                CompCode = rmCall("HelpMe", &#x2026;);
                do more work;
                if (error occurs)
                {
                        last<sub>ok</sub><sub>state</sub> = RollbackWork(last<sub>ok</sub><sub>state</sub>);
                        trusted<sub>data</sub> = Read<sub>Context</sub>(last<sub>ok</sub><sub>state</sub>);
                        reset local variables from what has been stored in trusted<sub>data</sub>;
                        i = 0;
                }
        }
        save all relevant local variables in trusted<sub>data</sub>;
        last<sub>ok</sub><sub>state</sub> = Save<sub>Work</sub>(FALSE, trusted<sub>data</sub>);
}
</p>

<p>
        if (result<sub>ok</sub>)
        {
                prepare output parameters;
                CommitWork();
                return TRUE;
        }
        else
        {
                Abort<sub>Work</sub>();
                return FALSE;
        }
}
</p>


<p>
如果一个资源管理器请求Save<sub>Work或RollbackWork</sub>，所有参与该事物的其他资源管理器，如果有合适的入口（enterance），都将得到通知。假设CautiousServer根据RollbackWork请求执行部分回滚操作::
</p>

<p>
Boolean rm<sub>Rollback</sub><sub>Savepoint</sub>(savepoint BackTo)
{
    trusted<sub>data</sub> = Read<sub>Context</sub>(BackTo);
    reset local variables from what has been stored in trusted<sub>data</sub>;
    return TRUE;
}
</p>

<p>
如果此时TRPC HelpMe返回“正常”，这会引入副作用。
</p>

<p>
复杂的资源管理器（SRM）可能同时为多个事务服务。如果事务T1由于某种原因挂起，SRM开始执行事务T2，TP监控器必须要了解到这个情况::
</p>

<p>
TRID Leave<sub>transaction</sub>(void);
Boolean Resume<sub>transaction</sub>(TRID desired);
</p>

<p>
Boolean Bartlett(rmParams *InParams, rmParams *OutParams)
{
    TRID ClientTRID;
    TRID MyownTRID;
    &#x2026;
    ClientTRID = Leave<sub>transaction</sub>();
    MyownTRID = BeginWork();
    &#x2026;
</p>

<p>
do database lookup;
prepare reference list;
write biling record to database;
CommitWork(FALSE, NULL);
Resume<sub>Transaction</sub>(ClientTRID);
</p>

<p>
    return;
}
</p>


<p>
第六章 事务处理监控器
<code>======</code>
</p>

<p>
从这一章开始讨论TP监控器的实现：如何在进程、地址空间、消息和会话的基础上，为应用构建一个面向事务的执行环境。
</p>

<p>
首先介绍事务型远程过程调用（TPRC）。前面介绍过远程过程调用。事务型远程过程调用的区别在于，它将资源管理器纳入到事务之中。为此，TP监控器必须考虑：
参与者的控制。在事务执行期间，为了管理提交和回滚，必须记录使用到的资源管理器。这个工作由事务管理器（TM）负责。资源管理器不需要知道自己参与过哪些事务。
保留事务相关信息。事务型远程过程调用可能会使用位于不同网络节点的多个资源管理器，必须记录这些信息。
事务协议的支持。资源管理器必须满足ACID特性，这些特性有事务型远程过程调用机制保证。
</p>

<p>
在事务执行期间，为了管理提交和回滚，必须有一个组件记录调用了哪些资源管理器。作为两阶段提交的一部分，必须有一个组件向全部资源管理器确认是否可以正常提交。这个组件叫做事务管理器（TM）。下面是一个事务型资源管理器的接口::
</p>

<p>
typedef char* RMNAME;
</p>

<p>
typedef struct 
{
        NODEID nodeId;
        PID pid;
        TIMESTAMP birthdate;
} rmInstance;
</p>

<p>
typedef struct
{
        unsigned long CB<sub>length</sub>;
        char CB<sub>bytes</sub>[CB<sub>length</sub>];
} rmParams;
</p>

<p>
Boolean rmCall(RMNAME, BindId* BoundTo, rmParams *InParams, rmParams *OutResults);
</p>


<p>
有两种方法来调用资源管理器：
单一入口。服务器只有一个服务入口（消息缓冲区），通过这个入口服务器接受全部的请求。在处理请求前，服务器必须判断请求的类型，并转发的合适的子程序。
服务入口加回调入口。资源管理器处理入口外还定义了一些回调接口，当某些特定事件发生后，这些回调接口被调用。下面是一些接口的声明::
</p>

<p>
Boolean rm<sub>Prepare</sub>();                        <i>/ 在提交的第一阶段调用，返回自己的结果。
Boolean rm<sub>Rollback</sub><sub>Savepoint</sub>(Savepoint);    /</i> 回滚到保存点。如果回滚成功，返回TRUE。如果需要进一步回滚，返回FALSE。
Boolean rm<sub>Commit</sub>(Boolean);                  <i>/ 在提交的第二阶段调用。
Boolean rm<sub>Savepoint</sub>();                      /</i> 在事务接收到一个保存点时调用。
void rm<sub>UNDO</sub>(&amp;buffer);                       <i>/ 要求资源管理器根据日志记录撤销操作。
void rm<sub>Abort</sub>();                             /</i> 中止事务。
void rm<sub>REDO</sub>(&amp;buffer);                       <i>/ 要求资源管理器根据日志记录重做操作。
void rm<sub>Checkpoint</sub>();                        /</i> 检查点。
void rm<sub>restart</sub>(LSN);                        
Boolean Identify(RMID);
</p>

<p>
在系统启动和关闭时，需要安装和卸载资源管理器::
</p>

<p>
RMID rmInstall(RMNAME,              <i>/ 全局唯一的名字。
               &amp;rm<sub>callbacks</sub>[],     /</i> 回调接口。
               AccessControlList,   <i>/ 访问控制列表。
               stuff);              /</i> TP监控器使用的其他信息。
Boolean rmRemove(RMID);             <i>/ 卸载资源管理器。
Boolean rmDeactivate(RMID);         /</i> 卸载资源管理器，并将其设置为不活跃。系统重启时将不会启动这个资源管理器。
Boolean rmActivate(RMID);           // 卸载资源管理器，并将其设置为活跃。系统重启时将会启动这个资源管理器。
void rm<sub>Startup</sub>();
void rm<sub>Shutdown</sub>();
</p>


<p>
如果一个客户重复调用服务器类，肯能出现3种情况：
相互独立的调用。由于调用是独立的，请求可以转发给服务器类中的任意进程。
按顺序调用。这类调用和前面的请求相关，比如“取后面10条记录”。这个请求需要使用SQL游标解决。首先一个OPEN CURSOR调用执行SQL语句并建立上下文，然后执行FETCH CURSOR调用，直到读取完全部数据。如果这是一个更新游标，在最后一个操作被执行前，服务器不能决定是否可以提交。
复杂的相互作用。这种情况较为普遍。服务器类必须记录客户的所有调用结果，否则无法判断一致性要求是否得到满足。
</p>

<p>
如果客户和服务器进程协作一段时间，并都保存了协作状态，那么就说它们在同一个会话中。这时服务器可以知道它在为哪个客户提供服务。会话可以避免重复的授权认证过程和一部分重复操作（比如打开文件），因此从性能角度来看是更好的选择。为维护上下文信息时，有四种可选方案：
</p>

<ol class="org-ol">
<li>通信会话复制维护上下文信息，并保证每一个后续请求转发到同一个服务器实例。</li>
<li>上下文信息包含在请求和应答之中，在客户和服务器之间传递。</li>
<li>服务器将上下文保存到一个数据库中。</li>
<li>服务器将上下文保存在共享的存储器中。</li>
</ol>

<p>
就上下文的类型来看，可以分为2类：
</p>
<ol class="org-ol">
<li>面向客户的上下文。这是客户和服务器之间相互作用的状态。比如游标位置、授权信息、用户标识等。</li>
<li>面向事务的上下文。这是事务控制范围包含的信息。</li>
</ol>

<p>
事务处理操作系统（Transaction Processing Operating System，TPOS）提供了两种机制来支持面向客户的上下文：
</p>
<ol class="org-ol">
<li>会话管理。如果上下文由通信会话维护，TP监控器负责将客户请求绑定到一个服务器进程上。</li>
<li>进程管理。即使TP监控器不主动负责上下文管理，但为了负载平衡它也可能使用关于每一个服务器已经存在的会话数量的信息。基本原理是一个已经建立的会话预示将来有更多的工作。</li>
</ol>

<p>
下面是会话绑定接口::
</p>

<p>
typedef struct
{
        rmInstance EndA;
        rmInstance EndB;
        Uint SeqNo;         // 用于区分相同两个端点建立的多个会话。
} BindId;
</p>

<p>
BindId rmBind(rmInstance);
Boolean rmUnbind(BindId);
</p>

<p>
TP监控器以服务器类（或者资源管理器类型）来管理资源。系统通过全局唯一的RMNAME标识服务。当资源管理器被安装到本地节点时，它会得到一个本地唯一的RMID。TP监控器为每个RMID维护一个服务器类。服务器类中的进程运行着相同的代码。在执行TRPC时，TP监控器根据请求中的RMNAME找到RMID，进而找到服务器类。如果服务器类中没有空闲进程，TP监控器会创建一个新进程，或者延迟执行TRPC。这些都发生在TRPC stub中。
</p>

<p>
假设系统中有5种资源管理器：TP监控器、事务管理器、日志管理器、锁管理器和通信管理器，可以构造如下的系统控制块::
</p>

<p>
typedef char* timestamp;
typedef struct anchor* TPOS<sub>AnchorP</sub>;
typedef struct anchor
{
        char *SysName;              <i>/ 本地系统名字
        timestamp DateGenerated;    /</i> 
        timestamp DateLastStartUp;  <i>/ 上次系统启动时间
        char morelikethis;          /</i> 管理相关的信息
        TPAnchorP TPMonCBs;         <i>/ TP监控器
        TMAnchorP TM<sub>CBs</sub>;           /</i> 事务管理器
        CMAnchorP SM<sub>CBs</sub>;           <i>/ 会话管理器
        LMAnchorP LM<sub>CBs</sub>;           /</i> 日志管理器
        IMAnchorP IM<sub>CBs</sub>;           // 锁管理器
} TPOS<sub>Anchor</sub>;
</p>


<p>
TP监控器的结构如下::
</p>

<p>
typedef struct tpa* TPAnchorP;
typedef struct tpa
{
        char *MyVersion;        <i>/ TP监控器版本
        char Repository[64];    /</i> 中心库名字
        handle Repos<sub>Handle</sub>;    <i>/ 中心库句柄
        char ContextDB;         /</i> 上下文数据库名字
        handle CtxDB<sub>Handle</sub>;    <i>/ 上下文数据库句柄
        RMID NextRMID;          /</i> 
        RMCB* FirstRMCB;        <i>/ 资源管理器控制块链表
        PCB* FirstPRCB;         /</i> 进程控制块链表
        SECB* FirstSECB;        <i>/ 会话控制块链表
        char *stuff;            /</i> 管理性数据
} TPAnchor;
</p>


<p>
当TPOS组件执行它的函数的时候，TPOS需要了解：
</p>
<ol class="org-ol">
<li>它在哪个进程中执行？</li>
<li>它在哪个事务中运行？</li>
<li>哪个资源管理器提出了该调用？</li>
</ol>

<p>
为了便于后面的阅读，我们首先定义几个TPOS相关的存取函数::
</p>

<p>
// 返回当前进程
PID MyProcid();
// 返回当前事务
TRID MyTrid();
// 返回发出调用的资源管理器
RMID MyRmid();
// 返回调用者客户的RMID
RMID ClientRmid();
// 返回进程控制块
PCB MyProc();
// 返回资源管理器控制块
RMCB MyRM();
// 返回客户RM
RMCB ClientRM();
// 返回进程控制块指针
PCB* MyProcP();
// 返回事务控制指针
TransCB* MyTransP();
// 返回资源管理器控制块指针
RMCB* MyRMP();
// 返回客户资源管理器控制块指针
RMCB* ClientRMP();
</p>

<p>
下面是资源管理器控制块::
</p>

<p>
typedef struct ResMgr *RMCBP;
typedef struct ResMgr
{
        // 资源管理器全局名字
        RMNAME rmname;
        // 资源管理器标识
        RMID rmid;
        // 是否是本地资源管理器
        Boolean RMLocal;
        // 访问控制列表
        pointer acl;
        // 资源管理器优先级
        Uint priority;
        // 是否处于活跃状态
        Boolean RMactive;
        Boolean RMup;
        Boolean UpAfterREDO;
        // 请求数量
        Uint QueueLength;
        // 请求队列
        RMQUEP waiters;
        // 指向最后一个等待的请求
        RMQUEP end<sub>of</sub><sub>chain</sub>;
        // 事务控制块链表
        RMTA<sub>CBP</sub> RMTA<sub>chain</sub>;
        // 进程控制块链表
        RMPR<sub>CBP</sub> RMPR<sub>chain</sub>;
        // 网络节点控制块链表
        RMNO<sub>CBP</sub> RMNO<sub>chain</sub>;
        // 指向链表中的下一个元素
        RMCBP next<sub>RMCB</sub>;
} RMCB;
</p>


<p>
下面是进程控制块::        
</p>

<p>
typedef struct Processes *PCBP;
typedef struct Processes 
{
        // 操作系统提供的进程编号
        PID pid;
        // 所属的服务器类
        RMID InstanceOf;
        // 资源管理器进程正在其中运行的服务器类
        RMID RunsIn;
        // 调用RunsIn的客户的RMID
        RMID ClientID;
        // 正在执行的事务
        TRID WorksFor;
        // 是否正在处理请求
        Boolean busy;
        // 优先级
        Uint priority;
        // 指向被挂起的事务列表
        PRTA<sub>CBP</sub> TAsToDo;
        // 地址空间可以切换的资源管理器列表
        PRRM<sub>CBP</sub> IMayUse;
} PCB;
</p>


<p>
会话控制块::
</p>

<p>
typedef struct Sessions *SECBP;
struct Sessions 
{
        // 会话名
        char name[BIG];
        // 会话方向（输入、输出）
        Boolean  Incomming;
        // 初始化进程编号
        PID  Initator;
        // 初始化进程所在节点
        NODEID InitNode;
        // 通信管理器提供的会话句柄
        HANDLE handle;
        // 使用当前会话的事务
        TRID UsedBy;
        // 其他信息
        char *stuff;
} SECB;
</p>

<p>
实体之间的交叉引用块::
</p>

<p>
typedef struct rmta *RMTA<sub>CBP</sub>;
// 描述资源管理器和事务的关联信息
typedef struct rmta 
{
        // 事务
        TRID ServicedTA;
        // 保存事务状态的数据结构
        pointer DataINeed;
        // 指向资源管理器的下一个事务的控制块
        RMTA<sub>CBP</sub> NextTA;
} RMTA<sub>CB</sub>;
</p>


<p>
资源管理器请求队列控制块::
</p>

<p>
typedef struct rmq *RMQUEP;
typedef struct rmq 
{
        // 消息
        pointer RequestMsg;
        // RPC上下文
        pointer RPC<sub>Data</sub>;
        // 超时时间
        long timeout;
        // 请求的资源管理器类型
        RMID ClientType;
        // 请求的资源管理器实例
        rmInstance ClientInst;
        // 下一个元素
        RMQUEP NextWaiter;
} RMQUE;
</p>


<p>
资源管理器进程队列::
</p>

<p>
typedef struct rmqr *RMPR<sub>CBP</sub>;
typedef struct rmpr
{
        // 进程
        PID pid;
        // 是否分配给了服务器类
        Boolean PrimaryProc;
        RMPR<sub>CBP</sub> NextProcess;
} RMPR<sub>CB</sub>;
</p>


<p>
进程的资源管理器列表::
</p>

<p>
typedef struct prm *RMPR<sub>CBP</sub>;
typedef struct prm
{
        RMID rmid;
        char *stuff;
        PRRM<sub>CBP</sub> NextResMgr;
} PRRM<sub>CB</sub>;
</p>

<p>
辅助程序执行下面的函数：给定对象类型的标识符，创建或返回对应的控制块指针::
</p>

<p>
enum operation { LOOKUP, INSERT };
RMCB* RMCBAccess(RMID, operation);
</p>

<p>
TRPC路径概览。
</p>

<p>
下面介绍完整的TRPC路径。TRPC过程分为：
</p>

<p>
本地调用处理。查找调用种类和调用目的地。这一步发生在调用者的TRPC stub上。
准备联出调用。如果是远程调用，通信管理器需要向其他节点发送消息。
联入调用处理。当来自其他节点的TRPC到达后，联入调用处理吧请求转发给本地进程。
调用执行。当一个（本地或远程）TRPC的接收被决定后，它必须被正确的处理。
调用返回。这可以由一个步骤完成，因为返回路径已经在调用过程中完全确定了。
</p>

<p>
本地调用处理::
</p>

<p>
Boolean rmCall(RMNAME rmname,
               BindId* BoundTo,
               rmParams* InParams,
               rmParams* OutResults)
{
        // 资源管理器控制块
        RMCBP rmcbp;
        // 进程ID
        PID pid = MyProcId();
        // 进程控制块
        PCBP pcbp = MyProcP();
        // 新进程的ID
        PID pid<sub>new</sub>;
        // 新进程控制块
        PCBP pcbp<sub>new</sub>;
        PRRM<sub>CBP</sub> prrm<sub>cbp</sub>;
        Boolean CanSwitch;
        RMID DestRMID;
        RMID CallerClient;
        Boolean success;
        CallerClient = pcbp-&gt;ClientID;
        if (BoundTo == NULL)
        {
                // 这是没有上下文的调用
                rmcbp = NameServer(rmname, "LOOKUP");
                if (rmcbp == NULL)
                        handle<sub>error</sub>;
                if (!rmcbp-&gt;RMLocal)
                {
                        // 远程调用
                        return RemoteRMC(&#x2026;);
                }
</p>

<p>
                DestRMID = rmcbp-&gt;rmid;
                // 省略授权
                CanSwitch = FALSE;
                // 检查是否需要切换进程
                prrm<sub>cbp</sub> = pcbp-&gt;IMayUse;
                while ((prrm<sub>cbp</sub> != NULL) &amp;&amp; !CanSwitch)
                {
                        // 切换到被调用者地址空间
                        CanSwitch = (prrm<sub>cbp</sub>-&gt;rmid == DestRMID);
                        prrm<sub>cbp</sub> = prrm<sub>cbp</sub>-&gt;NextResMgr;
                }
                if (CanSwitch)
                {
                        // 将进程指定给资源管理器。
                        pcbp-&gt;ClientID = pcbp-&gt;RunsIn;
                        pcbp-&gt;RunsIn = DestRMID;
                        success = DomainSwitch(DestRMID, &#x2026;);
                }
                else
                {
                        pcbp<sub>new</sub>-&gt;busy = TRUE;
                        pcbp<sub>new</sub>-&gt;ClientID = pcbp-&gt;RunsIn;
                        pcbp<sub>new</sub>-&gt;RunsIn = DestRMID;
                        pcbp<sub>new</sub>-&gt;WorksFor = pcbp-&gt;WorksFor;
                        SendIPC(pid<sub>new</sub>, RequestMessage);
                        Receive(ResponseMessage);
                }
                return success;
        }
        else
        {
                // 在会话中执行
                if (BoundTo.EndB.nodeId != NULL)
                {
                        return RemoveRMC(&#x2026;);
                }
                if (BoundTo.EndB.pid == pid)
                {
                        // do domain switch
                }
                else
                {
                        SendIPC(&#x2026;);
                }
        }
}
</p>

<p>
准备联出调用。
如果请求需要发送到其他节点执行，通信管理器需要建立和维护进程间的通信会话。TP监控器中的TRPC stub将请求封装成固定格式::
</p>

<p>
typedef struct FPMsg *msg<sub>ptr</sub>;
typedef struct FRMsg
{
        // 接收请求的服务器
        RMID addressee;
        // 请求中TRID
        TRID req<sub>trid</sub>;
        // 被调用者节点
        NODEID orig<sub>node</sub>;
        // 调用者节点的RMID
        RMID rmid;
        // 会话句柄
        HANDLE handle;
        // 终端ID
        TERMID terminal<sub>id</sub>;
        // 用户授权
        AUTHID user<sub>id</sub>;
        // 请求者授权
        AUTHID rm<sub>authid</sub>;
        // 标识请求已经被本地TP监控器授权
        Ulong source<sub>authent</sub>;
        // 其他数据
        char *stuff;
        // 消息长度
        Ulong data<sub>length</sub>;
        // 消息体
        char payload[data<sub>length</sub>];
} RequestMessage;
</p>

<p>
联入调用处理。从网络上传来的请求，首先被发送到通信管理器。通信管理器执行类似本地rmCall的逻辑。如果请求在已经建立的会话中，系统已经分配了一个进程给它。实际上，在等待会话中的下一个请求时，进程在它的TRPC stub中挂起。通信管理器必须唤醒进程。如果请求不属于任意会话，就必须要进行调度。TP监控器的调度程序找到可用的服务器类，转发请求。还有一种情况，请求要求建立会话。这时通信管理器建立一个会话，让TP监控器分配一个进程和会话管理。
</p>

<p>
调用执行。资源管理器可能需要执行和请求相关的一些授权。这是第一步。第二步，TP监控器（或资源管理器）向事务管理器登记当前事务::
</p>

<p>
// 资源管理器控制块
RMCBP rmcbp;
// 资源管理器事务链表
RMTA<sub>CBP</sub> rmta<sub>cbp</sub>;
Boolean HaveToJoin;
// 当前事务
TRID trid = MyTrid();
if (tnd != NULLTRID)
{
        <i>/ 联入请求包含TRID
        /</i> 获得资源管理器控制块
        rmcbp = MyRMP();
        // 查找TRID
        rmta<sub>cbp</sub> = rmcbp-&gt;RMTA<sub>chain</sub>;
        HaveToJoin = TRUE;
        while (rmta<sub>cbp</sub> != NULL &amp;&amp; HaveToJoin)
        {
                HaveToJoin = (rmta<sub>cbp</sub>-&gt;ServicedTA != trid);
                rmta<sub>cbp</sub> = rmta<sub>cbp</sub>-&gt;NextTA;
        }
</p>

<p>
        if (HaveToJoin)
        {
                Join<sub>Work</sub>();
        }
}
</p>

<p>
调用返回。调用者进程在TRPC stub中挂起，等待响应消息的唤醒。TP监控器有两个工作需要处理，一是重置返回进程的控制块，二是检查请求，转发给等待该请求的资源管理器::
</p>

<p>
// 请求队列指针
RMQUEP rmquep; 
if (BoundTo == NULL)
{
        pcbp<sub>new</sub>-&gt;busy = FALSE;
        pcbp<sub>new</sub>-&gt;ClientID = NULLRMID;
        pcbp<sub>new</sub>-&gt;RunsIn = NULLRMID;
        pcpb<sub>new</sub>-&gt;WorksFor = NULLTRID;
        if (rmcbp-&gt;QueueLength != 0)
        {
                rmqueuep = rmcbp-&gt;waiters;
                rmcbp-&gt;waiters = rmqueue-&gt;NextWaiter;
                rmbcp-&gt;QueueLength&#x2013;;
        }
}
</p>

<p>
上面的讨论都是基于单独TRPC进行的。实际情况是，TRPC stub会被很多进程并行执行。为此必须使用信号量来保护中心控制块。TP监控器采用如下的简单协议：
</p>

<ol class="org-ol">
<li>进程在TRID中运行时，进程负责保护它运行的控制块，防止其他进程使用和更改。事务处理器保护自己的控制块。</li>
<li>如果TP监控器希望处理一个事务中资源管理器的调用，如果事务繁忙，除非是中止调用，否则应立即拒绝。</li>
<li>中止调用首先要检查是否有正在执行中的中止操作。如果答案是肯定的，立即拒绝调用。</li>
<li>如果没有中止操作发生，可能会有一个进程正在为事务工作。TP监控器通过它的中心控制块可以检测到这种情况。这时，TP监控器等待调用返回，并阻塞属于这个事务的控制块，以保证事务回滚操作在当前节点上可以正常执行。</li>
</ol>


<p>
管理请求和应答对立。迄今为止我们讨论的都是直接事务：请求被立即授权、分派和执行，应答也立即返回给客户。直接事务通常用于交互式处理。对事务请求，也可以采用异步的方式，将请求放入队列中。这么做主要是因为：
</p>

<p>
负载控制。将资源管理器的负载稳定保持在一个固定的范围内。
最终用户控制。如果在系统中事务已经提交，但是在向用户发送结果时通信出现故障，用户无法接收事务结果。因此需要保存异步事务的输出用于重发，直到明确收到用户的确认。
可恢复的数据项。一些应用需要顺序处理大量数据。这些数据通常放到一个队列中，并且保证即使系统崩溃，也不能丢失数据。
多重事务请求。比如服务器S1处理的结果需要传递给服务器S2处理。
</p>

<p>
事务系统需要两种类型的队列：易失队列用于支持直接事务，持久队列用于支持异步事务。首先介绍易失队列。易失队列在系统崩溃后不能重建，崩溃后队列中的元素会丢失。易失队列通常用于直接事务调度。假设一个服务器类已经建立了P个进程，如果某个时刻系统中并发的请求有P+1个，这时TP监控器有三种选择：
</p>

<ol class="org-ol">
<li>建立新进程处理请求。</li>
<li>告诉客户系统负载过高，让客户等待一段时间后重新请求。等待的时间由客户决定。这种方法的缺点是TP系统失去了对请求的控制，也无法了解负载的真实情况。</li>
<li>TP监控器建立一个易失队列，将请求放入队列。等待有空闲的进程时分派请求。</li>
</ol>

<p>
由于服务器类包含多个进程，必须考虑队列访问的并发控制，即：
</p>

<ol class="org-ol">
<li>每个请求只能被一个进程获取并执行。</li>
<li>队列的结构必须时刻保持正确。</li>
</ol>

<p>
如何做到这一点将在第八章介绍。
</p>


<p>
异步事务处理需要使用持久队列。有一个事务处理客户的请求，表示服务、认证、一致性检查都是事务的一部分。事务向服务器发出请求，这个请求被放在服务器的请求队列中，然后客户事务进行提交。每一个请求都对应三个事务：
</p>

<p>
第一个事务产生请求，并把请求放到服务器的输入队列里。
第二个事务在服务器处理请求并把结果放入客户的响应队列中。
第三个事务从客户的响应队列取出应答并展现给用户。
</p>

<p>
这样的处理方式叫做排队事务处理（Queued Transaction Processing，QTP）。面向对象的客户-服务器交互的活动可以用三个属性来描述：
</p>

<p>
请求-回复匹配。系统保证每个请求都会有一个回复（reply），即使回复的内容是“无法处理该请求”。
ACID请求处理。每个请求只执行一次。保存响应是ACID事务的一部分。
至少一次的响应处理。保证客户对每一个响应至少接收一次。
</p>

<p>
为了实现这些功能，必须让应答和请求关联起来。我们为每个请求分配一个标识符（RQID），这个标识符由客户提供，并随着应答返回给客户。
</p>

<p>
有了这些准备就可以定义TPOS系统的排队系统接口了。排队系统可以看成是一种处理请求和应答的资源管理器，每个队列都有一个全局唯一的名字和局部的标识符::
</p>

<p>
using QueueName = std::array&lt;char,Big&gt;;
using QueueId = unsigned int;
using RequestId = TransactionId;
using Request = std::string;
using Response = std::string;
</p>

<p>
// 将请求放入请求队列。
bool send(Request request, RequestId requestId, QueueId requestQueueId, QueueId responseQueueId);
</p>

<p>
// 从应答队列接收应答。
Response receive(QueueId responseQueueId, char *keepThat[1000]);
</p>

<p>
// 客户在重启后找出上次执行成功的最后一项工作。
Response re<sub>receive</sub>(QueueId response);
</p>

<p>
当客户注册到队列，就建立了客户和队列资源管理器之间的可恢复的会话。如果任何一端崩溃，都可以根据最后一次更新队列的事务重建状态::
</p>

<p>
using QueueStatePtr=*QueueState;
</p>

<p>
struct SessionParameter {
        QueueId queueId;
        RequestId lastSentRequest;
        RequestId lastReceivedRequest;
        Response response;
} QueueState;
</p>

<p>
// 客户连接队列。
QueueState connect(RMID myRMID, QueueId queueId);
</p>

<p>
// 客户关闭队列会话。只有在全部应答被客户接收后才能返回。
bool disconnect(RMID myRMID, QueueId queueId);
</p>

<p>
为了简单起见，假设队列保存在下面的数据表里::
</p>

<p>
exec sql CREATE TABLE sys<sub>queues</sub> (
        quid             integer not null,
        q<sub>type</sub>           char(2) not null,
        from<sub>rmid</sub>        integer not null,
        to<sub>rmid</sub>          integer not null,
        timestamp        time,
        rqid             TRID not null,
        keepthat         char(1000),
        request<sub>response</sub> char(40000),
        no<sub>dequeues</sub>      integer,
        delete<sub>flag</sub>      char(1),
        primary key (quid, rqid, time));
</p>

<p>
属性q<sub>type表示队列的用途</sub>。“CS”表示是客户向服务器发送请求的队列，“SC”表示是客户接收服务应答的队列，“SS”表示队列用于多重事务。属性no<sub>dequeues表示请求频率的计数器</sub>，属性delete<sub>flag用来标记将元素删除</sub>。
</p>

<p>
其他资源管理和队列管理器之间的会话保存在::
</p>

<p>
exec sql CREATE TABLE qu<sub>sessions</sub> (
        quid integer not null,
        rmid integer not null,
        role char(1),
        primary key (quid, rmid));
</p>

<p>
属性role表示rmid的角色是客户还是服务器。下面是send函数的实现方法::
</p>

<p>
using QueueAttributePtr=*QueueAttribute;
struct QueueAttribute {
        QueueId queueId;
        char q<sub>type</sub>[2];
        RMID from<sub>rmid</sub>;
        RMID to<sub>rmid</sub>;
        char time[8];
        RequestId requestId;
        char keepthat[1000];
        char request<sub>response</sub>[40000];
        unsigned int no<sub>dequeues</sub>;
        char delete<sub>flag</sub>;
};
</p>

<p>
bool send(QueueAttributePtr p) {
        exec sql INSERT INTO sys<sub>queues</sub> VALUES (
                :p-&gt;queueId,
                :p-&gt;q<sub>type</sub>,
                :p-&gt;from<sub>rmid</sub>,
                :p-&gt;to<sub>rmid</sub>,
                CURRENT,
                :p-&gt;requestId,
                :p-&gt;keepthat,
                :p-&gt;request<sub>response</sub>,
                0,
                NULL);
        return (sqlcode == 0);
}
</p>

<p>
Response receive(QueueId from<sub>there</sub>, char keepThat[1000]) {
</p>

<p>
exec sql DECLARE CURSOR dequ ON
        SELECT * FROM sys<sub>queues</sub>
        WHERE quid=:from<sub>there</sub> AND
        delete<sub>flag</sub> = NULL
        ORDER BY rqid ASCENDING
        FOR UPDATE;
</p>

<p>
while (TRUE) {
        exec sql OPEN dequ;
        exec sql FETCH dequ INTO :p-&gt;QAttr;
        if (sqlcode == 0) {
                exec sql UPDATE WHERE CURRENT OF CURSOR dequ
                        SET delete<sub>flag</sub> = 'D',
                        QAttrPtr-&gt;KeepThat=:keepThat;
                exec sql CLOSE dequ;
                return TRUE;
        }
</p>

<p>
                exec sql OPEN dequ;
                wait(1);
        }
}
</p>

<p>
void rm<sub>Startup</sub>() { return; }
bool rm<sub>Prepare</sub>() { return TRUE; }
</p>

<p>
void rm<sub>Abort</sub>(QAttrPtr request) {
        TRID new<sub>trid</sub>;
        TRID old<sub>trid</sub>;
        bool success;
        old<sub>trid</sub> = leave<sub>transaction</sub>();
        new<sub>trid</sub> = BeginWork();
        exec sql UPDATE sys<sub>queues</sub>
                SET delete<sub>flag</sub> = NULL,
                no<sub>dequeues</sub> =no<sub>dequeues</sub> + 1
                WHERE quid = :(request-&gt;quid)
                AND rqid = :(request-&gt;rquid)
                AND time = :(request-&gt;time);
</p>

<p>
        success = CommitWork(NULL, FALSE);
        success = resume<sub>transaction</sub>(old<sub>trid</sub>);
        return;
}
</p>


<p>
下面介绍TP监控器进行负载均衡、认证、授权及重启时的典型机制。
</p>

<p>
负载均衡。负载均衡需要解决的问题是：给定一组请求，需要分配多少个进程？首先来看本地进程调度。本地进程调度需要考虑以下参数：
</p>

<p>
进程的优先级。
工作集合大小。在某个时间点上为进程分配多少内存。
完成时间约束。请求必须在多少时间内被处理。
</p>

<p>
因此，在本地调度时往往采用如下的策略：
</p>

<ol class="org-ol">
<li>如果产生请求的地址空间里提供这个服务，就保持进程和地址空间。</li>
<li>如果服务在不同的地址空间中提供，当前进程可以绑定到服务进程。</li>
<li>如果本地节点不提供该服务，通过名字服务器得到服务节点，通过通信管理器转发请求。</li>
<li>如果本地有一个空闲服务，将请求转发给该进程。</li>
<li>此外，根据CPU和服务器类的使用情况，决定是否新建进程。</li>
</ol>

<p>
考虑一个带有队列的数据库服务器。假设请求的到达率为R，服务时间是T1。假设请求满足M/M/1队列模型。每个请求的平均服务时间是S1=T1/(1-T/R)。如果系统满足：
</p>

<ol class="org-ol">
<li>每个请求拥有足够的CPU。</li>
<li>数据没有冲突。</li>
</ol>

<p>
可以支持服务器类包含多个进程。假设每个服务器类包含n个进程，那么每个请求的平均服务时间是
</p>

<p>
Sn=(T(1+c(n-1)))/(1-T(R/n)(1+c(n-1)))
</p>

<p>
TP监控器必须监测所有服务器类的利用率，以及CPU及其他物理资源，如通信总线和磁盘利用率。
</p>


<p>
跨节点边界的调度。在分布式系统中，节点之间通过高带宽低延时的通信通道连接起来。假设发送请求到远程节点并返回的开销为T，调度策略必须考虑：
</p>

<ol class="org-ol">
<li>基于CPU利用率和服务类的利用率，预期的本地响应时间Sl是多少？</li>
<li>给定远程服务器的资源利用率，它的预期响应时间Sr是多少？</li>
<li>基于通信媒介利用率，预期的Tc是多少？</li>
</ol>

<p>
如果某个远程节点满足Sr+Tc&lt;Sl，请求应该分派到这个节点上。为了进行估算，TP监控器需要跟踪本地服务器和远程服务器的性能数据。
</p>

<p>
上述的全局调度策略由两个问题。假设系统中有两个服务器类A和B，系统一共有N个节点，每个节点分配Ia个进程给A，Ib个进程给B。每个A实例都可以吧请求转发给任意一个B实例。如果请求不是上下文无关的，就必须通过会话关联起来。这样，在运行一段时间后，每个A实例会和每个B实例建立会话，产生N<sup>2</sup>*Ia*Ib个控制块。这种控制块数量膨胀的问题叫做控制块死亡。
</p>

<p>
认证和授权。操作系统在以下几个方面支持系统安全：
</p>

<p>
用户身份认证。用户被赋予在文件、库和系统函数上的特定权限。在登入时，系统认证用户身份。
会话认证。同用户认证类似，不过请求认证的是远程节点上的进程。
文件存储控制。文件安全由一个二维存取矩阵保护。
内存存取控制。
</p>

<p>
TP监控器使用的认证授权机制粒度更细。假设具有认证标识A的用户对服务S发出请求，TP监控器必须作出判断：
</p>

<p>
当前用户在当前时刻，是否有权从当前终端上，以给定参数调用对象提供的服务。
</p>

<p>
在传统的分时环境里，用户登录后可以获得一组进程，这些进程都运行在用户标识下。这种机制容易实现，但也容易被木马程序利用。考虑下面这个场景：用户的电脑上部署了一套邮件系统，以myself标识运行。用户收发邮件时，需要启动应用程序，向邮件系统发出请求。假设应用程序的用户标识是localadm。在发送邮件时，邮件系统会连接到远程服务器上运行的邮件系统。在远程服务器上，邮件系统以mailguy标识运行，并将数据保存在SQL数据库中。当用户查看邮件时，会产生这样的访问路径：
</p>

<p>
用户以myself身份访本地应用
应用程序以localadm身份访问本地邮件系统
远程邮件系统以mailguy身份访问SQL数据库
SQL数据库以DBadmin身份访问文件系统
</p>

<p>
如果为访问路径的每个节点都加上用户认证标识，会存在两个问题：一是在分布式系统中，不能保证每个节点都知道这个用户标识；二是最终用户（myself）可能没有操作资源（如远程服务器上的文件系统）的授权。另一种方法是收集路径上的全部认证标识。这种做法没有必要。通常的做法是记录两个认证标识，一个是直接调用方的标识（成为客户授权），一个是事务标识。事务标识通过请求传递，它是启动事务的用户具有的认证标识。TP监控器在调用服务时只对客户授权进行认证，对事务标识的认证交给资源管理器处理。这反映了一个简单的操作分离原则：TP监控器不拥有数据库、日志或用户文件，它管理的是一系列资源管理器，这些资源管理器负责运行数据库、维护日志等工作。TP监控器控制对资源管理器的访问，资源管理器控制对资源的访问。
</p>

<p>
下面是TP监控器存取矩阵的一个例子：
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2019-09-23 周一 18:45</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>

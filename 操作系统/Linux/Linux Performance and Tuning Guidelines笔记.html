<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-09-23 周一 20:55 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Linux Performance and Tuning Guidelines笔记</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Linux Performance and Tuning Guidelines笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgcb5889b">第一章 理解Linux操作系统</a>
<ul>
<li><a href="#orga63409d">Linux进程管理</a>
<ul>
<li><a href="#orgcf1899c">进程</a></li>
<li><a href="#org6e9070a">内存</a></li>
</ul>
</li>
<li><a href="#orgc96bf9c">Linux文件系统</a></li>
<li><a href="#org83fc661">磁盘IO系统</a></li>
<li><a href="#org1079dd7">网络子系统</a></li>
<li><a href="#orgdc9d069">理解Linux性能度量</a></li>
</ul>
</li>
<li><a href="#orgecb25f4">第二章 监控和基准测试工具</a>
<ul>
<li><a href="#org9523c9b">监控工具</a></li>
<li><a href="#orgf0b808a">基准测试工具</a></li>
</ul>
</li>
<li><a href="#org0876699">第三章 分析性能瓶颈</a>
<ul>
<li><a href="#orgba77c62">确认瓶颈</a></li>
<li><a href="#orgd632a51">CPU瓶颈</a></li>
<li><a href="#orgd80c8ce">内存瓶颈</a></li>
<li><a href="#org4410d70">磁盘瓶颈</a></li>
<li><a href="#org63d0956">网络优化</a></li>
</ul>
</li>
<li><a href="#org5deab54">第四章 调整操作系统</a>
<ul>
<li><a href="#org7cd91e8">优调CPU子系统</a></li>
<li><a href="#org04db646">调整虚拟内存子系统</a></li>
<li><a href="#org8798bf1">优调磁盘系统</a></li>
<li><a href="#org06a8a9a">优调网络系统</a></li>
</ul>
</li>
<li><a href="#orge9e6c0e">参考资料</a></li>
<li><a href="#org7a49781">编辑记录</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgcb5889b" class="outline-2">
<h2 id="orgcb5889b">第一章 理解Linux操作系统</h2>
<div class="outline-text-2" id="text-orgcb5889b">
</div>
<div id="outline-container-orga63409d" class="outline-3">
<h3 id="orga63409d">Linux进程管理</h3>
<div class="outline-text-3" id="text-orga63409d">
</div>
<div id="outline-container-orgcf1899c" class="outline-4">
<h4 id="orgcf1899c">进程</h4>
<div class="outline-text-4" id="text-orgcf1899c">
<p>
进程（process）管理是操作系统最重要的功能之一。Linux进程管理功能包括：
</p>

<ul class="org-ul">
<li>进程调度</li>
<li>中断处理</li>
<li>信号</li>
<li>进程优先级</li>
<li>进程切换</li>
<li>进程状态</li>
<li>进程内存</li>
</ul>

<p>
进程是运行在处理器上的一个执行序列实例。进程使用Linux内核可以管理的资源来完成任务。Linux下的进程通过结构体 task_struct 管理，
它也叫做进程描述符（process descriptor）。进程描述符记录了进程的标识、属性和分配的资源。了解进程描述符，可以对进程的执行和性能表现有更深入的理解。
结构体 task_struct 定义在头文件include/linux/sched.h中，它包括以下的主要部分：
</p>

<ul class="org-ul">
<li>stat。进程状态</li>
<li>thread_info 。进程信息和内核堆栈 （ thread_info ）</li>
<li>run_list 。进程调度使用（runqueue）</li>
<li>mm。地址空间（ mm_struct ）</li>
<li>pid。进程编号</li>
<li>group_info 。组管理（group_info）</li>
<li>user。用户管理（ user_struct ）</li>
<li>fs。工作目录和组目录（ fs_struct ）</li>
<li>files。文件描述符（ files_struct ）</li>
<li>signal。信号信息（ signal_struct ）</li>
<li>sighand。信号处理句柄（ sighand_struct ）</li>
</ul>

<p>
每个进程都有自己的生命周期：创建、执行、终止和移除。创建进程时，父进程执行系统调用fork()，fork()获得一个新的进程描述符，设置进程编号，
将父进程描述符中的值复制到子进程描述符。这时地址空间还没有进行复制，两个进程共享同一个地址空间。
</p>


<p>
大部分程序在fork()之后会立即调用exec()。exec()将新程序复制到子进程的地址空间中。由于此时子进程还在使用父进程的地址空间，
复制操作会引发一个页错误（page fault），CPU检测到错误后，通过中断向量表通知Linux内核。内核为子进程分配物理页（physical page），
然后CPU重新执行复制指令。这种延迟复制的策略叫做写时拷贝（Copy-On-Write），可以避免不必要的复制行为。因为复制地址空间成本较高，写时拷贝可以提高系统性能。
</p>


<p>
进程执行完毕，立即调用exit()通知内核。exit()释放进程使用的大部分资源，并发送信号通知父进程。这时进程描述符还没有被释放。这种状态叫做僵尸（zombie）。
当父进程通过该wait()或waitpid()得知子进程退出的消息后，子进程的资源才会被全部释放。
</p>


<p>
线程（thread）是进程中的一个执行单元。一个进程中可以有多个线程。这些线程并发执行，共享进程的内存、地址空间、文件句柄等资源。
在建立线程时，共享的资源无需复制，新建成本比进程低。因此线程也叫做轻量进程（light weight process，LWP）。
但另一方面，线程是并发执行的，在访问共享资源时必须进行协调，否则会触发竞态条件。常用的协调手段是互斥。
</p>


<p>
Linux采用抢占式调度。内核为每个进程分配一个数字作为优先级（priority）。优先级高的进程有更大的机会得到CPU运行时间。
进程优先级分为静态优先级和动态优先级两部分。动态优先级由内核维护，根据进程的表现和特性决定。静态优先级可以通过nice命令设置。
nice值从19（优先级最低）到-20（优先级最高），默认值是0。
</p>


<p>
进程在CPU上执行时，寄存器和缓存记录了进程需要的信息（程序指令和数据）。这些信息叫做上下文（context）。当其下一个进程需要使用CPU时，
当前进程的上下文会保存到进程描述符和内核堆栈（kernel mode stack）中。下一个进程的上下文加载到寄存器和缓存中。这个过程叫做上下文切换（context switch）。
上下文切换会引起寄存器、高速缓存以及流水线的冲刷。过于频繁的上下文切换会影响系统性能。
</p>


<p>
硬件和软件产生的事件通过中断的方式通知CPU。CPU在执行完一条指令后检查中断是否发生，然后从中断向量表中找到处理函数，暂停当前进程，执行中断处理函数（内核态）。
这表明中断会引发上下文切换，因此也会影响系统性能。硬件事件引发的中断叫硬中断（hard interrupt），软件事件引发的叫软中断（soft interrupt）。
在多核环境下，中断均匀分配到每个核心上。使用命令可以将中断绑定到一个核心上，以避免其他核心频繁出现上下文切换。Linux的内核接口/proc/interrupts提供了关于
中断的统计信息。
</p>


<p>
进程状态表明进程正在做些什么，这些状态有：
</p>

<ul class="org-ul">
<li>TASK_RUNNING 。进程正在执行，或者在运行队列（run queue）中等待执行。</li>
<li>TASK_STOPPED 。进程被信号（比如SIGINT、SIGSTOP）挂起，并等待被信号（如SIGCONT）唤醒。</li>
<li>TASK_INTERRUPTIBLE 。进程被挂起，并等待某个特定条件。此时进程可以处理信号。典型例子如等待键盘输入。</li>
<li>TASK_UNINTERRUPTIBLE 。进程被挂起，且不处理信号。比如等待磁盘I/O操作的进程。</li>
<li>TASK_ZOMBIE 。进程已退出，但其父进程尚未得知退出情况。</li>
</ul>


<p>
这里的 TASK_ZOMBIE 状态前面提到过僵尸进程。僵尸进程的大部分资源都已释放，但是进程描述符还在。Linux的进程描述符表长度有限，如果被僵尸进程占满，
会影响后续进程的建立。僵尸进程无法用kill杀死。如果系统中存在大量僵尸进程，可以采用kill父进程的方式处理。如果父进程是init进程，就需要重启机器了。
当然，根本的方案是检查父进程和子进程的职责分配以及程序中是否存在缺陷。
</p>



<p>
Linux下进程地址空间布局如下：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Text段</td>
<td class="org-left">可执行指令，只读</td>
<td class="org-right">0x0000</td>
</tr>

<tr>
<td class="org-left">Data段</td>
<td class="org-left">初始化数据</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Data段（BSS）</td>
<td class="org-left">初始化为零的数据</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Heap段</td>
<td class="org-left">通过malloc()动态分配的内存</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">stack段</td>
<td class="org-left">局部变量、函数参数、返回地址等</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-org6e9070a" class="outline-4">
<h4 id="org6e9070a">内存</h4>
<div class="outline-text-4" id="text-org6e9070a">
<p>
应用程序申请分配的内存实际上是虚拟内存。虚拟内存可能被映射到物理内存上，也可能被映射到磁盘上。
这种映射是由内核维护的，应用程序不需要关心。内存管理以页（page）为单位，
页是一块连续的内存（物理内存或虚拟内存）。页通常4KB大小。
</p>


<p>
内核使用伙伴系统（buddy system）分配和维护空闲页。如果系统中没有足够的空闲页，页回收机制将被触发。
内核将一些不再使用的active页释放并重新分配。内核进程kswapd负责这项工作。kswapd通常处于
可中断休眠状态。当空闲页低于某个阈值时，伙伴系统调用kswapd，
后者根据最近最少使用（Least Recently Used，LRU）原则选出候选待释放页。
kswapd也会释放页缓存（page cache）。页缓存映射到磁盘文件的页。
页回收的阈值可以通过/proc/sys/vm/swappiness设置。伙伴系统的信息在/proc/buddyinfo中。
</p>
</div>
</div>
</div>


<div id="outline-container-orgc96bf9c" class="outline-3">
<h3 id="orgc96bf9c">Linux文件系统</h3>
<div class="outline-text-3" id="text-orgc96bf9c">
<p>
Linux在用户进程和实际文件系统之间提供了一个抽象层，叫做VFS（Virtual Files System）。
VFS提供了公用对象模型，如：i-node、文件对象、页缓存、目录项等。
</p>


<p>
对于非日志文件系统，写操作首先更新文件的元数据（metadata），然后才更新文件内容。
写操作没有提供原子性。程序fsck可以修复掉电导致的文件系统数据不一致问题。
如果机器磁盘容量很大，修复过程需要持续很长一段时间。
</p>


<p>
日志（journaling）文件系统解决了这个问题。首先将原始数据写入日志（journal area），
然后将数据写入实际的文件系统。日志可以放置在文件系统内，也可以放置在文件系统外。
日志文件系统多了一次写数据操作，因此会产生一定的性能消耗。
</p>


<p>
Ext2文件系统是一个非日志文件系统。Ext2将磁盘划分为1个boot sector和多个block group。
block group又分为
</p>
<ul class="org-ul">
<li>super block。文件系统信息。</li>
<li>block group descriptor。当前block group的描述信息。</li>
<li>data block bitmaps。空闲数据块表。</li>
<li>i-node bitmaps。空闲i-node表。</li>
<li>i-node tables。保存文件的i-node表。每个文件有一个i-node表与之关联。i-node表中记录的文件的元数据，如file-mode、uid、gid、atime、ctime、mtime、dtime等，以及一个指向数据块（data block）的指针。</li>
<li>data blocks。保存用户数据（user data）。</li>
</ul>

<p>
Ext2将磁盘划分为多个block group的目的是让i-node和用户数据的距离更近，缩短磁盘寻址时间。
在打开一个文件时，内核首先要读取i-node，然后才能找到用户数据的位置。
目录项记录在目录文件的用户数据中。为了加速文件访问速度，内核会将使用到的文件对象（如i-node或目录项）
缓存起来。
</p>

<p>
Ext3是Ext2的升级版本。Ext3提供了写操作的一致性保证。它支持3中日志类型：
</p>
<ul class="org-ul">
<li>journal。提供最高一致性保证，元数据和用户数据使用日志。</li>
<li>ordered。</li>
<li>writeback。提供最快访问速度。系统崩溃时可能发生更新丢失。</li>
</ul>


<p>
XFS是eXtended File System的缩写，是一个高性能日志文件系统。
</p>
</div>
</div>


<div id="outline-container-org83fc661" class="outline-3">
<h3 id="org83fc661">磁盘IO系统</h3>
<div class="outline-text-3" id="text-org83fc661">
<p>
用户进程调用write()函数后，数据要经过VFS/file system layer、block layer、device driver
几个层次后传递给磁盘设备，完成实际的写入操作。这个过程简述如下：
</p>

<ol class="org-ol">
<li>用户进程调用write()请求向文件写入数据。</li>
<li>内核更新文件的page cache。</li>
<li>pdflush内核进程负责将page cache刷写到磁盘。这个过程是异步的。</li>
<li>文件系统将多个block buffer组成bio结构体，并提交写请求给block device layer。</li>
<li>block device layer执行I/O elevator，将请求放入I/O队列。</li>
<li>设备驱动（如SCSI）执行写操作。</li>
<li>磁盘固件执行seek head、rotation、data transfer等硬件操作。</li>
</ol>

<p>
书签 35
</p>

<p>
现代计算机系统通常具有3个层次的存储器：CPU缓存、内存和磁盘。提高CPU缓存命中率可以减少CPU等待数据的时间，对性能提升非常重要。使用的技术叫做locality of reference。locality of reference基于下列原则：
</p>

<ol class="org-ol">
<li>temporal locality。最近使用的数据具有更高概率在将来被使用。</li>
<li>spatial locality。正在使用的数据附近的数据具有更高概率被使用。</li>
</ol>

<p>
Linux在很多组件中（如page cache、i-node cache、directory entry cache）使用了这些原则。
</p>

<p>
在写入文件时，Linux首先将数据写入内存，在适当的时候再刷写到磁盘。在这中间，内存和磁盘的数据是不一致的。这样的数据叫做dirty buffer。pdflush进程负责刷写dirty buffer。文件/proc/sys/vm/dirty_background_ratio控制了这个行为。
</p>

<p>
block layer负责处理块设备操作，核心的数据结构是bio结构。bio接口是file system layer和block layer之间的接口。在刷写page caches时，file system layer将连续的block buffer组成一个bio结构发送给block layer。block layer处理bio结构，并将它们链接起来，放到I/O请求队列中。链接操作叫做I/O elevator。Linux支持4中I/O elevator算法：
</p>

<p>
Anitcipatory。此策略假设磁盘只有一个物理seek head（比如典型的SATA硬盘），并使用deadline机制和启发式预测。Anticipatory策略尝试写单一的长字节流，而不是大量小的随机磁盘访问。对于通用系统（general purpose system），比如PC，这种策略会提升吞吐量（throughput），代价是增加I/O延迟。
CFQ（Complete Fair Queueing）。CFQ为每个进程维护一个I/O队列，并以此实现QoS（Quality of Service）策略。CFQ适合于大量多用户系统（large multiuser system）。CFQ可以降低I/O延迟，并避免进程饥饿。从2.6.18开始，CFQ是默认策略。CFQ可能导致一些程序变慢。默认情况下，CFQ把一个进程组看做是一个程序，在各个程序之间尽量保证公平。如果一个数据库程序使用了多个进程，每个进程都频繁写磁盘，处于公平性考虑，CFQ会使这个程序变慢。
Deadline。Deadline elevator是一个cyclic elevator，它使用deadline算法进行轮询（round robin），并提供了近实时行为。Deadline策略提供了出色的I/O延迟，同时兼顾吞吐量，并保证进程饥饿不会发送。
NOOP。NOOP表示无操作（No Operation）。NOOP使用一个FIFO队列，不会执行任何数据排序（data ordering），只是将临近数据合并起来（NOOP simply merges adjacent data requests）。NOOP消耗非常少的CPU资源。NOOP假设块设备具有自己的elevator算法，像TCQ或SCSI，或者设备没有查询延迟（seek latency），比如闪存卡（flash card）。
</p>

<p>
每个磁盘子系统（disk subsystem）可以选择自己的elevator策略。
</p>

<p>
block size是读写磁盘的最小单位。如果服务器要处理大量小文件，降低block size可以提高处理性能。调整block size需要reformat。
</p>


<p>
Linux内核通过驱动控制设备。驱动是独立的内核模块。部分驱动在/etc/modules.conf中提供了配置接口。
</p>
</div>
</div>

<div id="outline-container-org1079dd7" class="outline-3">
<h3 id="org1079dd7">网络子系统</h3>
<div class="outline-text-3" id="text-org1079dd7">
<p>
下图简述了TCP协议栈：
</p>

<p>
                                       Process
                                       BSD socket
Ethernet Header 			 INET socket
  IP Header                            TCP/UDP
    TCP/UDP Header  &lt;-sk_buff-&gt;        IP
      Data                             Datalink
                                       Device
                                       Device driver
                                       NIC 
</p>

<p>
内核提供了缓冲区来发送和接收数据。缓冲区可以通过下列文件调整：
</p>

<p>
/proc/sys/net/core/rmem_max
/proc/sys/net/core/rmem_default
/proc/sys/net/core/wmem_max
/proc/sys/net/core/wmem_default
/proc/sys/net/ipv4/tcp_mem
/proc/sys/net/ipv4/tcp_rmem
/proc/sys/net/ipv4/tcp_wmem
</p>

<p>
TCP连接建立过程如下：
</p>

<ol class="org-ol">
<li>客户端发送SYN包给服务器。</li>
<li>服务器收到SYN包，发送SYN+ACK给客户端。</li>
<li>客户端发送ACK包给服务器，连接建立。</li>
</ol>

<p>
TCP连接关闭过程如下：
</p>

<ol class="org-ol">
<li>主动关闭端发送FIN包给对方。</li>
<li>被动关闭段收到FIN后，发送ACK和FIN给对方。</li>
<li>主动关闭段收到收到FIN后，发送ACK给对方。</li>
</ol>


<p>
transfer window是TCP在收到ACK之前可以发送或接受的最大数据量。窗口大小是接收端通过TCP头发送过来的。
</p>
</div>
</div>

<div id="outline-container-orgdc9d069" class="outline-3">
<h3 id="orgdc9d069">理解Linux性能度量</h3>
<div class="outline-text-3" id="text-orgdc9d069">
<p>
CPU性能度量：
</p>

<p>
CPU使用率。
用户时间（user time）。用户进程使用的CPU时间。用户时间高说明系统在进行实际工作。
系统时间（system time）。内核使用的CPU时间，包括IRQ和softirq时间。系统时间高说明网络或驱动栈（driver stack）可能存在瓶颈。
等待（Waiting）。CPU在等待I/O的时间。
空闲时间（Idle time）。CPU等待任务的空闲时间。
Nice time。CPU通过re-nicing来调整进程优先级所使用的时间。
平均负载（load average）。平均负载TASK_RUNNING和TASK_UNINTERRUPTIBLE状态的进程数的滚动平均值（rolling average），就是最近一段时间内，需要消耗CPU的进程数平均值。
可运行进程（runable processes）。等待执行的进程数。应当小于核心数乘以10。否则CPU可能成为瓶颈。
Blocked。等待I/O的进程数。如果这个值偏大，说明I/O存在瓶颈。
上下文切换（Context switch）。上下文切换会导致CPU缓存被频繁刷新，导致性能下降。
中断（interrupts）。中断过多表明软件（包括内核或驱动）可能存在瓶颈。
</p>

<p>
内存度量：
</p>

<p>
空闲内存（Free memory）。Linux系统会将没有使用的内存作为文件系统缓存，因此这个值对Linux系统意义不大。
交换空间使用率（swap usage）。这个值表明系统使用了多少交换空间。这个值越大，说明系统内存使用效率越高。
缓冲区和缓存（buffer and cache）。为文件系统和块设备分配的缓存。
slabs。内核使用内存的情况。内核页不会page out。
active versus inactive memory。inactive内存时可能被swap out的内存。
</p>

<p>
网卡度量：
</p>

<p>
收发包数量（packets received and sent）。
收发字节数（bytes received and sent）。
Collisions per second。通常为0。如果大于0，说明网络基础设施（不是服务器）存在问题。
掉包数量（packets dropped）。由于防火墙配置或缺少缓冲区而被内核丢弃的包。
Overruns。网卡耗尽缓冲区的次数。和掉包数量一起可以确认网络缓冲区或网络队列长度瓶颈。
Errors。标记为faulty的frame数量。通常由于网络不匹配或网络cable存在问题。
</p>

<p>
块设备度量：
</p>

<p>
Iowait。CPU等待I/O操作的时间。如果iowait过高，I/O可能存在瓶颈。
Average queue length。I/O请求队列长度。磁盘队列在2-3较好。如果高于这个值，可能存在瓶颈。
Average wait。I/O请求的平均耗时，单位是毫秒。包括实际处理I/O操作的时间以及在队列中的等待时间。
Transfers per second。每秒钟执行的I/O操作数量。结合KB per second可以了解系统中的平均转移大小。这个大小应该和磁盘子系统的stripe size匹配。
Blocks read/write per second。每秒钟读写的块数量。
Kilobytes per second read/write。每秒钟读写的数据量。
</p>
</div>
</div>
</div>



<div id="outline-container-orgecb25f4" class="outline-2">
<h2 id="orgecb25f4">第二章 监控和基准测试工具</h2>
<div class="outline-text-2" id="text-orgecb25f4">
<p>
下表列出了常用的性能监控工具
</p>

<p>
<code>==========</code>      <code>=========</code>
工具               主要功能
<code>==========</code>      <code>=========</code>
top                进程活动
vmstat             系统活动、硬件和系统信息
uptime, w          平均系统负载
ps, pstree         显示进程
free               内存使用情况
iostat             平均CPU负载，磁盘活动
sar                搜集和报告系统活动
mpstat             多处理器使用率
numastat           NUMA相关统计信息
pmap               进程内存管理
netstat            网络统计
iptraf             实时网络统计
tcpdump, ethereal  网络流量分析
nmon               搜集和报告系统活动
strace             系统调用
Proc file system   内核统计
hdparm             查看磁盘参数
tune2fs            查看磁盘参数
i7z                查看中断分布
</p>

<p>
基准测试工具
</p>

<p>
<code>=========</code>    <code>=========</code>
工具            主要功能
lmbench         操作系统函数基准测试
iozone          文件系统基准测试
netperf         网络性能基准测试
</p>
</div>

<div id="outline-container-org9523c9b" class="outline-3">
<h3 id="org9523c9b">监控工具</h3>
<div class="outline-text-3" id="text-org9523c9b">
<p>
top命令。top命令展示了进程活动。它输出的格列为：
</p>

<p>
PID。进程编号。
USER。进程属主。
PRI。进程优先级。
NI。niceness值。
SIZE。进程使用的内存（code+date+stack），单位KB。
RSS。进程使用的物理内存，单位KB。
SHARE。和其他进程共享的内存，单位KB。
STAT。进程状态。S是休眠，R是运行，T是停止或跟踪（traced），D是可中断休眠，Z是僵尸进程。
%CPU。CPU使用率。
%MEM。物理内存使用率。
TIME。进程累计使用的CPU时间。
COMMAND。启动任务的命令行。
</p>

<p>
top命令如下热键：
</p>

<p>
t。打开/关闭总结信息。
m。打开/关闭内存信息。
A。排序。
f。进入交互配置屏幕。
o。交互选择排序列。
r。运行renice命令。
k。运行kill命令。
</p>

<p>
vmstat。vmstat提供了进程的信息，诸如内存、paging、block I/O、traps、CPU活动等。vmstat输出的第一行是自系统启动以来的平均值。vmstat输出个各列如下：
</p>

<p>
r。运行队列长度。
b。不可中断休眠进程数。
swpd。虚拟内存使用量，单位KB。
free。空闲内存，单位KB。
buff。用作缓冲区的内存，单位KB。
cache。用作缓存的内存，单位KB。
si。从磁盘交换到内存的数据，单位KBps。
so。从内存交换到磁盘的数据，单位KBps。
bi。发送给块设备的数据，单位blocks/s。
bo。从块设备接收的数据，单位blocks/s。
in。每秒中断数，含时钟中断。
cs。每秒上下文切换数。
us。非内核代码执行时间，含（nice时间）。
sy。内核代码执行时间（system time）。
id。空闲时间。
wa。等待I/O时间。
</p>

<p>
vmstat支持通过参数调整统计的数据：
</p>

<p>
-m 显示内核内存使用情况（slabs）
-a 显示active/inactive内存
-n 只显示一行
</p>

<p>
当使用参数-p（需要配合其他参数）时，vmstat可以查看I/O信息。
</p>

<p>
uptime。uptime命令可以查看启动了多久，以及当前有哪些用户登录。uptime显示最近1分钟、5分钟、15分钟内的系统负载。命令w可以代替uptime。
</p>

<p>
ps和pstree。ps命令列出了当前进程。pstree同时会显示进程树结构。pgrep可以根据条件过滤进程。ps命令支持的参数有：
</p>

<p>
-e 列出全部进程，同-A。
-l 以长格式显示。
-F 以全模式显示。
-H 显示进程结构。
-L 显示线程。
-m 在进程后显示线程。
</p>

<p>
ps命令各列如下：
</p>

<p>
F。进程标志（flag）。
S。进程状态。S是休眠，R是运行，T是停止或跟踪，D是不可中断休眠，Z是僵尸进程。
UID。进程属主编号。
PID。进程编号。
PPID。父进程编号。
LWP。线程编号。
C。CPU使用率。
NLWP。进程中的线程数，即thcount。
PRI。进程优先级。
NI。niceness值。
ADDR。进程地址空间。
SZ。进程使用的内存（code+data+stack），单位KB。
WCHAN。当前进程休眠于哪个内核函数。
RSS。Resident set size，进程使用的物理内存，单位kB。
PSR。进程分配的处理器。
STIME。进程启动时间。
TTY。终端。
TIME。进程累计使用的CPU时间。
CMD。启动进程的命令行。
</p>

<p>
free。free命令显示了内存信息。free命令的输出类似::
</p>

<p>
             total       used       free     shared    buffers     cached
Mem:       3528540    2679084     849456        428     432024    1387608
-/+ buffers/cache:     859452    2669088 
Swap:      4194300          0    4194300 
</p>

<p>
其中-/+ buffers/cache一行对应的free是系统当前可用的全部内存（free+buffers+cached）。free命令的参数如下：
</p>

<p>
-b,-k,-m,-g 以字节、KB、MB、GB为单位显示。
-l 显示high/low zone内存使用情况。
</p>

<p>
查看文件/proc/buddyinfo可以了解系统中每个区域（zone）可用的内存块（chunk）：
</p>

<p>
Node 0, zone      DMA      1      1      2      1      2      0      0      0      1      1      3 
Node 0, zone    DMA32   8509   4965   2758    675    936    260    277    350    149      6      4 
Node 0, zone   Normal    543   1556    666     94    159    147     94     67     44      1      2
</p>

<p>
从数字列开始计算，第n列表示大小为2^(n-1)*PAGE_SIZE的空闲chunk数量。比如在上例中，在DMA区域内，大小为2^3*PAGE_SIZE的空闲块数量是675。
</p>

<p>
iostat。iostat命令显示了启动以来CPU使用情况和磁盘情况。iostat命令的各列为：
</p>

<p>
Device。块设备名。
tps。transfers per second。transfer是一个I/O请求，或多个I/O请求的合并。
Blk_read/s，Blk_wrtn/s。每秒读/写块数。
Blk_read，Blk_wrtn。累计读/写块数。
</p>

<p>
块大小可以通过::
</p>

<p>
dumpe2fs -h /dev/sda1 | grep -F "Block size"
</p>

<p>
获得。
</p>

<p>
当使用-x参数时，iostat会显示更多信息：
</p>

<p>
rrqm/s，wrqm/s。读/写请求每秒合并次数。
r/s，w/s。每秒提交给设备的读/写请求数。
rsec/s，wsec/s。设备每秒读/写的扇区数。
rkB/s，wkB/s。每秒读/写的字节数，单位kB。
avgrq-sz。提交给设备的请求大小平均值，以扇区为单位。
avgqu-sz。提交给设备的请求队列长度平均值。
await。内核CPU使用率。
svctm。I/O请求服务时间平均值，单位ms。
%util。设备带宽使用率。达到100%时，设备发生饥饿。
</p>

<p>
sar。sar命令用于收集、报告和保存系统信息。sar将数据保存在/var/log/sysstat/目录。下面是sar命令使用示例::
</p>

<p>
sar -u 2 5
sar -A
</p>

<p>
isag可以提供了查看sar数据的图形化工具。
</p>

<p>
mpstat。mpstat用于了解多CPU系统中的CPU使用情况::
</p>

<p>
[root@i-25512154 ~]# mpstat -P ALL
Linux 2.6.32-573.el6.x86_64 (i-25512154) 	2019年01月11日 	_x86_64_ (2 CPU)
</p>

<p>
14时49分36秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest   %idle
14时49分36秒  all    0.37    0.00    0.31    0.01    0.00    0.00    0.00    0.00   99.31
14时49分36秒    0    0.39    0.00    0.31    0.01    0.00    0.00    0.00    0.00   99.27
14时49分36秒    1    0.35    0.00    0.31    0.00    0.00    0.00    0.00    0.00   99.34
</p>

<p>
numastat。numastaa用于监控NUMA系统的行为。NUMA（Non-Uniform Memory Architecture）系统中，内存局部性（memory locality）对性能非常重要::
</p>

<p>
[root@i-25512154 ~]# numastat
                           node0
numa_hit             13958403517
numa_miss                      0
numa_foreign                   0
interleave_hit             25788
local_node           13958403517
other_node                     0
</p>

<p>
pmap。pmap用于包括进程的内存使用情况::
</p>

<p>
[root@i-25512154 ~]# pmap -d 1
1:   /sbin/init
Address           Kbytes Mode  Offset           Device    Mapping
00007f11e4488000      48 r-x&#x2013; 0000000000000000 0fd:00000 libnss_files-2.12.so
00007f11e4494000    2048 &#x2013;&#x2014; 000000000000c000 0fd:00000 libnss_files-2.12.so
00007f11e4694000       4 r-&#x2014; 000000000000c000 0fd:00000 libnss_files-2.12.so
00007f11e4695000       4 rw&#x2014; 000000000000d000 0fd:00000 libnss_files-2.12.so
00007f11e4696000    1576 r-x&#x2013; 0000000000000000 0fd:00000 libc-2.12.so
00007f11e4820000    2048 &#x2013;&#x2014; 000000000018a000 0fd:00000 libc-2.12.so
00007f11e4a20000      16 r-&#x2014; 000000000018a000 0fd:00000 libc-2.12.so
00007f11e4a24000       4 rw&#x2014; 000000000018e000 0fd:00000 libc-2.12.so
00007f11e4a25000      20 rw&#x2014; 0000000000000000 000:00000   [ anon ]
00007f11e4a2a000      88 r-x&#x2013; 0000000000000000 0fd:00000 libgcc_s-4.4.7-20120601.so.1
00007f11e4a40000    2044 &#x2013;&#x2014; 0000000000016000 0fd:00000 libgcc_s-4.4.7-20120601.so.1
00007f11e4c3f000       4 rw&#x2014; 0000000000015000 0fd:00000 libgcc_s-4.4.7-20120601.so.1
00007f11e4c40000      28 r-x&#x2013; 0000000000000000 0fd:00000 librt-2.12.so
00007f11e4c47000    2044 &#x2013;&#x2014; 0000000000007000 0fd:00000 librt-2.12.so
00007f11e4e46000       4 r-&#x2014; 0000000000006000 0fd:00000 librt-2.12.so
00007f11e4e47000       4 rw&#x2014; 0000000000007000 0fd:00000 librt-2.12.so
00007f11e4e48000      92 r-x&#x2013; 0000000000000000 0fd:00000 libpthread-2.12.so
00007f11e4e5f000    2048 &#x2013;&#x2014; 0000000000017000 0fd:00000 libpthread-2.12.so
00007f11e505f000       4 r-&#x2014; 0000000000017000 0fd:00000 libpthread-2.12.so
00007f11e5060000       4 rw&#x2014; 0000000000018000 0fd:00000 libpthread-2.12.so
00007f11e5061000      16 rw&#x2014; 0000000000000000 000:00000   [ anon ]
00007f11e5065000     256 r-x&#x2013; 0000000000000000 0fd:00000 libdbus-1.so.3.4.0
00007f11e50a5000    2044 &#x2013;&#x2014; 0000000000040000 0fd:00000 libdbus-1.so.3.4.0
00007f11e52a4000       4 r-&#x2014; 000000000003f000 0fd:00000 libdbus-1.so.3.4.0
00007f11e52a5000       4 rw&#x2014; 0000000000040000 0fd:00000 libdbus-1.so.3.4.0
00007f11e52a6000      36 r-x&#x2013; 0000000000000000 0fd:00000 libnih-dbus.so.1.0.0
00007f11e52af000    2044 &#x2013;&#x2014; 0000000000009000 0fd:00000 libnih-dbus.so.1.0.0
00007f11e54ae000       4 r-&#x2014; 0000000000008000 0fd:00000 libnih-dbus.so.1.0.0
00007f11e54af000       4 rw&#x2014; 0000000000009000 0fd:00000 libnih-dbus.so.1.0.0
00007f11e54b0000      96 r-x&#x2013; 0000000000000000 0fd:00000 libnih.so.1.0.0
00007f11e54c8000    2044 &#x2013;&#x2014; 0000000000018000 0fd:00000 libnih.so.1.0.0
00007f11e56c7000       4 r-&#x2014; 0000000000017000 0fd:00000 libnih.so.1.0.0
00007f11e56c8000       4 rw&#x2014; 0000000000018000 0fd:00000 libnih.so.1.0.0
00007f11e56c9000     128 r-x&#x2013; 0000000000000000 0fd:00000 ld-2.12.so
00007f11e58d8000      20 rw&#x2014; 0000000000000000 000:00000   [ anon ]
00007f11e58e7000       4 rw&#x2014; 0000000000000000 000:00000   [ anon ]
00007f11e58e8000       4 r-&#x2014; 000000000001f000 0fd:00000 ld-2.12.so
00007f11e58e9000       4 rw&#x2014; 0000000000020000 0fd:00000 ld-2.12.so
00007f11e58ea000       4 rw&#x2014; 0000000000000000 000:00000   [ anon ]
00007f11e58eb000     140 r-x&#x2013; 0000000000000000 0fd:00000 init
00007f11e5b0d000       8 r-&#x2014; 0000000000022000 0fd:00000 init
00007f11e5b0f000       4 rw&#x2014; 0000000000024000 0fd:00000 init
00007f11e6b64000     264 rw&#x2014; 0000000000000000 000:00000   [ anon ]
00007ffcb7417000      84 rw&#x2014; 0000000000000000 000:00000   [ stack ]
00007ffcb746b000       4 r-x&#x2013; 0000000000000000 000:00000   [ anon ]
ffffffffff600000       4 r-x&#x2013; 0000000000000000 000:00000   [ anon ]
mapped: 19364K    writeable/private: 452K    shared: 0K
</p>

<p>
netstat。netstat用于监控网络::
</p>

<p>
-a 套接字信息
-r 路由信息
-i 网卡信息
-s 网络协议信息
</p>

<p>
netstat输出各列为：
</p>

<p>
Proto。协议。
Recv-Q。接收队列长度。
Send-Q。发送队列长度。
Local Address。本地地址。
Foreign Address。远程地址。
State。套接字状态。
</p>

<p>
iptraf。iptraf监控试试网络流量。
</p>

<p>
tcpdump。tcpdump和ethereal用户捕获和分析流量。tcpdump的参数有：
</p>

<p>
-i &lt;interface&gt; 网络接口。
-e 打印链路层头。
-s &lt;snaplen&gt; 每个包捕获&lt;snaplen&gt;字节。
-n 避免DNS查询。
-w &lt;file&gt; 写入文件。
-r &lt;file&gt; 读取文件。
-v, -vv, -vvv 详细输出。
</p>

<p>
捕获过滤器：
</p>

<p>
关键词：
</p>

<p>
host, dst, src, port, src port, dst port, tcp, udp, icmp, net, dst net, src net 等等
</p>

<p>
组合词：
</p>

<p>
!, not, &amp;&amp;, and, ||, or
</p>

<p>
示例：
</p>

<p>
DNS查询包::
</p>

<p>
tcpdump -i eth0 'udp port 53'
</p>

<p>
到192.168.1.10的FTP控制和FTP数据包::
</p>

<p>
tcpdump -i eth0 'dst 192.168.1.10 and (port ftp or ftp-data)'
</p>

<p>
到192.168.2.253的HTTP数据::
</p>

<p>
tcpdump -ni eth0 'dst 192.168.2.253 and tcp and port 80'
</p>

<p>
到子网192.168.2.0/24的telnet数据::
</p>

<p>
tcpdump -ni eth0 'dst net 192.168.2.0/24 and tcp and port 22'
</p>

<p>
源和目标不是子网192.168.1.0/24的，带有TCP SYN或TCP FIN标志的包::
</p>

<p>
tcpdump 'tcp[tcpflags] &amp; (tcp-syn|tcp-fin) != 0 and not src and dst net 192.168.10/24'
</p>

<p>
strace。strace记录一个进程使用的系统调用::
</p>

<p>
strace -p &lt;pid&gt;       # 显示系统调用
strace -c &lt;command&gt;   # 显示系统调用次数和耗时
</p>

<p>
proc文件系统。
</p>

<p>
tc。
</p>
</div>
</div>

<div id="outline-container-orgf0b808a" class="outline-3">
<h3 id="orgf0b808a">基准测试工具</h3>
<div class="outline-text-3" id="text-orgf0b808a">
<p>
基准测试工具需要：
</p>

<p>
生成负载。
监控性能。
监控系统使用率。
报告。
</p>

<p>
基准测试时需要：
</p>

<p>
使用实际服务器进行基准测试。
模拟预期负载。
隔离目标系统。
计算均值。
</p>

<p>
LMbench。LMbench可以测量上下文切换、本地通信、内存带宽、文件操作等。
</p>

<p>
IOzone。IOzone用于测试文件系统。
</p>

<p>
netperf。netperf用于测试网络。
</p>

<p>
iometer。测试磁盘I/O和网络。
</p>

<p>
ttcp。测试网络。
</p>

<p>
nttcp。测试网络。
</p>

<p>
JMeter。Web服务器性能测试。
</p>
</div>
</div>
</div>

<div id="outline-container-org0876699" class="outline-2">
<h2 id="org0876699">第三章 分析性能瓶颈</h2>
<div class="outline-text-2" id="text-org0876699">
</div>
<div id="outline-container-orgba77c62" class="outline-3">
<h3 id="orgba77c62">确认瓶颈</h3>
<div class="outline-text-3" id="text-orgba77c62">
<p>
确认瓶颈的步骤：
</p>

<ol class="org-ol">
<li>了解系统。</li>
<li>备份系统。</li>
<li>监控和分析系统性能。</li>
<li>缩小瓶颈范围，分析原因。</li>
<li>修复瓶颈原因，一次进行一个变更。</li>
<li>返回步骤3，直到性能满足要求。</li>
</ol>

<p>
性能日志应当包括：
</p>

<p>
处理器
系统
服务队列
内存
页文件
物理磁盘
重定向
网络接口
</p>
</div>
</div>

<div id="outline-container-orgd632a51" class="outline-3">
<h3 id="orgd632a51">CPU瓶颈</h3>
<div class="outline-text-3" id="text-orgd632a51">
<p>
CPU使用率高并非一定是CPU存在系统瓶颈。可能是CPU在等待其他子系统。使用uptime可以查看等待运行的任务数，top可以找到消耗CPU最多的进程，vmstat可以得到上下文切换和中断信息。在优化CPU性能时：
</p>

<p>
通过ps -ef检查进程，确保后台没有不必要的进程。检查cron，避免在高峰期执行定时任务。
通过top找到非关键的CPU密集型进程，使用renice调整优先级。
如果是SMP架构，使用taskset将进程绑定到CPU，避免进程在各CPU之间切换引起的缓存刷新。
考虑应用的具体情况。对于单线程应用程序，scale up比scale out更有效。
</p>
</div>
</div>

<div id="outline-container-orgd80c8ce" class="outline-3">
<h3 id="orgd80c8ce">内存瓶颈</h3>
<div class="outline-text-3" id="text-orgd80c8ce">
<p>
操作系统控制哪些程序使用物理内存，另外一些应用被page out。页空间（page space）是OS在磁盘上建立的，用来保存当下没有使用的内存。页大小通常占4KB或8KB，定义在include/asm-&lt;architecture&gt;/param.h中的EXEC_PAGESIZE。
</p>

<p>
检查内存瓶颈前首先要观察系统中运行的程序，确定已经使用的内存和交换空间。然后启动目标程序。分析内存的主要指标有：
</p>

<p>
可用内存。如果程序启动后，可用内存迅速下降，程序可能存在内存泄漏。
页错误（page fault）。页面在内存中找到会引发soft page fault，如果没有在内存中找到，需要从磁盘读取，会引发hard page fault。
文件系统缓存。
进程私有内存。每个进程的私有内存。
</p>

<p>
在所有类UNIX系统上，page和swap具有不同的含义。page指将独立的页交换到磁盘上，swap指将进程的整个地址空间交换到磁盘上。
</p>

<p>
交换有两种原因：
</p>

<p>
进程进入休眠模式。通常是由于进程依赖于交互行为并等待输入。
进程性能不佳。Paging可能是程序性能问题引发的。当系统可用页低于阈值，系统无法处理内存请求时，交换就会发生。这时交换会产生显著的磁盘I/O并显著降低服务器新年。
</p>

<p>
如果系统存在内存瓶颈，可以考虑下面的优化方法：
</p>

<p>
调整交换空间，使用bigpages、hugetlb或共享内存。
提高或降低页大小。
调整page-out rate。
限制每个用户在服务器上使用的资源。
关闭不需要的服务。
增加内存。
</p>
</div>
</div>

<div id="outline-container-org4410d70" class="outline-3">
<h3 id="org4410d70">磁盘瓶颈</h3>
<div class="outline-text-3" id="text-org4410d70">
<p>
慢磁盘会导致：
</p>

<p>
内存缓冲区填满了写入数据，或磁盘队列中填满了读请求。
低效内存。没有足够的缓冲区处理网络请求。
磁盘使用率高。
大部分LAN transfer在磁盘I/O完毕之后执行，导致响应时间过长，同时网络使用率低。
磁盘I/O耗时较长，且磁盘队列填满。CPU空闲，使用率降低，因为在处理下个请求前一直在等待。
</p>

<p>
磁盘优调建议：
</p>

<p>
如果工作负载时顺序的，压力在控制器带宽，方法是使用更快的磁盘控制器。如果工作负载是随机的，瓶颈可能在驱动程序。
Add more disk drives in a RAID environment。这会提高I/O per second。
增加内存。
</p>
</div>
</div>

<div id="outline-container-org63d0956" class="outline-3">
<h3 id="org63d0956">网络优化</h3>
<div class="outline-text-3" id="text-org63d0956">
<p>
网络监控指标：
</p>

<p>
收发包数量。
冲突包数量（collision packets）。
掉包数量（dropped packets）。
错误（errors）。
faulty adapters。
</p>

<p>
网络优调参数：
</p>

<p>
保证网卡配置匹配路由和switch configuratoin，比如frame size。
调整子网。
使用更快的网卡。
调整内核TCP参数。
增加网卡，绑定成一个adapter team。
</p>
</div>
</div>
</div>

<div id="outline-container-org5deab54" class="outline-2">
<h2 id="org5deab54">第四章 调整操作系统</h2>
<div class="outline-text-2" id="text-org5deab54">
<p>
检查当前系统配置。
</p>

<p>
dmesg。dmesg可以查看系统信息。
</p>

<p>
ulimit。ulimit是一个bash命令，用于控制进程资源。ulimit使用-H参数可以设置hard limit，使用-S参数设置soft limit。文件/etc/security/limits.conf定义了系统限制。
</p>

<p>
runlevel：
</p>

<p>
0 停止
1 单用户模式
2 多用户无网络模式
3 多用户模式
4 未使用
5 X11
6 重启
</p>

<p>
修改/etc/inittab可以调整启动模式。
/etc/sysctl.conf
</p>
</div>


<div id="outline-container-org7cd91e8" class="outline-3">
<h3 id="org7cd91e8">优调CPU子系统</h3>
<div class="outline-text-3" id="text-org7cd91e8">
<p>
绑定中断::
</p>

<p>
echo 03 &gt; /proc/irq/19/smp_affinity
cat /proc/interrupts
</p>

<p>
NUMA::
</p>

<p>
/sys/devices/system/node/%{node number}/numastat
</p>

<p>
nice/renice。
</p>

<p>
chrt。调整动态优先级。
</p>
</div>
</div>

<div id="outline-container-org04db646" class="outline-3">
<h3 id="org04db646">调整虚拟内存子系统</h3>
<div class="outline-text-3" id="text-org04db646">
<p>
交换空间：
</p>

<p>
参数vm.swappiness控制了系统对交换空间的偏好，0表示积极使用物理内存，100表示积极使用交换分区::
</p>

<p>
vm.swappiness # /etc/sysctl.conf
/proc/sys/vm/swappiness
sysctl -w vm.swappiness=100
</p>

<p>
参数vm.dirty_background_ratio是脏页面回写阈值。当脏页面比例超过这个值，后台进程pdflush/flush/kdmflush会刷写页面::
</p>

<p>
vm.dirty_background_ratio # /etc/sysctl.conf
/proc/sys/vm/dirty_background_ratio
sysctl -w vm.dirty_background_ratio=10
</p>

<p>
参数vm.dirty_ratio决定了系统中脏页面的上限。超过这个值，系统将阻塞后续的I/O操作::
</p>

<p>
vm.dirty_ratio # /etc/sysctl.conf
/proc/sys/vm/dirty_ratio
sysctl -w vm.drity_ratio=20
</p>

<p>
参数vm.dirty_background_bytes和vm.dirty_bytes与前面两个参数类似，使用了绝对值进行设置。
</p>

<p>
参数vm.dirty_writeback_centisecs决定了后台刷写进程的唤醒间隔。
</p>

<p>
参数vm.dirty_expire_centisecs决定了脏页面生命周期。
</p>

<p>
文件/proc/vmstat提供了虚拟内存信息,其中的nr_dirty*和nr_writeback*是关于脏页面的。
</p>

<p>
参数vm.nr_hugepages定义了HugeTLB数量::
</p>

<p>
/proc/sys/vm/nr_hugepages=512
</p>

<p>
如果通过mmap()使用huge page，需要挂载一个文件系统::
</p>

<p>
mount -t hugetlbfs none /mnt/hugepages
</p>

<p>
文件/proc/meminfo提供了HugePages信息。
</p>
</div>
</div>

<div id="outline-container-org8798bf1" class="outline-3">
<h3 id="org8798bf1">优调磁盘系统</h3>
<div class="outline-text-3" id="text-org8798bf1">
<p>
选择I/O elevator::
</p>

<p>
echo sched_name &gt; /sys/block/&lt;sdx&gt;/queue/schedule
</p>

<p>
调整I/O队列长度::
</p>

<p>
echo 64 &gt; /sys/block/sdb/queue/nr_requests
</p>

<p>
增加队列长度可以提高大量小文件写入性能。
</p>

<p>
调整预读大小::
</p>

<p>
echo 64 &gt; /sys/block/&lt;disk_subsystem&gt;/queue/read_ahead_kb
</p>

<p>
对于大数据量流读取，增加预读大小可以提高性能。但是对于随机读写，反而会降低性能。
</p>

<p>
调整进程I/O优先级::
</p>

<p>
ionice -c&lt;n&gt; -p&lt;pid&gt; # n: 1 real time 2 best-effort 3 idle
</p>

<p>
调整日志模式::
</p>

<p>
mount -o data=writeback /dev/sda1 /mnt/mountpoint
</p>

<p>
writeback提供了最高的写入速度，journal提供最佳的一致性，ordered介于二者之间，是默认配置。
</p>
</div>
</div>

<div id="outline-container-org06a8a9a" class="outline-3">
<h3 id="org06a8a9a">优调网络系统</h3>
<div class="outline-text-3" id="text-org06a8a9a">
<p>
调整MTU大小::
</p>

<p>
ifconfig eth0 mtu 9000 up
</p>

<p>
增加网络缓冲区::
</p>

<p>
/proc/sys/net/ipv4/tcp_mem
/proc/sys/net/core/rmem_default
/proc/sys/net/core/rmem_max
/proc/sys/net/core/wrem_default
/proc/sys/net/core/wrem_max
/proc/sys/net/core/optmem_max
</p>

<p>
调整窗口大小。理论上窗口大小等于BDP（bandwidth delay product）::
</p>

<p>
BDP = Bandwidth(bytes/sec) * Delay (or round trip time)(sec)
</p>

<p>
比如Gigabit以太LAN，如果延迟是1毫秒，BDP是：
</p>

<p>
125Mbytes/sec(1Gbit/sec)*1msec = 125Kbytes
</p>

<p>
缓冲区大小。如果rmem_max和wmem_max过低，甚至会影响窗口大小，导致性能下降。
</p>

<p>
避免spoofing攻击::
</p>

<p>
sysctl -w net.ipv4.conf.eth0.accept_source_route=0
sysctl -w net.ipv4.conf.lo.accept_source_route=0
sysctl -w net.ipv4.conf.default.accept_source_route=0
sysctl -w net.ipv4.conf.all.accept_source_route=0
</p>

<p>
只允许信任源转发::
</p>

<p>
sysctl -w net.ipv4.conf.eth0.secure_redirects=1
sysctl -w net.ipv4.conf.lo.secure_redirects=1
sysctl -w net.ipv4.conf.default.secure_redirects=1
sysctl -w net.ipv4.conf.all.secure_redirects=1
</p>

<p>
::
</p>

<p>
net.ipv4.conf.eth0.accept_redirects=0
net.ipv4.conf.eth0.send_redirects=0
net.ipv4.icmp_echo_ignore_all=1
net.ipv4.icmp_ignore_bogus_error_responses=1
net.ipv4.ipfrag_low_thresh=262144
net.ipv4.ipfrag_high_thresh=393216
</p>

<p>
调整TCP参数::
</p>

<p>
net.ipv4.tcp_tw_reuse=1
net.ipv4.tcp_tw_recycle=1
net.ipv4.tcp_fin_timeout=30
net.ipv4.tcp_keepalive_time=1800
net.ipv4.tcp_max_syn_backlog=4096
net.ipv4.tcp_syncookies=1
net.ipv4.tcp_sack=0
net.ipv4.tcp_dsack=0
net.ipv4.tcp_timestamps=0
net.ipv4.tcp_window_scaling=0
</p>

<p>
提高收包队列长度::
</p>

<p>
/proc/sys/net/core/netdev_max_backlog
</p>

<p>
增加传输队列长度::
</p>

<p>
ifconfig eth1 txqueuelen 2000 # 1000-20000
</p>

<p>
增加监听队列长度::
</p>

<p>
net.core.somaxconn=1024 # 默认128
</p>

<p>
调整本地端口区间::
</p>

<p>
net.ipv4.ip_local_port_range="1025 65535"
</p>
</div>
</div>
</div>

<div id="outline-container-orge9e6c0e" class="outline-2">
<h2 id="orge9e6c0e">参考资料</h2>
<div class="outline-text-2" id="text-orge9e6c0e">
<p>
Linux Performance and Tuning Guidelines
<a href="https://lonesysadmin.net/2013/12/22/better-linux-disk-caching-performance-vm-dirty_ratio/">https://lonesysadmin.net/2013/12/22/better-linux-disk-caching-performance-vm-dirty_ratio/</a>
<a href="https://www.ibm.com/support/knowledgecenter/en/SSQPD3_2.6.0/com.ibm.wllm.doc/wllm_performancetuning.html">https://www.ibm.com/support/knowledgecenter/en/SSQPD3_2.6.0/com.ibm.wllm.doc/wllm_performancetuning.html</a>
<a href="http://noops.me/">http://noops.me/</a>
<a href="http://public.dhe.ibm.com/software/dw/linux390/perf/network_tuning.pdf">http://public.dhe.ibm.com/software/dw/linux390/perf/network_tuning.pdf</a>
<a href="http://public.dhe.ibm.com/software/dw/linux390/perf/Linux_on_z_Systems_Disk_IO_Performance_2017_10_t.pdf">http://public.dhe.ibm.com/software/dw/linux390/perf/Linux_on_z_Systems_Disk_IO_Performance_2017_10_t.pdf</a>
<a href="http://noops.me/?p=747">http://noops.me/?p=747</a>
</p>

<p>
<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h">https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h</a>
</p>
</div>
</div>

<div id="outline-container-org7a49781" class="outline-2">
<h2 id="org7a49781">编辑记录</h2>
<div class="outline-text-2" id="text-org7a49781">
<p>
2019年03月12日 改为org格式。
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2019-09-23 周一 20:55</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
